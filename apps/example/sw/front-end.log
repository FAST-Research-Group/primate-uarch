Args: clang (LLVM option parsing) -debug -print-after-all 
In file included from tcp_parse.cpp:2:
./tcp_parse.h:2:18: warning: '_ExtInt' is deprecated; use '_BitInt' instead [-Wdeprecated-type]
    2 | typedef unsigned _ExtInt(16) uint16_t;
      |                  ^~~~~~~
      |                  _BitInt
./tcp_parse.h:3:18: warning: '_ExtInt' is deprecated; use '_BitInt' instead [-Wdeprecated-type]
    3 | typedef unsigned _ExtInt(8)  uint8_t;
      |                  ^~~~~~~
      |                  _BitInt
./tcp_parse.h:4:18: warning: '_ExtInt' is deprecated; use '_BitInt' instead [-Wdeprecated-type]
    4 | typedef unsigned _ExtInt(32) uint32_t;
      |                  ^~~~~~~
      |                  _BitInt
./tcp_parse.h:6:9: warning: '_ExtInt' is deprecated; use '_BitInt' instead [-Wdeprecated-type]
    6 | typedef _ExtInt(16) egressSpec_t;
      |         ^~~~~~~
      |         _BitInt
./tcp_parse.h:7:9: warning: '_ExtInt' is deprecated; use '_BitInt' instead [-Wdeprecated-type]
    7 | typedef _ExtInt(48) macAddr_t;
      |         ^~~~~~~
      |         _BitInt
./tcp_parse.h:18:5: warning: '_ExtInt' is deprecated; use '_BitInt' instead [-Wdeprecated-type]
   18 |     _ExtInt(72)  version_ttl;
      |     ^~~~~~~
      |     _BitInt
./tcp_parse.h:20:5: warning: '_ExtInt' is deprecated; use '_BitInt' instead [-Wdeprecated-type]
   20 |     _ExtInt(80) hdrChecksum_dstAddr;
      |     ^~~~~~~
      |     _BitInt
./tcp_parse.h:25:5: warning: '_ExtInt' is deprecated; use '_BitInt' instead [-Wdeprecated-type]
   25 |     _ExtInt(96)  srcPort_ackNo;
      |     ^~~~~~~
      |     _BitInt
./tcp_parse.h:26:5: warning: '_ExtInt' is deprecated; use '_BitInt' instead [-Wdeprecated-type]
   26 |     _ExtInt(4)   dataOffset;
      |     ^~~~~~~
      |     _BitInt
./tcp_parse.h:27:5: warning: '_ExtInt' is deprecated; use '_BitInt' instead [-Wdeprecated-type]
   27 |     _ExtInt(60)  res_urgentPtr;
      |     ^~~~~~~
      |     _BitInt
./tcp_parse.h:32:5: warning: '_ExtInt' is deprecated; use '_BitInt' instead [-Wdeprecated-type]
   32 |     _ExtInt(8)  kind;
      |     ^~~~~~~
      |     _BitInt
./tcp_parse.h:37:3: warning: '_ExtInt' is deprecated; use '_BitInt' instead [-Wdeprecated-type]
   37 |   _BitInt(128) padding1;
      |   ^
./tcp_parse.h:1:20: note: expanded from macro '_BitInt'
    1 | #define _BitInt(x) _ExtInt(x) 
      |                    ^
./tcp_parse.h:38:3: warning: '_ExtInt' is deprecated; use '_BitInt' instead [-Wdeprecated-type]
   38 |   _BitInt(128) padding2;
      |   ^
./tcp_parse.h:1:20: note: expanded from macro '_BitInt'
    1 | #define _BitInt(x) _ExtInt(x) 
      |                    ^
./tcp_parse.h:43:5: warning: '_ExtInt' is deprecated; use '_BitInt' instead [-Wdeprecated-type]
   43 |     _ExtInt(64)  srcPort_checksum;
      |     ^~~~~~~
      |     _BitInt
tcp_parse.cpp:23:30: warning: '_ExtInt' is deprecated; use '_BitInt' instead [-Wdeprecated-type]
   23 |                     unsigned _ExtInt(8) kind;
      |                              ^~~~~~~
      |                              _BitInt
tcp_parse.cpp:24:52: warning: '_ExtInt' is deprecated; use '_BitInt' instead [-Wdeprecated-type]
   24 |                     kind = PRIMATE::input<unsigned _ExtInt(8)>();
      |                                                    ^~~~~~~
      |                                                    _BitInt
tcp_parse.cpp:28:34: warning: '_ExtInt' is deprecated; use '_BitInt' instead [-Wdeprecated-type]
   28 |                         unsigned _ExtInt(8) tcp_option;
      |                                  ^~~~~~~
      |                                  _BitInt
tcp_parse.cpp:30:50: warning: '_ExtInt' is deprecated; use '_BitInt' instead [-Wdeprecated-type]
   30 |                         PRIMATE::output<unsigned _ExtInt(8)>(tcp_option);
      |                                                  ^~~~~~~
      |                                                  _BitInt
tcp_parse.cpp:32:34: warning: '_ExtInt' is deprecated; use '_BitInt' instead [-Wdeprecated-type]
   32 |                         unsigned _ExtInt(128) padding;
      |                                  ^~~~~~~
      |                                  _BitInt
tcp_parse.cpp:34:63: warning: '_ExtInt' is deprecated; use '_BitInt' instead [-Wdeprecated-type]
   34 |                             padding = PRIMATE::input<unsigned _ExtInt(128)>();
      |                                                               ^~~~~~~
      |                                                               _BitInt
tcp_parse.cpp:35:54: warning: '_ExtInt' is deprecated; use '_BitInt' instead [-Wdeprecated-type]
   35 |                             PRIMATE::output<unsigned _ExtInt(128)>(padding);
      |                                                      ^~~~~~~
      |                                                      _BitInt
tcp_parse.cpp:41:34: warning: '_ExtInt' is deprecated; use '_BitInt' instead [-Wdeprecated-type]
   41 |                         unsigned _ExtInt(8) tcp_option;
      |                                  ^~~~~~~
      |                                  _BitInt
tcp_parse.cpp:44:50: warning: '_ExtInt' is deprecated; use '_BitInt' instead [-Wdeprecated-type]
   44 |                         PRIMATE::output<unsigned _ExtInt(8)>(tcp_option);
      |                                                  ^~~~~~~
      |                                                  _BitInt
Clearing AST...
Init Target Machine for CPU: 
This is a string
; *** IR Dump After Annotation2MetadataPass on [module] ***
; ModuleID = 'tcp_parse.cpp'
source_filename = "tcp_parse.cpp"
target datalayout = "e-G1-m:e-p:32:32-i64:64-n32-S128"
target triple = "primate32-unknown-linux-gnu"

%struct.ethernet_t = type { i48, i48, i16 }
%struct.ipv4_t = type { i72, i8, i80 }
%struct.tcp_t = type { i96, i4, i60 }
%struct.udp_t = type { i64 }

$_ZN7PRIMATE5inputI10ethernet_tEET_v = comdat any

$_ZN7PRIMATE6outputI10ethernet_tEEvT_ = comdat any

$_ZN7PRIMATE5inputI6ipv4_tEET_v = comdat any

$_ZN7PRIMATE6outputI6ipv4_tEEvT_ = comdat any

$_ZN7PRIMATE5inputI5tcp_tEET_v = comdat any

$_ZN7PRIMATE6outputI5tcp_tEEvT_ = comdat any

$_ZN7PRIMATE5inputIDU8_EET_v = comdat any

$_ZN7PRIMATE6outputIDU8_EEvT_ = comdat any

$_ZN7PRIMATE5inputIDU128_EET_v = comdat any

$_ZN7PRIMATE6outputIDU128_EEvT_ = comdat any

$_ZN7PRIMATE5inputI5udp_tEET_v = comdat any

$_ZN7PRIMATE6outputI5udp_tEEvT_ = comdat any

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.done() #1

; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() #2 {
entry:
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %udp = alloca %struct.udp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %hdr_byte_left = alloca i32, align 4
  %n = alloca i32, align 4
  %kind = alloca i8, align 1
  %tcp_option = alloca i8, align 1
  %i = alloca i32, align 4
  %padding = alloca i128, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %tcp_option24 = alloca i8, align 1
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.start.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr %ref.tmp) #1
  call void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind writable sret(%struct.ethernet_t) align 8 %ref.tmp), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %eth, ptr align 8 %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp, ptr align 8 %eth, i32 24, i1 false), !tbaa.struct !8
  call void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %agg.tmp), !primate !7
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %0 = load i16, ptr %etherType, align 8, !tbaa !15
  %conv = zext i16 %0 to i32
  %cmp = icmp eq i32 %conv, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr %ref.tmp1) #1
  call void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind writable sret(%struct.ipv4_t) align 8 %ref.tmp1), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %ipv4, ptr align 8 %ref.tmp1, i32 40, i1 false), !tbaa.struct !17
  call void @llvm.lifetime.end.p0(i64 40, ptr %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp2, ptr align 8 %ipv4, i32 40, i1 false), !tbaa.struct !17
  call void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %agg.tmp2), !primate !7
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %1 = load i8, ptr %protocol, align 8, !tbaa !24
  %conv3 = zext i8 %1 to i32
  %cmp4 = icmp eq i32 %conv3, 6
  br i1 %cmp4, label %if.then5, label %if.else29

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr %ref.tmp6) #1
  call void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind writable sret(%struct.tcp_t) align 8 %ref.tmp6), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %tcp, ptr align 8 %ref.tmp6, i32 32, i1 false), !tbaa.struct !26
  call void @llvm.lifetime.end.p0(i64 32, ptr %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp7, ptr align 8 %tcp, i32 32, i1 false), !tbaa.struct !26
  call void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %agg.tmp7), !primate !7
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %2 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv8 = sext i4 %2 to i32
  %cmp9 = icmp sgt i32 %conv8, 0
  br i1 %cmp9, label %if.then10, label %if.end28

if.then10:                                        ; preds = %if.then5
  call void @llvm.lifetime.start.p0(i64 4, ptr %hdr_byte_left) #1
  %dataOffset11 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %3 = load i4, ptr %dataOffset11, align 8, !tbaa !33
  %conv12 = sext i4 %3 to i32
  %sub = sub i32 %conv12, 5
  %mul = mul i32 4, %sub
  store i32 %mul, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 4, ptr %n) #1
  store i32 0, ptr %n, align 4, !tbaa !35
  br label %while.cond

while.cond:                                       ; preds = %cleanup.cont, %if.then10
  %4 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp13 = icmp sgt i32 %4, 0
  br i1 %cmp13, label %while.body, label %while.end27

while.body:                                       ; preds = %while.cond
  call void @llvm.lifetime.start.p0(i64 1, ptr %kind) #1
  %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
  store i8 %call, ptr %kind, align 1, !tbaa !20
  %5 = load i8, ptr %kind, align 1, !tbaa !20
  %conv14 = zext i8 %5 to i32
  %cmp15 = icmp eq i32 %conv14, 0
  br i1 %cmp15, label %if.then16, label %if.else

if.then16:                                        ; preds = %while.body
  %6 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec = add nsw i32 %6, -1
  store i32 %dec, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option) #1
  %7 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %7, ptr %tcp_option, align 1, !tbaa !20
  %8 = load i8, ptr %tcp_option, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %8), !primate !7
  call void @llvm.lifetime.start.p0(i64 4, ptr %i) #1
  store i32 0, ptr %i, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 16, ptr %padding) #1
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %9 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp18 = icmp sgt i32 %9, 0
  br i1 %cmp18, label %while.body19, label %while.end

while.body19:                                     ; preds = %while.cond17
  call void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind writable sret(i128) align 8 %tmp), !primate !7
  %10 = load i128, ptr %tmp, align 8, !tbaa !37
  store i128 %10, ptr %padding, align 8, !tbaa !37
  %11 = load i128, ptr %padding, align 8, !tbaa !37
  store i128 %11, ptr %indirect-arg-temp, align 8, !tbaa !37
  call void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %indirect-arg-temp), !primate !7
  %12 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %sub20 = sub nsw i32 %12, 16
  store i32 %sub20, ptr %hdr_byte_left, align 4, !tbaa !35
  br label %while.cond17, !llvm.loop !39

while.end:                                        ; preds = %while.cond17
  store i32 3, ptr %cleanup.dest.slot, align 4
  call void @llvm.lifetime.end.p0(i64 16, ptr %padding) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %i) #1
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option) #1
  br label %cleanup

if.else:                                          ; preds = %while.body
  %13 = load i8, ptr %kind, align 1, !tbaa !20
  %conv21 = zext i8 %13 to i32
  %cmp22 = icmp eq i32 %conv21, 1
  br i1 %cmp22, label %if.then23, label %if.end

if.then23:                                        ; preds = %if.else
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option24) #1
  %14 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %14, ptr %tcp_option24, align 1, !tbaa !20
  %15 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec25 = add nsw i32 %15, -1
  store i32 %dec25, ptr %hdr_byte_left, align 4, !tbaa !35
  %16 = load i8, ptr %tcp_option24, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %16), !primate !7
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option24) #1
  br label %if.end

if.end:                                           ; preds = %if.then23, %if.else
  br label %if.end26

if.end26:                                         ; preds = %if.end
  %17 = load i32, ptr %n, align 4, !tbaa !35
  %inc = add nsw i32 %17, 1
  store i32 %inc, ptr %n, align 4, !tbaa !35
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end26, %while.end
  call void @llvm.lifetime.end.p0(i64 1, ptr %kind) #1
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 3, label %while.end27
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %while.cond, !llvm.loop !41

while.end27:                                      ; preds = %cleanup, %while.cond
  call void @llvm.lifetime.end.p0(i64 4, ptr %n) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %hdr_byte_left) #1
  br label %if.end28

if.end28:                                         ; preds = %while.end27, %if.then5
  br label %if.end37

if.else29:                                        ; preds = %if.then
  %protocol30 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %18 = load i8, ptr %protocol30, align 8, !tbaa !24
  %conv31 = zext i8 %18 to i32
  %cmp32 = icmp eq i32 %conv31, 17
  br i1 %cmp32, label %if.then33, label %if.end36

if.then33:                                        ; preds = %if.else29
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp34) #1
  call void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind writable sret(%struct.udp_t) align 8 %ref.tmp34), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %udp, ptr align 8 %ref.tmp34, i32 8, i1 false), !tbaa.struct !42
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp34) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp35, ptr align 8 %udp, i32 8, i1 false), !tbaa.struct !42
  call void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %agg.tmp35), !primate !7
  br label %if.end36

if.end36:                                         ; preds = %if.then33, %if.else29
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.end28
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %entry
  call void @_ZN7PRIMATE10input_doneEv(), !primate !7
  call void @llvm.lifetime.end.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.end.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr %eth) #1
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ethernet_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 24, i1 false), !tbaa.struct !8
  ret void
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i32(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i32, i1 immarg) #4

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 24)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ipv4_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 40)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 40, i1 false), !tbaa.struct !17
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 40)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.tcp_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 32)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 32, i1 false), !tbaa.struct !26
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 32)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v() #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %1 = load i8, ptr %0, align 1, !tbaa !20
  ret i8 %1
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %out) #0 comdat !primate !7 {
entry:
  %out.addr = alloca i8, align 1
  store i8 %out, ptr %out.addr, align 1, !tbaa !20
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 1)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind noalias writable sret(i128) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 16)
  %1 = load i128, ptr %0, align 8, !tbaa !37
  store i128 %1, ptr %agg.result, align 8
  %2 = load i128, ptr %agg.result, align 8
  store i128 %2, ptr %agg.result, align 8, !tbaa !37
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %0) #0 comdat !primate !7 {
entry:
  %out.addr = alloca i128, align 8
  %out = load i128, ptr %0, align 8, !tbaa !37
  store i128 %out, ptr %out.addr, align 8, !tbaa !37
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 16)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.udp_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 8)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 8, i1 false), !tbaa.struct !42
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 8)
  ret void
}

; Function Attrs: nounwind
declare !primate !7 ptr @llvm.primate.input.p0.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.p0.i32(ptr, i32) #1

attributes #0 = { alwaysinline mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #1 = { nounwind }
attributes #2 = { mustprogress "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #3 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5}
!llvm.ident = !{!6}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"ilp32"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{i32 8, !"SmallDataLimit", i32 8}
!6 = !{!"clang version 18.1.8 (git@github.com:FAST-Research-Group/primate-arch-gen.git e8582d4315ec2267abfc97212fa19f342d0812e8)"}
!7 = !{!"blue", !"IO", i64 1, i64 1}
!8 = !{i64 0, i64 8, !9, i64 8, i64 8, !9, i64 16, i64 2, !13}
!9 = !{!10, !10, i64 0}
!10 = !{!"_BitInt(48)", !11, i64 0}
!11 = !{!"omnipotent char", !12, i64 0}
!12 = !{!"Simple C++ TBAA"}
!13 = !{!14, !14, i64 0}
!14 = !{!"_BitInt(16)", !11, i64 0}
!15 = !{!16, !14, i64 16}
!16 = !{!"_ZTS10ethernet_t", !10, i64 0, !10, i64 8, !14, i64 16}
!17 = !{i64 0, i64 16, !18, i64 16, i64 1, !20, i64 24, i64 16, !22}
!18 = !{!19, !19, i64 0}
!19 = !{!"_BitInt(72)", !11, i64 0}
!20 = !{!21, !21, i64 0}
!21 = !{!"_BitInt(8)", !11, i64 0}
!22 = !{!23, !23, i64 0}
!23 = !{!"_BitInt(80)", !11, i64 0}
!24 = !{!25, !21, i64 16}
!25 = !{!"_ZTS6ipv4_t", !19, i64 0, !21, i64 16, !23, i64 24}
!26 = !{i64 0, i64 16, !27, i64 16, i64 1, !29, i64 24, i64 8, !31}
!27 = !{!28, !28, i64 0}
!28 = !{!"_BitInt(96)", !11, i64 0}
!29 = !{!30, !30, i64 0}
!30 = !{!"_BitInt(4)", !11, i64 0}
!31 = !{!32, !32, i64 0}
!32 = !{!"_BitInt(60)", !11, i64 0}
!33 = !{!34, !30, i64 16}
!34 = !{!"_ZTS5tcp_t", !28, i64 0, !30, i64 16, !32, i64 24}
!35 = !{!36, !36, i64 0}
!36 = !{!"int", !11, i64 0}
!37 = !{!38, !38, i64 0}
!38 = !{!"_BitInt(128)", !11, i64 0}
!39 = distinct !{!39, !40}
!40 = !{!"llvm.loop.mustprogress"}
!41 = distinct !{!41, !40}
!42 = !{i64 0, i64 8, !43}
!43 = !{!44, !44, i64 0}
!44 = !{!"_BitInt(64)", !11, i64 0}
; *** IR Dump After ForceFunctionAttrsPass on [module] ***
; ModuleID = 'tcp_parse.cpp'
source_filename = "tcp_parse.cpp"
target datalayout = "e-G1-m:e-p:32:32-i64:64-n32-S128"
target triple = "primate32-unknown-linux-gnu"

%struct.ethernet_t = type { i48, i48, i16 }
%struct.ipv4_t = type { i72, i8, i80 }
%struct.tcp_t = type { i96, i4, i60 }
%struct.udp_t = type { i64 }

$_ZN7PRIMATE5inputI10ethernet_tEET_v = comdat any

$_ZN7PRIMATE6outputI10ethernet_tEEvT_ = comdat any

$_ZN7PRIMATE5inputI6ipv4_tEET_v = comdat any

$_ZN7PRIMATE6outputI6ipv4_tEEvT_ = comdat any

$_ZN7PRIMATE5inputI5tcp_tEET_v = comdat any

$_ZN7PRIMATE6outputI5tcp_tEEvT_ = comdat any

$_ZN7PRIMATE5inputIDU8_EET_v = comdat any

$_ZN7PRIMATE6outputIDU8_EEvT_ = comdat any

$_ZN7PRIMATE5inputIDU128_EET_v = comdat any

$_ZN7PRIMATE6outputIDU128_EEvT_ = comdat any

$_ZN7PRIMATE5inputI5udp_tEET_v = comdat any

$_ZN7PRIMATE6outputI5udp_tEEvT_ = comdat any

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.done() #1

; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() #2 {
entry:
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %udp = alloca %struct.udp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %hdr_byte_left = alloca i32, align 4
  %n = alloca i32, align 4
  %kind = alloca i8, align 1
  %tcp_option = alloca i8, align 1
  %i = alloca i32, align 4
  %padding = alloca i128, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %tcp_option24 = alloca i8, align 1
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.start.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr %ref.tmp) #1
  call void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind writable sret(%struct.ethernet_t) align 8 %ref.tmp), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %eth, ptr align 8 %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp, ptr align 8 %eth, i32 24, i1 false), !tbaa.struct !8
  call void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %agg.tmp), !primate !7
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %0 = load i16, ptr %etherType, align 8, !tbaa !15
  %conv = zext i16 %0 to i32
  %cmp = icmp eq i32 %conv, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr %ref.tmp1) #1
  call void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind writable sret(%struct.ipv4_t) align 8 %ref.tmp1), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %ipv4, ptr align 8 %ref.tmp1, i32 40, i1 false), !tbaa.struct !17
  call void @llvm.lifetime.end.p0(i64 40, ptr %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp2, ptr align 8 %ipv4, i32 40, i1 false), !tbaa.struct !17
  call void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %agg.tmp2), !primate !7
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %1 = load i8, ptr %protocol, align 8, !tbaa !24
  %conv3 = zext i8 %1 to i32
  %cmp4 = icmp eq i32 %conv3, 6
  br i1 %cmp4, label %if.then5, label %if.else29

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr %ref.tmp6) #1
  call void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind writable sret(%struct.tcp_t) align 8 %ref.tmp6), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %tcp, ptr align 8 %ref.tmp6, i32 32, i1 false), !tbaa.struct !26
  call void @llvm.lifetime.end.p0(i64 32, ptr %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp7, ptr align 8 %tcp, i32 32, i1 false), !tbaa.struct !26
  call void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %agg.tmp7), !primate !7
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %2 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv8 = sext i4 %2 to i32
  %cmp9 = icmp sgt i32 %conv8, 0
  br i1 %cmp9, label %if.then10, label %if.end28

if.then10:                                        ; preds = %if.then5
  call void @llvm.lifetime.start.p0(i64 4, ptr %hdr_byte_left) #1
  %dataOffset11 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %3 = load i4, ptr %dataOffset11, align 8, !tbaa !33
  %conv12 = sext i4 %3 to i32
  %sub = sub i32 %conv12, 5
  %mul = mul i32 4, %sub
  store i32 %mul, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 4, ptr %n) #1
  store i32 0, ptr %n, align 4, !tbaa !35
  br label %while.cond

while.cond:                                       ; preds = %cleanup.cont, %if.then10
  %4 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp13 = icmp sgt i32 %4, 0
  br i1 %cmp13, label %while.body, label %while.end27

while.body:                                       ; preds = %while.cond
  call void @llvm.lifetime.start.p0(i64 1, ptr %kind) #1
  %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
  store i8 %call, ptr %kind, align 1, !tbaa !20
  %5 = load i8, ptr %kind, align 1, !tbaa !20
  %conv14 = zext i8 %5 to i32
  %cmp15 = icmp eq i32 %conv14, 0
  br i1 %cmp15, label %if.then16, label %if.else

if.then16:                                        ; preds = %while.body
  %6 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec = add nsw i32 %6, -1
  store i32 %dec, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option) #1
  %7 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %7, ptr %tcp_option, align 1, !tbaa !20
  %8 = load i8, ptr %tcp_option, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %8), !primate !7
  call void @llvm.lifetime.start.p0(i64 4, ptr %i) #1
  store i32 0, ptr %i, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 16, ptr %padding) #1
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %9 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp18 = icmp sgt i32 %9, 0
  br i1 %cmp18, label %while.body19, label %while.end

while.body19:                                     ; preds = %while.cond17
  call void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind writable sret(i128) align 8 %tmp), !primate !7
  %10 = load i128, ptr %tmp, align 8, !tbaa !37
  store i128 %10, ptr %padding, align 8, !tbaa !37
  %11 = load i128, ptr %padding, align 8, !tbaa !37
  store i128 %11, ptr %indirect-arg-temp, align 8, !tbaa !37
  call void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %indirect-arg-temp), !primate !7
  %12 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %sub20 = sub nsw i32 %12, 16
  store i32 %sub20, ptr %hdr_byte_left, align 4, !tbaa !35
  br label %while.cond17, !llvm.loop !39

while.end:                                        ; preds = %while.cond17
  store i32 3, ptr %cleanup.dest.slot, align 4
  call void @llvm.lifetime.end.p0(i64 16, ptr %padding) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %i) #1
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option) #1
  br label %cleanup

if.else:                                          ; preds = %while.body
  %13 = load i8, ptr %kind, align 1, !tbaa !20
  %conv21 = zext i8 %13 to i32
  %cmp22 = icmp eq i32 %conv21, 1
  br i1 %cmp22, label %if.then23, label %if.end

if.then23:                                        ; preds = %if.else
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option24) #1
  %14 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %14, ptr %tcp_option24, align 1, !tbaa !20
  %15 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec25 = add nsw i32 %15, -1
  store i32 %dec25, ptr %hdr_byte_left, align 4, !tbaa !35
  %16 = load i8, ptr %tcp_option24, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %16), !primate !7
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option24) #1
  br label %if.end

if.end:                                           ; preds = %if.then23, %if.else
  br label %if.end26

if.end26:                                         ; preds = %if.end
  %17 = load i32, ptr %n, align 4, !tbaa !35
  %inc = add nsw i32 %17, 1
  store i32 %inc, ptr %n, align 4, !tbaa !35
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end26, %while.end
  call void @llvm.lifetime.end.p0(i64 1, ptr %kind) #1
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 3, label %while.end27
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %while.cond, !llvm.loop !41

while.end27:                                      ; preds = %cleanup, %while.cond
  call void @llvm.lifetime.end.p0(i64 4, ptr %n) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %hdr_byte_left) #1
  br label %if.end28

if.end28:                                         ; preds = %while.end27, %if.then5
  br label %if.end37

if.else29:                                        ; preds = %if.then
  %protocol30 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %18 = load i8, ptr %protocol30, align 8, !tbaa !24
  %conv31 = zext i8 %18 to i32
  %cmp32 = icmp eq i32 %conv31, 17
  br i1 %cmp32, label %if.then33, label %if.end36

if.then33:                                        ; preds = %if.else29
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp34) #1
  call void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind writable sret(%struct.udp_t) align 8 %ref.tmp34), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %udp, ptr align 8 %ref.tmp34, i32 8, i1 false), !tbaa.struct !42
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp34) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp35, ptr align 8 %udp, i32 8, i1 false), !tbaa.struct !42
  call void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %agg.tmp35), !primate !7
  br label %if.end36

if.end36:                                         ; preds = %if.then33, %if.else29
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.end28
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %entry
  call void @_ZN7PRIMATE10input_doneEv(), !primate !7
  call void @llvm.lifetime.end.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.end.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr %eth) #1
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ethernet_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 24, i1 false), !tbaa.struct !8
  ret void
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i32(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i32, i1 immarg) #4

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 24)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ipv4_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 40)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 40, i1 false), !tbaa.struct !17
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 40)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.tcp_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 32)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 32, i1 false), !tbaa.struct !26
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 32)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v() #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %1 = load i8, ptr %0, align 1, !tbaa !20
  ret i8 %1
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %out) #0 comdat !primate !7 {
entry:
  %out.addr = alloca i8, align 1
  store i8 %out, ptr %out.addr, align 1, !tbaa !20
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 1)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind noalias writable sret(i128) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 16)
  %1 = load i128, ptr %0, align 8, !tbaa !37
  store i128 %1, ptr %agg.result, align 8
  %2 = load i128, ptr %agg.result, align 8
  store i128 %2, ptr %agg.result, align 8, !tbaa !37
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %0) #0 comdat !primate !7 {
entry:
  %out.addr = alloca i128, align 8
  %out = load i128, ptr %0, align 8, !tbaa !37
  store i128 %out, ptr %out.addr, align 8, !tbaa !37
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 16)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.udp_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 8)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 8, i1 false), !tbaa.struct !42
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 8)
  ret void
}

; Function Attrs: nounwind
declare !primate !7 ptr @llvm.primate.input.p0.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.p0.i32(ptr, i32) #1

attributes #0 = { alwaysinline mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #1 = { nounwind }
attributes #2 = { mustprogress "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #3 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5}
!llvm.ident = !{!6}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"ilp32"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{i32 8, !"SmallDataLimit", i32 8}
!6 = !{!"clang version 18.1.8 (git@github.com:FAST-Research-Group/primate-arch-gen.git e8582d4315ec2267abfc97212fa19f342d0812e8)"}
!7 = !{!"blue", !"IO", i64 1, i64 1}
!8 = !{i64 0, i64 8, !9, i64 8, i64 8, !9, i64 16, i64 2, !13}
!9 = !{!10, !10, i64 0}
!10 = !{!"_BitInt(48)", !11, i64 0}
!11 = !{!"omnipotent char", !12, i64 0}
!12 = !{!"Simple C++ TBAA"}
!13 = !{!14, !14, i64 0}
!14 = !{!"_BitInt(16)", !11, i64 0}
!15 = !{!16, !14, i64 16}
!16 = !{!"_ZTS10ethernet_t", !10, i64 0, !10, i64 8, !14, i64 16}
!17 = !{i64 0, i64 16, !18, i64 16, i64 1, !20, i64 24, i64 16, !22}
!18 = !{!19, !19, i64 0}
!19 = !{!"_BitInt(72)", !11, i64 0}
!20 = !{!21, !21, i64 0}
!21 = !{!"_BitInt(8)", !11, i64 0}
!22 = !{!23, !23, i64 0}
!23 = !{!"_BitInt(80)", !11, i64 0}
!24 = !{!25, !21, i64 16}
!25 = !{!"_ZTS6ipv4_t", !19, i64 0, !21, i64 16, !23, i64 24}
!26 = !{i64 0, i64 16, !27, i64 16, i64 1, !29, i64 24, i64 8, !31}
!27 = !{!28, !28, i64 0}
!28 = !{!"_BitInt(96)", !11, i64 0}
!29 = !{!30, !30, i64 0}
!30 = !{!"_BitInt(4)", !11, i64 0}
!31 = !{!32, !32, i64 0}
!32 = !{!"_BitInt(60)", !11, i64 0}
!33 = !{!34, !30, i64 16}
!34 = !{!"_ZTS5tcp_t", !28, i64 0, !30, i64 16, !32, i64 24}
!35 = !{!36, !36, i64 0}
!36 = !{!"int", !11, i64 0}
!37 = !{!38, !38, i64 0}
!38 = !{!"_BitInt(128)", !11, i64 0}
!39 = distinct !{!39, !40}
!40 = !{!"llvm.loop.mustprogress"}
!41 = distinct !{!41, !40}
!42 = !{i64 0, i64 8, !43}
!43 = !{!44, !44, i64 0}
!44 = !{!"_BitInt(64)", !11, i64 0}
; *** IR Dump After AssignmentTrackingPass on [module] ***
; ModuleID = 'tcp_parse.cpp'
source_filename = "tcp_parse.cpp"
target datalayout = "e-G1-m:e-p:32:32-i64:64-n32-S128"
target triple = "primate32-unknown-linux-gnu"

%struct.ethernet_t = type { i48, i48, i16 }
%struct.ipv4_t = type { i72, i8, i80 }
%struct.tcp_t = type { i96, i4, i60 }
%struct.udp_t = type { i64 }

$_ZN7PRIMATE5inputI10ethernet_tEET_v = comdat any

$_ZN7PRIMATE6outputI10ethernet_tEEvT_ = comdat any

$_ZN7PRIMATE5inputI6ipv4_tEET_v = comdat any

$_ZN7PRIMATE6outputI6ipv4_tEEvT_ = comdat any

$_ZN7PRIMATE5inputI5tcp_tEET_v = comdat any

$_ZN7PRIMATE6outputI5tcp_tEEvT_ = comdat any

$_ZN7PRIMATE5inputIDU8_EET_v = comdat any

$_ZN7PRIMATE6outputIDU8_EEvT_ = comdat any

$_ZN7PRIMATE5inputIDU128_EET_v = comdat any

$_ZN7PRIMATE6outputIDU128_EEvT_ = comdat any

$_ZN7PRIMATE5inputI5udp_tEET_v = comdat any

$_ZN7PRIMATE6outputI5udp_tEEvT_ = comdat any

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.done() #1

; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() #2 {
entry:
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %udp = alloca %struct.udp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %hdr_byte_left = alloca i32, align 4
  %n = alloca i32, align 4
  %kind = alloca i8, align 1
  %tcp_option = alloca i8, align 1
  %i = alloca i32, align 4
  %padding = alloca i128, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %tcp_option24 = alloca i8, align 1
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.start.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr %ref.tmp) #1
  call void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind writable sret(%struct.ethernet_t) align 8 %ref.tmp), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %eth, ptr align 8 %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp, ptr align 8 %eth, i32 24, i1 false), !tbaa.struct !8
  call void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %agg.tmp), !primate !7
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %0 = load i16, ptr %etherType, align 8, !tbaa !15
  %conv = zext i16 %0 to i32
  %cmp = icmp eq i32 %conv, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr %ref.tmp1) #1
  call void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind writable sret(%struct.ipv4_t) align 8 %ref.tmp1), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %ipv4, ptr align 8 %ref.tmp1, i32 40, i1 false), !tbaa.struct !17
  call void @llvm.lifetime.end.p0(i64 40, ptr %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp2, ptr align 8 %ipv4, i32 40, i1 false), !tbaa.struct !17
  call void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %agg.tmp2), !primate !7
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %1 = load i8, ptr %protocol, align 8, !tbaa !24
  %conv3 = zext i8 %1 to i32
  %cmp4 = icmp eq i32 %conv3, 6
  br i1 %cmp4, label %if.then5, label %if.else29

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr %ref.tmp6) #1
  call void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind writable sret(%struct.tcp_t) align 8 %ref.tmp6), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %tcp, ptr align 8 %ref.tmp6, i32 32, i1 false), !tbaa.struct !26
  call void @llvm.lifetime.end.p0(i64 32, ptr %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp7, ptr align 8 %tcp, i32 32, i1 false), !tbaa.struct !26
  call void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %agg.tmp7), !primate !7
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %2 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv8 = sext i4 %2 to i32
  %cmp9 = icmp sgt i32 %conv8, 0
  br i1 %cmp9, label %if.then10, label %if.end28

if.then10:                                        ; preds = %if.then5
  call void @llvm.lifetime.start.p0(i64 4, ptr %hdr_byte_left) #1
  %dataOffset11 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %3 = load i4, ptr %dataOffset11, align 8, !tbaa !33
  %conv12 = sext i4 %3 to i32
  %sub = sub i32 %conv12, 5
  %mul = mul i32 4, %sub
  store i32 %mul, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 4, ptr %n) #1
  store i32 0, ptr %n, align 4, !tbaa !35
  br label %while.cond

while.cond:                                       ; preds = %cleanup.cont, %if.then10
  %4 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp13 = icmp sgt i32 %4, 0
  br i1 %cmp13, label %while.body, label %while.end27

while.body:                                       ; preds = %while.cond
  call void @llvm.lifetime.start.p0(i64 1, ptr %kind) #1
  %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
  store i8 %call, ptr %kind, align 1, !tbaa !20
  %5 = load i8, ptr %kind, align 1, !tbaa !20
  %conv14 = zext i8 %5 to i32
  %cmp15 = icmp eq i32 %conv14, 0
  br i1 %cmp15, label %if.then16, label %if.else

if.then16:                                        ; preds = %while.body
  %6 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec = add nsw i32 %6, -1
  store i32 %dec, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option) #1
  %7 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %7, ptr %tcp_option, align 1, !tbaa !20
  %8 = load i8, ptr %tcp_option, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %8), !primate !7
  call void @llvm.lifetime.start.p0(i64 4, ptr %i) #1
  store i32 0, ptr %i, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 16, ptr %padding) #1
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %9 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp18 = icmp sgt i32 %9, 0
  br i1 %cmp18, label %while.body19, label %while.end

while.body19:                                     ; preds = %while.cond17
  call void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind writable sret(i128) align 8 %tmp), !primate !7
  %10 = load i128, ptr %tmp, align 8, !tbaa !37
  store i128 %10, ptr %padding, align 8, !tbaa !37
  %11 = load i128, ptr %padding, align 8, !tbaa !37
  store i128 %11, ptr %indirect-arg-temp, align 8, !tbaa !37
  call void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %indirect-arg-temp), !primate !7
  %12 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %sub20 = sub nsw i32 %12, 16
  store i32 %sub20, ptr %hdr_byte_left, align 4, !tbaa !35
  br label %while.cond17, !llvm.loop !39

while.end:                                        ; preds = %while.cond17
  store i32 3, ptr %cleanup.dest.slot, align 4
  call void @llvm.lifetime.end.p0(i64 16, ptr %padding) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %i) #1
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option) #1
  br label %cleanup

if.else:                                          ; preds = %while.body
  %13 = load i8, ptr %kind, align 1, !tbaa !20
  %conv21 = zext i8 %13 to i32
  %cmp22 = icmp eq i32 %conv21, 1
  br i1 %cmp22, label %if.then23, label %if.end

if.then23:                                        ; preds = %if.else
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option24) #1
  %14 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %14, ptr %tcp_option24, align 1, !tbaa !20
  %15 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec25 = add nsw i32 %15, -1
  store i32 %dec25, ptr %hdr_byte_left, align 4, !tbaa !35
  %16 = load i8, ptr %tcp_option24, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %16), !primate !7
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option24) #1
  br label %if.end

if.end:                                           ; preds = %if.then23, %if.else
  br label %if.end26

if.end26:                                         ; preds = %if.end
  %17 = load i32, ptr %n, align 4, !tbaa !35
  %inc = add nsw i32 %17, 1
  store i32 %inc, ptr %n, align 4, !tbaa !35
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end26, %while.end
  call void @llvm.lifetime.end.p0(i64 1, ptr %kind) #1
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 3, label %while.end27
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %while.cond, !llvm.loop !41

while.end27:                                      ; preds = %cleanup, %while.cond
  call void @llvm.lifetime.end.p0(i64 4, ptr %n) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %hdr_byte_left) #1
  br label %if.end28

if.end28:                                         ; preds = %while.end27, %if.then5
  br label %if.end37

if.else29:                                        ; preds = %if.then
  %protocol30 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %18 = load i8, ptr %protocol30, align 8, !tbaa !24
  %conv31 = zext i8 %18 to i32
  %cmp32 = icmp eq i32 %conv31, 17
  br i1 %cmp32, label %if.then33, label %if.end36

if.then33:                                        ; preds = %if.else29
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp34) #1
  call void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind writable sret(%struct.udp_t) align 8 %ref.tmp34), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %udp, ptr align 8 %ref.tmp34, i32 8, i1 false), !tbaa.struct !42
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp34) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp35, ptr align 8 %udp, i32 8, i1 false), !tbaa.struct !42
  call void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %agg.tmp35), !primate !7
  br label %if.end36

if.end36:                                         ; preds = %if.then33, %if.else29
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.end28
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %entry
  call void @_ZN7PRIMATE10input_doneEv(), !primate !7
  call void @llvm.lifetime.end.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.end.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr %eth) #1
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ethernet_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 24, i1 false), !tbaa.struct !8
  ret void
}

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i32(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i32, i1 immarg) #4

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 24)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ipv4_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 40)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 40, i1 false), !tbaa.struct !17
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 40)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.tcp_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 32)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 32, i1 false), !tbaa.struct !26
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 32)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v() #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %1 = load i8, ptr %0, align 1, !tbaa !20
  ret i8 %1
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %out) #0 comdat !primate !7 {
entry:
  %out.addr = alloca i8, align 1
  store i8 %out, ptr %out.addr, align 1, !tbaa !20
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 1)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind noalias writable sret(i128) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 16)
  %1 = load i128, ptr %0, align 8, !tbaa !37
  store i128 %1, ptr %agg.result, align 8
  %2 = load i128, ptr %agg.result, align 8
  store i128 %2, ptr %agg.result, align 8, !tbaa !37
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %0) #0 comdat !primate !7 {
entry:
  %out.addr = alloca i128, align 8
  %out = load i128, ptr %0, align 8, !tbaa !37
  store i128 %out, ptr %out.addr, align 8, !tbaa !37
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 16)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.udp_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 8)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 8, i1 false), !tbaa.struct !42
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 8)
  ret void
}

; Function Attrs: nounwind
declare !primate !7 ptr @llvm.primate.input.p0.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.p0.i32(ptr, i32) #1

attributes #0 = { alwaysinline mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #1 = { nounwind }
attributes #2 = { mustprogress "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #3 = { nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5}
!llvm.ident = !{!6}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"ilp32"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{i32 8, !"SmallDataLimit", i32 8}
!6 = !{!"clang version 18.1.8 (git@github.com:FAST-Research-Group/primate-arch-gen.git e8582d4315ec2267abfc97212fa19f342d0812e8)"}
!7 = !{!"blue", !"IO", i64 1, i64 1}
!8 = !{i64 0, i64 8, !9, i64 8, i64 8, !9, i64 16, i64 2, !13}
!9 = !{!10, !10, i64 0}
!10 = !{!"_BitInt(48)", !11, i64 0}
!11 = !{!"omnipotent char", !12, i64 0}
!12 = !{!"Simple C++ TBAA"}
!13 = !{!14, !14, i64 0}
!14 = !{!"_BitInt(16)", !11, i64 0}
!15 = !{!16, !14, i64 16}
!16 = !{!"_ZTS10ethernet_t", !10, i64 0, !10, i64 8, !14, i64 16}
!17 = !{i64 0, i64 16, !18, i64 16, i64 1, !20, i64 24, i64 16, !22}
!18 = !{!19, !19, i64 0}
!19 = !{!"_BitInt(72)", !11, i64 0}
!20 = !{!21, !21, i64 0}
!21 = !{!"_BitInt(8)", !11, i64 0}
!22 = !{!23, !23, i64 0}
!23 = !{!"_BitInt(80)", !11, i64 0}
!24 = !{!25, !21, i64 16}
!25 = !{!"_ZTS6ipv4_t", !19, i64 0, !21, i64 16, !23, i64 24}
!26 = !{i64 0, i64 16, !27, i64 16, i64 1, !29, i64 24, i64 8, !31}
!27 = !{!28, !28, i64 0}
!28 = !{!"_BitInt(96)", !11, i64 0}
!29 = !{!30, !30, i64 0}
!30 = !{!"_BitInt(4)", !11, i64 0}
!31 = !{!32, !32, i64 0}
!32 = !{!"_BitInt(60)", !11, i64 0}
!33 = !{!34, !30, i64 16}
!34 = !{!"_ZTS5tcp_t", !28, i64 0, !30, i64 16, !32, i64 24}
!35 = !{!36, !36, i64 0}
!36 = !{!"int", !11, i64 0}
!37 = !{!38, !38, i64 0}
!38 = !{!"_BitInt(128)", !11, i64 0}
!39 = distinct !{!39, !40}
!40 = !{!"llvm.loop.mustprogress"}
!41 = distinct !{!41, !40}
!42 = !{i64 0, i64 8, !43}
!43 = !{!44, !44, i64 0}
!44 = !{!"_BitInt(64)", !11, i64 0}
; *** IR Dump After InferFunctionAttrsPass on [module] ***
; ModuleID = 'tcp_parse.cpp'
source_filename = "tcp_parse.cpp"
target datalayout = "e-G1-m:e-p:32:32-i64:64-n32-S128"
target triple = "primate32-unknown-linux-gnu"

%struct.ethernet_t = type { i48, i48, i16 }
%struct.ipv4_t = type { i72, i8, i80 }
%struct.tcp_t = type { i96, i4, i60 }
%struct.udp_t = type { i64 }

$_ZN7PRIMATE5inputI10ethernet_tEET_v = comdat any

$_ZN7PRIMATE6outputI10ethernet_tEEvT_ = comdat any

$_ZN7PRIMATE5inputI6ipv4_tEET_v = comdat any

$_ZN7PRIMATE6outputI6ipv4_tEEvT_ = comdat any

$_ZN7PRIMATE5inputI5tcp_tEET_v = comdat any

$_ZN7PRIMATE6outputI5tcp_tEEvT_ = comdat any

$_ZN7PRIMATE5inputIDU8_EET_v = comdat any

$_ZN7PRIMATE6outputIDU8_EEvT_ = comdat any

$_ZN7PRIMATE5inputIDU128_EET_v = comdat any

$_ZN7PRIMATE6outputIDU128_EEvT_ = comdat any

$_ZN7PRIMATE5inputI5udp_tEET_v = comdat any

$_ZN7PRIMATE6outputI5udp_tEEvT_ = comdat any

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.done() #1

; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() #2 {
entry:
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %udp = alloca %struct.udp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %hdr_byte_left = alloca i32, align 4
  %n = alloca i32, align 4
  %kind = alloca i8, align 1
  %tcp_option = alloca i8, align 1
  %i = alloca i32, align 4
  %padding = alloca i128, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %tcp_option24 = alloca i8, align 1
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.start.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr %ref.tmp) #1
  call void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind writable sret(%struct.ethernet_t) align 8 %ref.tmp), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %eth, ptr align 8 %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp, ptr align 8 %eth, i32 24, i1 false), !tbaa.struct !8
  call void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %agg.tmp), !primate !7
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %0 = load i16, ptr %etherType, align 8, !tbaa !15
  %conv = zext i16 %0 to i32
  %cmp = icmp eq i32 %conv, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr %ref.tmp1) #1
  call void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind writable sret(%struct.ipv4_t) align 8 %ref.tmp1), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %ipv4, ptr align 8 %ref.tmp1, i32 40, i1 false), !tbaa.struct !17
  call void @llvm.lifetime.end.p0(i64 40, ptr %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp2, ptr align 8 %ipv4, i32 40, i1 false), !tbaa.struct !17
  call void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %agg.tmp2), !primate !7
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %1 = load i8, ptr %protocol, align 8, !tbaa !24
  %conv3 = zext i8 %1 to i32
  %cmp4 = icmp eq i32 %conv3, 6
  br i1 %cmp4, label %if.then5, label %if.else29

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr %ref.tmp6) #1
  call void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind writable sret(%struct.tcp_t) align 8 %ref.tmp6), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %tcp, ptr align 8 %ref.tmp6, i32 32, i1 false), !tbaa.struct !26
  call void @llvm.lifetime.end.p0(i64 32, ptr %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp7, ptr align 8 %tcp, i32 32, i1 false), !tbaa.struct !26
  call void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %agg.tmp7), !primate !7
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %2 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv8 = sext i4 %2 to i32
  %cmp9 = icmp sgt i32 %conv8, 0
  br i1 %cmp9, label %if.then10, label %if.end28

if.then10:                                        ; preds = %if.then5
  call void @llvm.lifetime.start.p0(i64 4, ptr %hdr_byte_left) #1
  %dataOffset11 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %3 = load i4, ptr %dataOffset11, align 8, !tbaa !33
  %conv12 = sext i4 %3 to i32
  %sub = sub i32 %conv12, 5
  %mul = mul i32 4, %sub
  store i32 %mul, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 4, ptr %n) #1
  store i32 0, ptr %n, align 4, !tbaa !35
  br label %while.cond

while.cond:                                       ; preds = %cleanup.cont, %if.then10
  %4 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp13 = icmp sgt i32 %4, 0
  br i1 %cmp13, label %while.body, label %while.end27

while.body:                                       ; preds = %while.cond
  call void @llvm.lifetime.start.p0(i64 1, ptr %kind) #1
  %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
  store i8 %call, ptr %kind, align 1, !tbaa !20
  %5 = load i8, ptr %kind, align 1, !tbaa !20
  %conv14 = zext i8 %5 to i32
  %cmp15 = icmp eq i32 %conv14, 0
  br i1 %cmp15, label %if.then16, label %if.else

if.then16:                                        ; preds = %while.body
  %6 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec = add nsw i32 %6, -1
  store i32 %dec, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option) #1
  %7 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %7, ptr %tcp_option, align 1, !tbaa !20
  %8 = load i8, ptr %tcp_option, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %8), !primate !7
  call void @llvm.lifetime.start.p0(i64 4, ptr %i) #1
  store i32 0, ptr %i, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 16, ptr %padding) #1
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %9 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp18 = icmp sgt i32 %9, 0
  br i1 %cmp18, label %while.body19, label %while.end

while.body19:                                     ; preds = %while.cond17
  call void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind writable sret(i128) align 8 %tmp), !primate !7
  %10 = load i128, ptr %tmp, align 8, !tbaa !37
  store i128 %10, ptr %padding, align 8, !tbaa !37
  %11 = load i128, ptr %padding, align 8, !tbaa !37
  store i128 %11, ptr %indirect-arg-temp, align 8, !tbaa !37
  call void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %indirect-arg-temp), !primate !7
  %12 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %sub20 = sub nsw i32 %12, 16
  store i32 %sub20, ptr %hdr_byte_left, align 4, !tbaa !35
  br label %while.cond17, !llvm.loop !39

while.end:                                        ; preds = %while.cond17
  store i32 3, ptr %cleanup.dest.slot, align 4
  call void @llvm.lifetime.end.p0(i64 16, ptr %padding) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %i) #1
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option) #1
  br label %cleanup

if.else:                                          ; preds = %while.body
  %13 = load i8, ptr %kind, align 1, !tbaa !20
  %conv21 = zext i8 %13 to i32
  %cmp22 = icmp eq i32 %conv21, 1
  br i1 %cmp22, label %if.then23, label %if.end

if.then23:                                        ; preds = %if.else
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option24) #1
  %14 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %14, ptr %tcp_option24, align 1, !tbaa !20
  %15 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec25 = add nsw i32 %15, -1
  store i32 %dec25, ptr %hdr_byte_left, align 4, !tbaa !35
  %16 = load i8, ptr %tcp_option24, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %16), !primate !7
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option24) #1
  br label %if.end

if.end:                                           ; preds = %if.then23, %if.else
  br label %if.end26

if.end26:                                         ; preds = %if.end
  %17 = load i32, ptr %n, align 4, !tbaa !35
  %inc = add nsw i32 %17, 1
  store i32 %inc, ptr %n, align 4, !tbaa !35
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end26, %while.end
  call void @llvm.lifetime.end.p0(i64 1, ptr %kind) #1
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 3, label %while.end27
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %while.cond, !llvm.loop !41

while.end27:                                      ; preds = %cleanup, %while.cond
  call void @llvm.lifetime.end.p0(i64 4, ptr %n) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %hdr_byte_left) #1
  br label %if.end28

if.end28:                                         ; preds = %while.end27, %if.then5
  br label %if.end37

if.else29:                                        ; preds = %if.then
  %protocol30 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %18 = load i8, ptr %protocol30, align 8, !tbaa !24
  %conv31 = zext i8 %18 to i32
  %cmp32 = icmp eq i32 %conv31, 17
  br i1 %cmp32, label %if.then33, label %if.end36

if.then33:                                        ; preds = %if.else29
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp34) #1
  call void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind writable sret(%struct.udp_t) align 8 %ref.tmp34), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %udp, ptr align 8 %ref.tmp34, i32 8, i1 false), !tbaa.struct !42
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp34) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp35, ptr align 8 %udp, i32 8, i1 false), !tbaa.struct !42
  call void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %agg.tmp35), !primate !7
  br label %if.end36

if.end36:                                         ; preds = %if.then33, %if.else29
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.end28
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %entry
  call void @_ZN7PRIMATE10input_doneEv(), !primate !7
  call void @llvm.lifetime.end.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.end.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr %eth) #1
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ethernet_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 24, i1 false), !tbaa.struct !8
  ret void
}

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i32(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i32, i1 immarg) #4

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 24)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ipv4_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 40)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 40, i1 false), !tbaa.struct !17
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 40)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.tcp_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 32)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 32, i1 false), !tbaa.struct !26
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 32)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v() #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %1 = load i8, ptr %0, align 1, !tbaa !20
  ret i8 %1
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %out) #0 comdat !primate !7 {
entry:
  %out.addr = alloca i8, align 1
  store i8 %out, ptr %out.addr, align 1, !tbaa !20
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 1)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind noalias writable sret(i128) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 16)
  %1 = load i128, ptr %0, align 8, !tbaa !37
  store i128 %1, ptr %agg.result, align 8
  %2 = load i128, ptr %agg.result, align 8
  store i128 %2, ptr %agg.result, align 8, !tbaa !37
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %0) #0 comdat !primate !7 {
entry:
  %out.addr = alloca i128, align 8
  %out = load i128, ptr %0, align 8, !tbaa !37
  store i128 %out, ptr %out.addr, align 8, !tbaa !37
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 16)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.udp_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 8)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 8, i1 false), !tbaa.struct !42
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 8)
  ret void
}

; Function Attrs: nounwind
declare !primate !7 ptr @llvm.primate.input.p0.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.p0.i32(ptr, i32) #1

attributes #0 = { alwaysinline mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #1 = { nounwind }
attributes #2 = { mustprogress "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #3 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5}
!llvm.ident = !{!6}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"ilp32"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{i32 8, !"SmallDataLimit", i32 8}
!6 = !{!"clang version 18.1.8 (git@github.com:FAST-Research-Group/primate-arch-gen.git e8582d4315ec2267abfc97212fa19f342d0812e8)"}
!7 = !{!"blue", !"IO", i64 1, i64 1}
!8 = !{i64 0, i64 8, !9, i64 8, i64 8, !9, i64 16, i64 2, !13}
!9 = !{!10, !10, i64 0}
!10 = !{!"_BitInt(48)", !11, i64 0}
!11 = !{!"omnipotent char", !12, i64 0}
!12 = !{!"Simple C++ TBAA"}
!13 = !{!14, !14, i64 0}
!14 = !{!"_BitInt(16)", !11, i64 0}
!15 = !{!16, !14, i64 16}
!16 = !{!"_ZTS10ethernet_t", !10, i64 0, !10, i64 8, !14, i64 16}
!17 = !{i64 0, i64 16, !18, i64 16, i64 1, !20, i64 24, i64 16, !22}
!18 = !{!19, !19, i64 0}
!19 = !{!"_BitInt(72)", !11, i64 0}
!20 = !{!21, !21, i64 0}
!21 = !{!"_BitInt(8)", !11, i64 0}
!22 = !{!23, !23, i64 0}
!23 = !{!"_BitInt(80)", !11, i64 0}
!24 = !{!25, !21, i64 16}
!25 = !{!"_ZTS6ipv4_t", !19, i64 0, !21, i64 16, !23, i64 24}
!26 = !{i64 0, i64 16, !27, i64 16, i64 1, !29, i64 24, i64 8, !31}
!27 = !{!28, !28, i64 0}
!28 = !{!"_BitInt(96)", !11, i64 0}
!29 = !{!30, !30, i64 0}
!30 = !{!"_BitInt(4)", !11, i64 0}
!31 = !{!32, !32, i64 0}
!32 = !{!"_BitInt(60)", !11, i64 0}
!33 = !{!34, !30, i64 16}
!34 = !{!"_ZTS5tcp_t", !28, i64 0, !30, i64 16, !32, i64 24}
!35 = !{!36, !36, i64 0}
!36 = !{!"int", !11, i64 0}
!37 = !{!38, !38, i64 0}
!38 = !{!"_BitInt(128)", !11, i64 0}
!39 = distinct !{!39, !40}
!40 = !{!"llvm.loop.mustprogress"}
!41 = distinct !{!41, !40}
!42 = !{i64 0, i64 8, !43}
!43 = !{!44, !44, i64 0}
!44 = !{!"_BitInt(64)", !11, i64 0}
; *** IR Dump After CoroEarlyPass on [module] ***
; ModuleID = 'tcp_parse.cpp'
source_filename = "tcp_parse.cpp"
target datalayout = "e-G1-m:e-p:32:32-i64:64-n32-S128"
target triple = "primate32-unknown-linux-gnu"

%struct.ethernet_t = type { i48, i48, i16 }
%struct.ipv4_t = type { i72, i8, i80 }
%struct.tcp_t = type { i96, i4, i60 }
%struct.udp_t = type { i64 }

$_ZN7PRIMATE5inputI10ethernet_tEET_v = comdat any

$_ZN7PRIMATE6outputI10ethernet_tEEvT_ = comdat any

$_ZN7PRIMATE5inputI6ipv4_tEET_v = comdat any

$_ZN7PRIMATE6outputI6ipv4_tEEvT_ = comdat any

$_ZN7PRIMATE5inputI5tcp_tEET_v = comdat any

$_ZN7PRIMATE6outputI5tcp_tEEvT_ = comdat any

$_ZN7PRIMATE5inputIDU8_EET_v = comdat any

$_ZN7PRIMATE6outputIDU8_EEvT_ = comdat any

$_ZN7PRIMATE5inputIDU128_EET_v = comdat any

$_ZN7PRIMATE6outputIDU128_EEvT_ = comdat any

$_ZN7PRIMATE5inputI5udp_tEET_v = comdat any

$_ZN7PRIMATE6outputI5udp_tEEvT_ = comdat any

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.done() #1

; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() #2 {
entry:
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %udp = alloca %struct.udp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %hdr_byte_left = alloca i32, align 4
  %n = alloca i32, align 4
  %kind = alloca i8, align 1
  %tcp_option = alloca i8, align 1
  %i = alloca i32, align 4
  %padding = alloca i128, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %tcp_option24 = alloca i8, align 1
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.start.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr %ref.tmp) #1
  call void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind writable sret(%struct.ethernet_t) align 8 %ref.tmp), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %eth, ptr align 8 %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp, ptr align 8 %eth, i32 24, i1 false), !tbaa.struct !8
  call void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %agg.tmp), !primate !7
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %0 = load i16, ptr %etherType, align 8, !tbaa !15
  %conv = zext i16 %0 to i32
  %cmp = icmp eq i32 %conv, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr %ref.tmp1) #1
  call void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind writable sret(%struct.ipv4_t) align 8 %ref.tmp1), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %ipv4, ptr align 8 %ref.tmp1, i32 40, i1 false), !tbaa.struct !17
  call void @llvm.lifetime.end.p0(i64 40, ptr %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp2, ptr align 8 %ipv4, i32 40, i1 false), !tbaa.struct !17
  call void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %agg.tmp2), !primate !7
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %1 = load i8, ptr %protocol, align 8, !tbaa !24
  %conv3 = zext i8 %1 to i32
  %cmp4 = icmp eq i32 %conv3, 6
  br i1 %cmp4, label %if.then5, label %if.else29

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr %ref.tmp6) #1
  call void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind writable sret(%struct.tcp_t) align 8 %ref.tmp6), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %tcp, ptr align 8 %ref.tmp6, i32 32, i1 false), !tbaa.struct !26
  call void @llvm.lifetime.end.p0(i64 32, ptr %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp7, ptr align 8 %tcp, i32 32, i1 false), !tbaa.struct !26
  call void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %agg.tmp7), !primate !7
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %2 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv8 = sext i4 %2 to i32
  %cmp9 = icmp sgt i32 %conv8, 0
  br i1 %cmp9, label %if.then10, label %if.end28

if.then10:                                        ; preds = %if.then5
  call void @llvm.lifetime.start.p0(i64 4, ptr %hdr_byte_left) #1
  %dataOffset11 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %3 = load i4, ptr %dataOffset11, align 8, !tbaa !33
  %conv12 = sext i4 %3 to i32
  %sub = sub i32 %conv12, 5
  %mul = mul i32 4, %sub
  store i32 %mul, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 4, ptr %n) #1
  store i32 0, ptr %n, align 4, !tbaa !35
  br label %while.cond

while.cond:                                       ; preds = %cleanup.cont, %if.then10
  %4 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp13 = icmp sgt i32 %4, 0
  br i1 %cmp13, label %while.body, label %while.end27

while.body:                                       ; preds = %while.cond
  call void @llvm.lifetime.start.p0(i64 1, ptr %kind) #1
  %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
  store i8 %call, ptr %kind, align 1, !tbaa !20
  %5 = load i8, ptr %kind, align 1, !tbaa !20
  %conv14 = zext i8 %5 to i32
  %cmp15 = icmp eq i32 %conv14, 0
  br i1 %cmp15, label %if.then16, label %if.else

if.then16:                                        ; preds = %while.body
  %6 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec = add nsw i32 %6, -1
  store i32 %dec, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option) #1
  %7 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %7, ptr %tcp_option, align 1, !tbaa !20
  %8 = load i8, ptr %tcp_option, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %8), !primate !7
  call void @llvm.lifetime.start.p0(i64 4, ptr %i) #1
  store i32 0, ptr %i, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 16, ptr %padding) #1
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %9 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp18 = icmp sgt i32 %9, 0
  br i1 %cmp18, label %while.body19, label %while.end

while.body19:                                     ; preds = %while.cond17
  call void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind writable sret(i128) align 8 %tmp), !primate !7
  %10 = load i128, ptr %tmp, align 8, !tbaa !37
  store i128 %10, ptr %padding, align 8, !tbaa !37
  %11 = load i128, ptr %padding, align 8, !tbaa !37
  store i128 %11, ptr %indirect-arg-temp, align 8, !tbaa !37
  call void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %indirect-arg-temp), !primate !7
  %12 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %sub20 = sub nsw i32 %12, 16
  store i32 %sub20, ptr %hdr_byte_left, align 4, !tbaa !35
  br label %while.cond17, !llvm.loop !39

while.end:                                        ; preds = %while.cond17
  store i32 3, ptr %cleanup.dest.slot, align 4
  call void @llvm.lifetime.end.p0(i64 16, ptr %padding) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %i) #1
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option) #1
  br label %cleanup

if.else:                                          ; preds = %while.body
  %13 = load i8, ptr %kind, align 1, !tbaa !20
  %conv21 = zext i8 %13 to i32
  %cmp22 = icmp eq i32 %conv21, 1
  br i1 %cmp22, label %if.then23, label %if.end

if.then23:                                        ; preds = %if.else
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option24) #1
  %14 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %14, ptr %tcp_option24, align 1, !tbaa !20
  %15 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec25 = add nsw i32 %15, -1
  store i32 %dec25, ptr %hdr_byte_left, align 4, !tbaa !35
  %16 = load i8, ptr %tcp_option24, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %16), !primate !7
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option24) #1
  br label %if.end

if.end:                                           ; preds = %if.then23, %if.else
  br label %if.end26

if.end26:                                         ; preds = %if.end
  %17 = load i32, ptr %n, align 4, !tbaa !35
  %inc = add nsw i32 %17, 1
  store i32 %inc, ptr %n, align 4, !tbaa !35
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end26, %while.end
  call void @llvm.lifetime.end.p0(i64 1, ptr %kind) #1
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 3, label %while.end27
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %while.cond, !llvm.loop !41

while.end27:                                      ; preds = %cleanup, %while.cond
  call void @llvm.lifetime.end.p0(i64 4, ptr %n) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %hdr_byte_left) #1
  br label %if.end28

if.end28:                                         ; preds = %while.end27, %if.then5
  br label %if.end37

if.else29:                                        ; preds = %if.then
  %protocol30 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %18 = load i8, ptr %protocol30, align 8, !tbaa !24
  %conv31 = zext i8 %18 to i32
  %cmp32 = icmp eq i32 %conv31, 17
  br i1 %cmp32, label %if.then33, label %if.end36

if.then33:                                        ; preds = %if.else29
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp34) #1
  call void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind writable sret(%struct.udp_t) align 8 %ref.tmp34), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %udp, ptr align 8 %ref.tmp34, i32 8, i1 false), !tbaa.struct !42
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp34) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp35, ptr align 8 %udp, i32 8, i1 false), !tbaa.struct !42
  call void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %agg.tmp35), !primate !7
  br label %if.end36

if.end36:                                         ; preds = %if.then33, %if.else29
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.end28
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %entry
  call void @_ZN7PRIMATE10input_doneEv(), !primate !7
  call void @llvm.lifetime.end.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.end.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr %eth) #1
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ethernet_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 24, i1 false), !tbaa.struct !8
  ret void
}

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i32(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i32, i1 immarg) #4

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 24)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ipv4_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 40)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 40, i1 false), !tbaa.struct !17
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 40)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.tcp_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 32)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 32, i1 false), !tbaa.struct !26
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 32)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v() #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %1 = load i8, ptr %0, align 1, !tbaa !20
  ret i8 %1
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %out) #0 comdat !primate !7 {
entry:
  %out.addr = alloca i8, align 1
  store i8 %out, ptr %out.addr, align 1, !tbaa !20
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 1)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind noalias writable sret(i128) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 16)
  %1 = load i128, ptr %0, align 8, !tbaa !37
  store i128 %1, ptr %agg.result, align 8
  %2 = load i128, ptr %agg.result, align 8
  store i128 %2, ptr %agg.result, align 8, !tbaa !37
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %0) #0 comdat !primate !7 {
entry:
  %out.addr = alloca i128, align 8
  %out = load i128, ptr %0, align 8, !tbaa !37
  store i128 %out, ptr %out.addr, align 8, !tbaa !37
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 16)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.udp_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 8)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 8, i1 false), !tbaa.struct !42
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 8)
  ret void
}

; Function Attrs: nounwind
declare !primate !7 ptr @llvm.primate.input.p0.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.p0.i32(ptr, i32) #1

attributes #0 = { alwaysinline mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #1 = { nounwind }
attributes #2 = { mustprogress "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #3 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5}
!llvm.ident = !{!6}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"ilp32"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{i32 8, !"SmallDataLimit", i32 8}
!6 = !{!"clang version 18.1.8 (git@github.com:FAST-Research-Group/primate-arch-gen.git e8582d4315ec2267abfc97212fa19f342d0812e8)"}
!7 = !{!"blue", !"IO", i64 1, i64 1}
!8 = !{i64 0, i64 8, !9, i64 8, i64 8, !9, i64 16, i64 2, !13}
!9 = !{!10, !10, i64 0}
!10 = !{!"_BitInt(48)", !11, i64 0}
!11 = !{!"omnipotent char", !12, i64 0}
!12 = !{!"Simple C++ TBAA"}
!13 = !{!14, !14, i64 0}
!14 = !{!"_BitInt(16)", !11, i64 0}
!15 = !{!16, !14, i64 16}
!16 = !{!"_ZTS10ethernet_t", !10, i64 0, !10, i64 8, !14, i64 16}
!17 = !{i64 0, i64 16, !18, i64 16, i64 1, !20, i64 24, i64 16, !22}
!18 = !{!19, !19, i64 0}
!19 = !{!"_BitInt(72)", !11, i64 0}
!20 = !{!21, !21, i64 0}
!21 = !{!"_BitInt(8)", !11, i64 0}
!22 = !{!23, !23, i64 0}
!23 = !{!"_BitInt(80)", !11, i64 0}
!24 = !{!25, !21, i64 16}
!25 = !{!"_ZTS6ipv4_t", !19, i64 0, !21, i64 16, !23, i64 24}
!26 = !{i64 0, i64 16, !27, i64 16, i64 1, !29, i64 24, i64 8, !31}
!27 = !{!28, !28, i64 0}
!28 = !{!"_BitInt(96)", !11, i64 0}
!29 = !{!30, !30, i64 0}
!30 = !{!"_BitInt(4)", !11, i64 0}
!31 = !{!32, !32, i64 0}
!32 = !{!"_BitInt(60)", !11, i64 0}
!33 = !{!34, !30, i64 16}
!34 = !{!"_ZTS5tcp_t", !28, i64 0, !30, i64 16, !32, i64 24}
!35 = !{!36, !36, i64 0}
!36 = !{!"int", !11, i64 0}
!37 = !{!38, !38, i64 0}
!38 = !{!"_BitInt(128)", !11, i64 0}
!39 = distinct !{!39, !40}
!40 = !{!"llvm.loop.mustprogress"}
!41 = distinct !{!41, !40}
!42 = !{i64 0, i64 8, !43}
!43 = !{!44, !44, i64 0}
!44 = !{!"_BitInt(64)", !11, i64 0}
; *** IR Dump After LowerExpectIntrinsicPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}
Compiling to primate CPU: 

Features:+32bit
CPU:PrimateModel
TuneCPU:PrimateModel

reading in register indexing parameters
0 48 72 80 96 100 
4 8 16 32 48 60 64 72 80 96 128 160 
number of ALUs found: 2
number of BFUs found: 2
Merged slot idx: 0
Merged slot idx: 1
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After EarlyCSEPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After CallSiteSplittingPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LowerExpectIntrinsicPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}
Compiling to primate CPU: 
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After EarlyCSEPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After CallSiteSplittingPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After LowerExpectIntrinsicPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() #2 {
entry:
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %udp = alloca %struct.udp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %hdr_byte_left = alloca i32, align 4
  %n = alloca i32, align 4
  %kind = alloca i8, align 1
  %tcp_option = alloca i8, align 1
  %i = alloca i32, align 4
  %padding = alloca i128, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %tcp_option24 = alloca i8, align 1
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.start.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr %ref.tmp) #1
  call void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind writable sret(%struct.ethernet_t) align 8 %ref.tmp), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %eth, ptr align 8 %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp, ptr align 8 %eth, i32 24, i1 false), !tbaa.struct !8
  call void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %agg.tmp), !primate !7
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %0 = load i16, ptr %etherType, align 8, !tbaa !15
  %conv = zext i16 %0 to i32
  %cmp = icmp eq i32 %conv, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr %ref.tmp1) #1
  call void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind writable sret(%struct.ipv4_t) align 8 %ref.tmp1), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %ipv4, ptr align 8 %ref.tmp1, i32 40, i1 false), !tbaa.struct !17
  call void @llvm.lifetime.end.p0(i64 40, ptr %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp2, ptr align 8 %ipv4, i32 40, i1 false), !tbaa.struct !17
  call void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %agg.tmp2), !primate !7
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %1 = load i8, ptr %protocol, align 8, !tbaa !24
  %conv3 = zext i8 %1 to i32
  %cmp4 = icmp eq i32 %conv3, 6
  br i1 %cmp4, label %if.then5, label %if.else29

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr %ref.tmp6) #1
  call void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind writable sret(%struct.tcp_t) align 8 %ref.tmp6), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %tcp, ptr align 8 %ref.tmp6, i32 32, i1 false), !tbaa.struct !26
  call void @llvm.lifetime.end.p0(i64 32, ptr %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp7, ptr align 8 %tcp, i32 32, i1 false), !tbaa.struct !26
  call void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %agg.tmp7), !primate !7
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %2 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv8 = sext i4 %2 to i32
  %cmp9 = icmp sgt i32 %conv8, 0
  br i1 %cmp9, label %if.then10, label %if.end28

if.then10:                                        ; preds = %if.then5
  call void @llvm.lifetime.start.p0(i64 4, ptr %hdr_byte_left) #1
  %dataOffset11 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %3 = load i4, ptr %dataOffset11, align 8, !tbaa !33
  %conv12 = sext i4 %3 to i32
  %sub = sub i32 %conv12, 5
  %mul = mul i32 4, %sub
  store i32 %mul, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 4, ptr %n) #1
  store i32 0, ptr %n, align 4, !tbaa !35
  br label %while.cond

while.cond:                                       ; preds = %cleanup.cont, %if.then10
  %4 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp13 = icmp sgt i32 %4, 0
  br i1 %cmp13, label %while.body, label %while.end27

while.body:                                       ; preds = %while.cond
  call void @llvm.lifetime.start.p0(i64 1, ptr %kind) #1
  %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
  store i8 %call, ptr %kind, align 1, !tbaa !20
  %5 = load i8, ptr %kind, align 1, !tbaa !20
  %conv14 = zext i8 %5 to i32
  %cmp15 = icmp eq i32 %conv14, 0
  br i1 %cmp15, label %if.then16, label %if.else

if.then16:                                        ; preds = %while.body
  %6 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec = add nsw i32 %6, -1
  store i32 %dec, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option) #1
  %7 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %7, ptr %tcp_option, align 1, !tbaa !20
  %8 = load i8, ptr %tcp_option, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %8), !primate !7
  call void @llvm.lifetime.start.p0(i64 4, ptr %i) #1
  store i32 0, ptr %i, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 16, ptr %padding) #1
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %9 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp18 = icmp sgt i32 %9, 0
  br i1 %cmp18, label %while.body19, label %while.end

while.body19:                                     ; preds = %while.cond17
  call void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind writable sret(i128) align 8 %tmp), !primate !7
  %10 = load i128, ptr %tmp, align 8, !tbaa !37
  store i128 %10, ptr %padding, align 8, !tbaa !37
  %11 = load i128, ptr %padding, align 8, !tbaa !37
  store i128 %11, ptr %indirect-arg-temp, align 8, !tbaa !37
  call void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %indirect-arg-temp), !primate !7
  %12 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %sub20 = sub nsw i32 %12, 16
  store i32 %sub20, ptr %hdr_byte_left, align 4, !tbaa !35
  br label %while.cond17, !llvm.loop !39

while.end:                                        ; preds = %while.cond17
  store i32 3, ptr %cleanup.dest.slot, align 4
  call void @llvm.lifetime.end.p0(i64 16, ptr %padding) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %i) #1
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option) #1
  br label %cleanup

if.else:                                          ; preds = %while.body
  %13 = load i8, ptr %kind, align 1, !tbaa !20
  %conv21 = zext i8 %13 to i32
  %cmp22 = icmp eq i32 %conv21, 1
  br i1 %cmp22, label %if.then23, label %if.end

if.then23:                                        ; preds = %if.else
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option24) #1
  %14 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %14, ptr %tcp_option24, align 1, !tbaa !20
  %15 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec25 = add nsw i32 %15, -1
  store i32 %dec25, ptr %hdr_byte_left, align 4, !tbaa !35
  %16 = load i8, ptr %tcp_option24, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %16), !primate !7
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option24) #1
  br label %if.end

if.end:                                           ; preds = %if.then23, %if.else
  br label %if.end26

if.end26:                                         ; preds = %if.end
  %17 = load i32, ptr %n, align 4, !tbaa !35
  %inc = add nsw i32 %17, 1
  store i32 %inc, ptr %n, align 4, !tbaa !35
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end26, %while.end
  call void @llvm.lifetime.end.p0(i64 1, ptr %kind) #1
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 3, label %while.end27
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %while.cond, !llvm.loop !41

while.end27:                                      ; preds = %cleanup, %while.cond
  call void @llvm.lifetime.end.p0(i64 4, ptr %n) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %hdr_byte_left) #1
  br label %if.end28

if.end28:                                         ; preds = %while.end27, %if.then5
  br label %if.end37

if.else29:                                        ; preds = %if.then
  %protocol30 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %18 = load i8, ptr %protocol30, align 8, !tbaa !24
  %conv31 = zext i8 %18 to i32
  %cmp32 = icmp eq i32 %conv31, 17
  br i1 %cmp32, label %if.then33, label %if.end36

if.then33:                                        ; preds = %if.else29
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp34) #1
  call void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind writable sret(%struct.udp_t) align 8 %ref.tmp34), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %udp, ptr align 8 %ref.tmp34, i32 8, i1 false), !tbaa.struct !42
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp34) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp35, ptr align 8 %udp, i32 8, i1 false), !tbaa.struct !42
  call void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %agg.tmp35), !primate !7
  br label %if.end36

if.end36:                                         ; preds = %if.then33, %if.else29
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.end28
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %entry
  call void @_ZN7PRIMATE10input_doneEv(), !primate !7
  call void @llvm.lifetime.end.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.end.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr %eth) #1
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}
Compiling to primate CPU: 
Looking to fold if.end into if.end26
Killing Trivial BB: 

if.end:                                           ; preds = %if.then23, %if.else
  br label %if.end26
Looking to fold cleanup.cont into while.cond
Killing Trivial BB: 

cleanup.cont:                                     ; preds = %cleanup
  br label %while.cond, !llvm.loop !41
Looking to fold if.end28 into if.end37
Killing Trivial BB: 

if.end28:                                         ; preds = %while.end27, %if.then5
  br label %if.end37
Looking to fold if.end36 into if.end37
Killing Trivial BB: 

if.end36:                                         ; preds = %if.then33, %if.else29
  br label %if.end37
Looking to fold if.end37 into if.end38
Killing Trivial BB: 

if.end37:                                         ; preds = %if.else29, %if.then33, %if.then5, %while.end27
  br label %if.end38
; *** IR Dump After SimplifyCFGPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() #2 {
entry:
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %udp = alloca %struct.udp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %hdr_byte_left = alloca i32, align 4
  %n = alloca i32, align 4
  %kind = alloca i8, align 1
  %tcp_option = alloca i8, align 1
  %i = alloca i32, align 4
  %padding = alloca i128, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %tcp_option24 = alloca i8, align 1
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.start.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr %ref.tmp) #1
  call void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind writable sret(%struct.ethernet_t) align 8 %ref.tmp), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %eth, ptr align 8 %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp, ptr align 8 %eth, i32 24, i1 false), !tbaa.struct !8
  call void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %agg.tmp), !primate !7
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %0 = load i16, ptr %etherType, align 8, !tbaa !15
  %conv = zext i16 %0 to i32
  %cmp = icmp eq i32 %conv, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr %ref.tmp1) #1
  call void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind writable sret(%struct.ipv4_t) align 8 %ref.tmp1), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %ipv4, ptr align 8 %ref.tmp1, i32 40, i1 false), !tbaa.struct !17
  call void @llvm.lifetime.end.p0(i64 40, ptr %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp2, ptr align 8 %ipv4, i32 40, i1 false), !tbaa.struct !17
  call void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %agg.tmp2), !primate !7
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %1 = load i8, ptr %protocol, align 8, !tbaa !24
  %conv3 = zext i8 %1 to i32
  %cmp4 = icmp eq i32 %conv3, 6
  br i1 %cmp4, label %if.then5, label %if.else29

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr %ref.tmp6) #1
  call void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind writable sret(%struct.tcp_t) align 8 %ref.tmp6), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %tcp, ptr align 8 %ref.tmp6, i32 32, i1 false), !tbaa.struct !26
  call void @llvm.lifetime.end.p0(i64 32, ptr %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp7, ptr align 8 %tcp, i32 32, i1 false), !tbaa.struct !26
  call void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %agg.tmp7), !primate !7
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %2 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv8 = sext i4 %2 to i32
  %cmp9 = icmp sgt i32 %conv8, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  call void @llvm.lifetime.start.p0(i64 4, ptr %hdr_byte_left) #1
  %dataOffset11 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %3 = load i4, ptr %dataOffset11, align 8, !tbaa !33
  %conv12 = sext i4 %3 to i32
  %sub = sub i32 %conv12, 5
  %mul = mul i32 4, %sub
  store i32 %mul, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 4, ptr %n) #1
  store i32 0, ptr %n, align 4, !tbaa !35
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %4 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp13 = icmp sgt i32 %4, 0
  br i1 %cmp13, label %while.body, label %while.end27

while.body:                                       ; preds = %while.cond
  call void @llvm.lifetime.start.p0(i64 1, ptr %kind) #1
  %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
  store i8 %call, ptr %kind, align 1, !tbaa !20
  %5 = load i8, ptr %kind, align 1, !tbaa !20
  %conv14 = zext i8 %5 to i32
  %cmp15 = icmp eq i32 %conv14, 0
  br i1 %cmp15, label %if.then16, label %if.else

if.then16:                                        ; preds = %while.body
  %6 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec = add nsw i32 %6, -1
  store i32 %dec, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option) #1
  %7 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %7, ptr %tcp_option, align 1, !tbaa !20
  %8 = load i8, ptr %tcp_option, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %8), !primate !7
  call void @llvm.lifetime.start.p0(i64 4, ptr %i) #1
  store i32 0, ptr %i, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 16, ptr %padding) #1
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %9 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp18 = icmp sgt i32 %9, 0
  br i1 %cmp18, label %while.body19, label %while.end

while.body19:                                     ; preds = %while.cond17
  call void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind writable sret(i128) align 8 %tmp), !primate !7
  %10 = load i128, ptr %tmp, align 8, !tbaa !37
  store i128 %10, ptr %padding, align 8, !tbaa !37
  %11 = load i128, ptr %padding, align 8, !tbaa !37
  store i128 %11, ptr %indirect-arg-temp, align 8, !tbaa !37
  call void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %indirect-arg-temp), !primate !7
  %12 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %sub20 = sub nsw i32 %12, 16
  store i32 %sub20, ptr %hdr_byte_left, align 4, !tbaa !35
  br label %while.cond17, !llvm.loop !39

while.end:                                        ; preds = %while.cond17
  store i32 3, ptr %cleanup.dest.slot, align 4
  call void @llvm.lifetime.end.p0(i64 16, ptr %padding) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %i) #1
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option) #1
  br label %cleanup

if.else:                                          ; preds = %while.body
  %13 = load i8, ptr %kind, align 1, !tbaa !20
  %conv21 = zext i8 %13 to i32
  %cmp22 = icmp eq i32 %conv21, 1
  br i1 %cmp22, label %if.then23, label %if.end26

if.then23:                                        ; preds = %if.else
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option24) #1
  %14 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %14, ptr %tcp_option24, align 1, !tbaa !20
  %15 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec25 = add nsw i32 %15, -1
  store i32 %dec25, ptr %hdr_byte_left, align 4, !tbaa !35
  %16 = load i8, ptr %tcp_option24, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %16), !primate !7
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option24) #1
  br label %if.end26

if.end26:                                         ; preds = %if.else, %if.then23
  %17 = load i32, ptr %n, align 4, !tbaa !35
  %inc = add nsw i32 %17, 1
  store i32 %inc, ptr %n, align 4, !tbaa !35
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end26, %while.end
  call void @llvm.lifetime.end.p0(i64 1, ptr %kind) #1
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %while.cond
    i32 3, label %while.end27
  ], !llvm.loop !41

while.end27:                                      ; preds = %cleanup, %while.cond
  call void @llvm.lifetime.end.p0(i64 4, ptr %n) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %hdr_byte_left) #1
  br label %if.end38

if.else29:                                        ; preds = %if.then
  %protocol30 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %18 = load i8, ptr %protocol30, align 8, !tbaa !24
  %conv31 = zext i8 %18 to i32
  %cmp32 = icmp eq i32 %conv31, 17
  br i1 %cmp32, label %if.then33, label %if.end38

if.then33:                                        ; preds = %if.else29
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp34) #1
  call void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind writable sret(%struct.udp_t) align 8 %ref.tmp34), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %udp, ptr align 8 %ref.tmp34, i32 8, i1 false), !tbaa.struct !42
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp34) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp35, ptr align 8 %udp, i32 8, i1 false), !tbaa.struct !42
  call void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %agg.tmp35), !primate !7
  br label %if.end38

if.end38:                                         ; preds = %while.end27, %if.then5, %if.then33, %if.else29, %entry
  call void @_ZN7PRIMATE10input_doneEv(), !primate !7
  call void @llvm.lifetime.end.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.end.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr %eth) #1
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}
EarlyCSE CVP: Add conditional value for 'cmp' as i1 true in if.then
EarlyCSE CVP: Add conditional value for 'cmp4' as i1 true in if.then5
EarlyCSE CVP: Add conditional value for 'cmp9' as i1 true in if.then10
EarlyCSE CSE GEP:   %dataOffset11 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1  to:   %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
EarlyCSE CVP: Add conditional value for 'cmp13' as i1 true in while.body
EarlyCSE CSE LOAD:   %5 = load i8, ptr %kind, align 1, !tbaa !20  to:   store i8 %call, ptr %kind, align 1, !tbaa !20
EarlyCSE CVP: Add conditional value for 'cmp15' as i1 true in if.then16
EarlyCSE CSE LOAD:   %7 = load i8, ptr %tcp_option, align 1, !tbaa !20  to:   store i8 %6, ptr %tcp_option, align 1, !tbaa !20
EarlyCSE CVP: Add conditional value for 'cmp18' as i1 true in while.body19
EarlyCSE CSE LOAD:   %9 = load i128, ptr %padding, align 8, !tbaa !37  to:   store i128 %8, ptr %padding, align 8, !tbaa !37
EarlyCSE CVP: Add conditional value for 'cmp18' as i1 false in while.end
EarlyCSE CVP: Add conditional value for 'cmp15' as i1 false in if.else
EarlyCSE CSE LOAD:   %10 = load i8, ptr %kind, align 1, !tbaa !20  to:   store i8 %call, ptr %kind, align 1, !tbaa !20
EarlyCSE CSE:   %conv21 = zext i8 %call to i32  to:   %conv14 = zext i8 %call to i32
EarlyCSE CVP: Add conditional value for 'cmp22' as i1 true in if.then23
EarlyCSE CVP: Add conditional value for 'cmp4' as i1 false in if.else29
EarlyCSE CSE GEP:   %protocol30 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1  to:   %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
EarlyCSE CSE LOAD:   %14 = load i8, ptr %protocol, align 8, !tbaa !24  to:   %1 = load i8, ptr %protocol, align 8, !tbaa !24
EarlyCSE CSE:   %conv31 = zext i8 %1 to i32  to:   %conv3 = zext i8 %1 to i32
EarlyCSE CVP: Add conditional value for 'cmp32' as i1 true in if.then33
; *** IR Dump After EarlyCSEPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() #2 {
entry:
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %udp = alloca %struct.udp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %hdr_byte_left = alloca i32, align 4
  %n = alloca i32, align 4
  %kind = alloca i8, align 1
  %tcp_option = alloca i8, align 1
  %i = alloca i32, align 4
  %padding = alloca i128, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %tcp_option24 = alloca i8, align 1
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.start.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr %ref.tmp) #1
  call void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind writable sret(%struct.ethernet_t) align 8 %ref.tmp), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %eth, ptr align 8 %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp, ptr align 8 %eth, i32 24, i1 false), !tbaa.struct !8
  call void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %agg.tmp), !primate !7
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %0 = load i16, ptr %etherType, align 8, !tbaa !15
  %conv = zext i16 %0 to i32
  %cmp = icmp eq i32 %conv, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr %ref.tmp1) #1
  call void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind writable sret(%struct.ipv4_t) align 8 %ref.tmp1), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %ipv4, ptr align 8 %ref.tmp1, i32 40, i1 false), !tbaa.struct !17
  call void @llvm.lifetime.end.p0(i64 40, ptr %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp2, ptr align 8 %ipv4, i32 40, i1 false), !tbaa.struct !17
  call void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %agg.tmp2), !primate !7
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %1 = load i8, ptr %protocol, align 8, !tbaa !24
  %conv3 = zext i8 %1 to i32
  %cmp4 = icmp eq i32 %conv3, 6
  br i1 %cmp4, label %if.then5, label %if.else29

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr %ref.tmp6) #1
  call void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind writable sret(%struct.tcp_t) align 8 %ref.tmp6), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %tcp, ptr align 8 %ref.tmp6, i32 32, i1 false), !tbaa.struct !26
  call void @llvm.lifetime.end.p0(i64 32, ptr %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp7, ptr align 8 %tcp, i32 32, i1 false), !tbaa.struct !26
  call void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %agg.tmp7), !primate !7
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %2 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv8 = sext i4 %2 to i32
  %cmp9 = icmp sgt i32 %conv8, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  call void @llvm.lifetime.start.p0(i64 4, ptr %hdr_byte_left) #1
  %3 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv12 = sext i4 %3 to i32
  %sub = sub i32 %conv12, 5
  %mul = mul i32 4, %sub
  store i32 %mul, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 4, ptr %n) #1
  store i32 0, ptr %n, align 4, !tbaa !35
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %4 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp13 = icmp sgt i32 %4, 0
  br i1 %cmp13, label %while.body, label %while.end27

while.body:                                       ; preds = %while.cond
  call void @llvm.lifetime.start.p0(i64 1, ptr %kind) #1
  %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
  store i8 %call, ptr %kind, align 1, !tbaa !20
  %conv14 = zext i8 %call to i32
  %cmp15 = icmp eq i32 %conv14, 0
  br i1 %cmp15, label %if.then16, label %if.else

if.then16:                                        ; preds = %while.body
  %5 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec = add nsw i32 %5, -1
  store i32 %dec, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option) #1
  %6 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %6, ptr %tcp_option, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %6), !primate !7
  call void @llvm.lifetime.start.p0(i64 4, ptr %i) #1
  store i32 0, ptr %i, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 16, ptr %padding) #1
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %7 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp18 = icmp sgt i32 %7, 0
  br i1 %cmp18, label %while.body19, label %while.end

while.body19:                                     ; preds = %while.cond17
  call void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind writable sret(i128) align 8 %tmp), !primate !7
  %8 = load i128, ptr %tmp, align 8, !tbaa !37
  store i128 %8, ptr %padding, align 8, !tbaa !37
  store i128 %8, ptr %indirect-arg-temp, align 8, !tbaa !37
  call void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %indirect-arg-temp), !primate !7
  %9 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %sub20 = sub nsw i32 %9, 16
  store i32 %sub20, ptr %hdr_byte_left, align 4, !tbaa !35
  br label %while.cond17, !llvm.loop !39

while.end:                                        ; preds = %while.cond17
  store i32 3, ptr %cleanup.dest.slot, align 4
  call void @llvm.lifetime.end.p0(i64 16, ptr %padding) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %i) #1
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option) #1
  br label %cleanup

if.else:                                          ; preds = %while.body
  %cmp22 = icmp eq i32 %conv14, 1
  br i1 %cmp22, label %if.then23, label %if.end26

if.then23:                                        ; preds = %if.else
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option24) #1
  %10 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %10, ptr %tcp_option24, align 1, !tbaa !20
  %11 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec25 = add nsw i32 %11, -1
  store i32 %dec25, ptr %hdr_byte_left, align 4, !tbaa !35
  %12 = load i8, ptr %tcp_option24, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %12), !primate !7
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option24) #1
  br label %if.end26

if.end26:                                         ; preds = %if.else, %if.then23
  %13 = load i32, ptr %n, align 4, !tbaa !35
  %inc = add nsw i32 %13, 1
  store i32 %inc, ptr %n, align 4, !tbaa !35
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end26, %while.end
  call void @llvm.lifetime.end.p0(i64 1, ptr %kind) #1
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %while.cond
    i32 3, label %while.end27
  ], !llvm.loop !41

while.end27:                                      ; preds = %cleanup, %while.cond
  call void @llvm.lifetime.end.p0(i64 4, ptr %n) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %hdr_byte_left) #1
  br label %if.end38

if.else29:                                        ; preds = %if.then
  %cmp32 = icmp eq i32 %conv3, 17
  br i1 %cmp32, label %if.then33, label %if.end38

if.then33:                                        ; preds = %if.else29
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp34) #1
  call void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind writable sret(%struct.udp_t) align 8 %ref.tmp34), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %udp, ptr align 8 %ref.tmp34, i32 8, i1 false), !tbaa.struct !42
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp34) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp35, ptr align 8 %udp, i32 8, i1 false), !tbaa.struct !42
  call void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %agg.tmp35), !primate !7
  br label %if.end38

if.end38:                                         ; preds = %while.end27, %if.then5, %if.then33, %if.else29, %entry
  call void @_ZN7PRIMATE10input_doneEv(), !primate !7
  call void @llvm.lifetime.end.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.end.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr %eth) #1
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}
; *** IR Dump After CallSiteSplittingPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() #2 {
entry:
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %udp = alloca %struct.udp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %hdr_byte_left = alloca i32, align 4
  %n = alloca i32, align 4
  %kind = alloca i8, align 1
  %tcp_option = alloca i8, align 1
  %i = alloca i32, align 4
  %padding = alloca i128, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %tcp_option24 = alloca i8, align 1
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.start.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr %ref.tmp) #1
  call void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind writable sret(%struct.ethernet_t) align 8 %ref.tmp), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %eth, ptr align 8 %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp, ptr align 8 %eth, i32 24, i1 false), !tbaa.struct !8
  call void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %agg.tmp), !primate !7
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %0 = load i16, ptr %etherType, align 8, !tbaa !15
  %conv = zext i16 %0 to i32
  %cmp = icmp eq i32 %conv, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr %ref.tmp1) #1
  call void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind writable sret(%struct.ipv4_t) align 8 %ref.tmp1), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %ipv4, ptr align 8 %ref.tmp1, i32 40, i1 false), !tbaa.struct !17
  call void @llvm.lifetime.end.p0(i64 40, ptr %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp2, ptr align 8 %ipv4, i32 40, i1 false), !tbaa.struct !17
  call void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %agg.tmp2), !primate !7
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %1 = load i8, ptr %protocol, align 8, !tbaa !24
  %conv3 = zext i8 %1 to i32
  %cmp4 = icmp eq i32 %conv3, 6
  br i1 %cmp4, label %if.then5, label %if.else29

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr %ref.tmp6) #1
  call void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind writable sret(%struct.tcp_t) align 8 %ref.tmp6), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %tcp, ptr align 8 %ref.tmp6, i32 32, i1 false), !tbaa.struct !26
  call void @llvm.lifetime.end.p0(i64 32, ptr %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp7, ptr align 8 %tcp, i32 32, i1 false), !tbaa.struct !26
  call void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %agg.tmp7), !primate !7
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %2 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv8 = sext i4 %2 to i32
  %cmp9 = icmp sgt i32 %conv8, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  call void @llvm.lifetime.start.p0(i64 4, ptr %hdr_byte_left) #1
  %3 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv12 = sext i4 %3 to i32
  %sub = sub i32 %conv12, 5
  %mul = mul i32 4, %sub
  store i32 %mul, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 4, ptr %n) #1
  store i32 0, ptr %n, align 4, !tbaa !35
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %4 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp13 = icmp sgt i32 %4, 0
  br i1 %cmp13, label %while.body, label %while.end27

while.body:                                       ; preds = %while.cond
  call void @llvm.lifetime.start.p0(i64 1, ptr %kind) #1
  %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
  store i8 %call, ptr %kind, align 1, !tbaa !20
  %conv14 = zext i8 %call to i32
  %cmp15 = icmp eq i32 %conv14, 0
  br i1 %cmp15, label %if.then16, label %if.else

if.then16:                                        ; preds = %while.body
  %5 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec = add nsw i32 %5, -1
  store i32 %dec, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option) #1
  %6 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %6, ptr %tcp_option, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %6), !primate !7
  call void @llvm.lifetime.start.p0(i64 4, ptr %i) #1
  store i32 0, ptr %i, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 16, ptr %padding) #1
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %7 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp18 = icmp sgt i32 %7, 0
  br i1 %cmp18, label %while.body19, label %while.end

while.body19:                                     ; preds = %while.cond17
  call void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind writable sret(i128) align 8 %tmp), !primate !7
  %8 = load i128, ptr %tmp, align 8, !tbaa !37
  store i128 %8, ptr %padding, align 8, !tbaa !37
  store i128 %8, ptr %indirect-arg-temp, align 8, !tbaa !37
  call void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %indirect-arg-temp), !primate !7
  %9 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %sub20 = sub nsw i32 %9, 16
  store i32 %sub20, ptr %hdr_byte_left, align 4, !tbaa !35
  br label %while.cond17, !llvm.loop !39

while.end:                                        ; preds = %while.cond17
  store i32 3, ptr %cleanup.dest.slot, align 4
  call void @llvm.lifetime.end.p0(i64 16, ptr %padding) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %i) #1
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option) #1
  br label %cleanup

if.else:                                          ; preds = %while.body
  %cmp22 = icmp eq i32 %conv14, 1
  br i1 %cmp22, label %if.then23, label %if.end26

if.then23:                                        ; preds = %if.else
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option24) #1
  %10 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %10, ptr %tcp_option24, align 1, !tbaa !20
  %11 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec25 = add nsw i32 %11, -1
  store i32 %dec25, ptr %hdr_byte_left, align 4, !tbaa !35
  %12 = load i8, ptr %tcp_option24, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %12), !primate !7
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option24) #1
  br label %if.end26

if.end26:                                         ; preds = %if.else, %if.then23
  %13 = load i32, ptr %n, align 4, !tbaa !35
  %inc = add nsw i32 %13, 1
  store i32 %inc, ptr %n, align 4, !tbaa !35
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end26, %while.end
  call void @llvm.lifetime.end.p0(i64 1, ptr %kind) #1
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %while.cond
    i32 3, label %while.end27
  ], !llvm.loop !41

while.end27:                                      ; preds = %cleanup, %while.cond
  call void @llvm.lifetime.end.p0(i64 4, ptr %n) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %hdr_byte_left) #1
  br label %if.end38

if.else29:                                        ; preds = %if.then
  %cmp32 = icmp eq i32 %conv3, 17
  br i1 %cmp32, label %if.then33, label %if.end38

if.then33:                                        ; preds = %if.else29
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp34) #1
  call void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind writable sret(%struct.udp_t) align 8 %ref.tmp34), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %udp, ptr align 8 %ref.tmp34, i32 8, i1 false), !tbaa.struct !42
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp34) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp35, ptr align 8 %udp, i32 8, i1 false), !tbaa.struct !42
  call void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %agg.tmp35), !primate !7
  br label %if.end38

if.end38:                                         ; preds = %while.end27, %if.then5, %if.then33, %if.else29, %entry
  call void @_ZN7PRIMATE10input_doneEv(), !primate !7
  call void @llvm.lifetime.end.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.end.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr %eth) #1
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}
; *** IR Dump After LowerExpectIntrinsicPass on _ZN7PRIMATE5inputI10ethernet_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ethernet_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 24, i1 false), !tbaa.struct !8
  ret void
}
Compiling to primate CPU: 
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE5inputI10ethernet_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ethernet_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 24, i1 false), !tbaa.struct !8
  ret void
}
; *** IR Dump After EarlyCSEPass on _ZN7PRIMATE5inputI10ethernet_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ethernet_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 24, i1 false), !tbaa.struct !8
  ret void
}
; *** IR Dump After CallSiteSplittingPass on _ZN7PRIMATE5inputI10ethernet_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ethernet_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 24, i1 false), !tbaa.struct !8
  ret void
}
; *** IR Dump After LowerExpectIntrinsicPass on _ZN7PRIMATE6outputI10ethernet_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 24)
  ret void
}
Compiling to primate CPU: 
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE6outputI10ethernet_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 24)
  ret void
}
; *** IR Dump After EarlyCSEPass on _ZN7PRIMATE6outputI10ethernet_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 24)
  ret void
}
; *** IR Dump After CallSiteSplittingPass on _ZN7PRIMATE6outputI10ethernet_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 24)
  ret void
}
; *** IR Dump After LowerExpectIntrinsicPass on _ZN7PRIMATE5inputI6ipv4_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ipv4_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 40)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 40, i1 false), !tbaa.struct !17
  ret void
}
Compiling to primate CPU: 
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE5inputI6ipv4_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ipv4_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 40)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 40, i1 false), !tbaa.struct !17
  ret void
}
; *** IR Dump After EarlyCSEPass on _ZN7PRIMATE5inputI6ipv4_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ipv4_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 40)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 40, i1 false), !tbaa.struct !17
  ret void
}
; *** IR Dump After CallSiteSplittingPass on _ZN7PRIMATE5inputI6ipv4_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ipv4_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 40)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 40, i1 false), !tbaa.struct !17
  ret void
}
; *** IR Dump After LowerExpectIntrinsicPass on _ZN7PRIMATE6outputI6ipv4_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 40)
  ret void
}
Compiling to primate CPU: 
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE6outputI6ipv4_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 40)
  ret void
}
; *** IR Dump After EarlyCSEPass on _ZN7PRIMATE6outputI6ipv4_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 40)
  ret void
}
; *** IR Dump After CallSiteSplittingPass on _ZN7PRIMATE6outputI6ipv4_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 40)
  ret void
}
; *** IR Dump After LowerExpectIntrinsicPass on _ZN7PRIMATE5inputI5tcp_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.tcp_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 32)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 32, i1 false), !tbaa.struct !26
  ret void
}
Compiling to primate CPU: 
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE5inputI5tcp_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.tcp_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 32)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 32, i1 false), !tbaa.struct !26
  ret void
}
; *** IR Dump After EarlyCSEPass on _ZN7PRIMATE5inputI5tcp_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.tcp_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 32)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 32, i1 false), !tbaa.struct !26
  ret void
}
; *** IR Dump After CallSiteSplittingPass on _ZN7PRIMATE5inputI5tcp_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.tcp_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 32)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 32, i1 false), !tbaa.struct !26
  ret void
}
; *** IR Dump After LowerExpectIntrinsicPass on _ZN7PRIMATE6outputI5tcp_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 32)
  ret void
}
Compiling to primate CPU: 
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE6outputI5tcp_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 32)
  ret void
}
; *** IR Dump After EarlyCSEPass on _ZN7PRIMATE6outputI5tcp_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 32)
  ret void
}
; *** IR Dump After CallSiteSplittingPass on _ZN7PRIMATE6outputI5tcp_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 32)
  ret void
}
; *** IR Dump After LowerExpectIntrinsicPass on _ZN7PRIMATE5inputIDU8_EET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v() #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %1 = load i8, ptr %0, align 1, !tbaa !20
  ret i8 %1
}
Compiling to primate CPU: 
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE5inputIDU8_EET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v() #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %1 = load i8, ptr %0, align 1, !tbaa !20
  ret i8 %1
}
; *** IR Dump After EarlyCSEPass on _ZN7PRIMATE5inputIDU8_EET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v() #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %1 = load i8, ptr %0, align 1, !tbaa !20
  ret i8 %1
}
; *** IR Dump After CallSiteSplittingPass on _ZN7PRIMATE5inputIDU8_EET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v() #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %1 = load i8, ptr %0, align 1, !tbaa !20
  ret i8 %1
}
; *** IR Dump After LowerExpectIntrinsicPass on _ZN7PRIMATE6outputIDU8_EEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %out) #0 comdat !primate !7 {
entry:
  %out.addr = alloca i8, align 1
  store i8 %out, ptr %out.addr, align 1, !tbaa !20
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 1)
  ret void
}
Compiling to primate CPU: 
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE6outputIDU8_EEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %out) #0 comdat !primate !7 {
entry:
  %out.addr = alloca i8, align 1
  store i8 %out, ptr %out.addr, align 1, !tbaa !20
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 1)
  ret void
}
; *** IR Dump After EarlyCSEPass on _ZN7PRIMATE6outputIDU8_EEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %out) #0 comdat !primate !7 {
entry:
  %out.addr = alloca i8, align 1
  store i8 %out, ptr %out.addr, align 1, !tbaa !20
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 1)
  ret void
}
; *** IR Dump After CallSiteSplittingPass on _ZN7PRIMATE6outputIDU8_EEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %out) #0 comdat !primate !7 {
entry:
  %out.addr = alloca i8, align 1
  store i8 %out, ptr %out.addr, align 1, !tbaa !20
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 1)
  ret void
}
; *** IR Dump After LowerExpectIntrinsicPass on _ZN7PRIMATE5inputIDU128_EET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind noalias writable sret(i128) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 16)
  %1 = load i128, ptr %0, align 8, !tbaa !37
  store i128 %1, ptr %agg.result, align 8
  %2 = load i128, ptr %agg.result, align 8
  store i128 %2, ptr %agg.result, align 8, !tbaa !37
  ret void
}
Compiling to primate CPU: 
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE5inputIDU128_EET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind noalias writable sret(i128) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 16)
  %1 = load i128, ptr %0, align 8, !tbaa !37
  store i128 %1, ptr %agg.result, align 8
  %2 = load i128, ptr %agg.result, align 8
  store i128 %2, ptr %agg.result, align 8, !tbaa !37
  ret void
}
EarlyCSE CSE LOAD:   %2 = load i128, ptr %agg.result, align 8  to:   store i128 %1, ptr %agg.result, align 8
EarlyCSE DEAD STORE:   store i128 %1, ptr %agg.result, align 8  due to:   store i128 %1, ptr %agg.result, align 8, !tbaa !8
; *** IR Dump After EarlyCSEPass on _ZN7PRIMATE5inputIDU128_EET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind noalias writable sret(i128) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 16)
  %1 = load i128, ptr %0, align 8, !tbaa !37
  store i128 %1, ptr %agg.result, align 8, !tbaa !37
  ret void
}
; *** IR Dump After CallSiteSplittingPass on _ZN7PRIMATE5inputIDU128_EET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind noalias writable sret(i128) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 16)
  %1 = load i128, ptr %0, align 8, !tbaa !37
  store i128 %1, ptr %agg.result, align 8, !tbaa !37
  ret void
}
; *** IR Dump After LowerExpectIntrinsicPass on _ZN7PRIMATE6outputIDU128_EEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %0) #0 comdat !primate !7 {
entry:
  %out.addr = alloca i128, align 8
  %out = load i128, ptr %0, align 8, !tbaa !37
  store i128 %out, ptr %out.addr, align 8, !tbaa !37
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 16)
  ret void
}
Compiling to primate CPU: 
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE6outputIDU128_EEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %0) #0 comdat !primate !7 {
entry:
  %out.addr = alloca i128, align 8
  %out = load i128, ptr %0, align 8, !tbaa !37
  store i128 %out, ptr %out.addr, align 8, !tbaa !37
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 16)
  ret void
}
; *** IR Dump After EarlyCSEPass on _ZN7PRIMATE6outputIDU128_EEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %0) #0 comdat !primate !7 {
entry:
  %out.addr = alloca i128, align 8
  %out = load i128, ptr %0, align 8, !tbaa !37
  store i128 %out, ptr %out.addr, align 8, !tbaa !37
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 16)
  ret void
}
; *** IR Dump After CallSiteSplittingPass on _ZN7PRIMATE6outputIDU128_EEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %0) #0 comdat !primate !7 {
entry:
  %out.addr = alloca i128, align 8
  %out = load i128, ptr %0, align 8, !tbaa !37
  store i128 %out, ptr %out.addr, align 8, !tbaa !37
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 16)
  ret void
}
; *** IR Dump After LowerExpectIntrinsicPass on _ZN7PRIMATE5inputI5udp_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.udp_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 8)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 8, i1 false), !tbaa.struct !42
  ret void
}
Compiling to primate CPU: 
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE5inputI5udp_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.udp_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 8)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 8, i1 false), !tbaa.struct !42
  ret void
}
; *** IR Dump After EarlyCSEPass on _ZN7PRIMATE5inputI5udp_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.udp_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 8)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 8, i1 false), !tbaa.struct !42
  ret void
}
; *** IR Dump After CallSiteSplittingPass on _ZN7PRIMATE5inputI5udp_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.udp_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 8)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 8, i1 false), !tbaa.struct !42
  ret void
}
; *** IR Dump After LowerExpectIntrinsicPass on _ZN7PRIMATE6outputI5udp_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 8)
  ret void
}
Compiling to primate CPU: 
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE6outputI5udp_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 8)
  ret void
}
; *** IR Dump After EarlyCSEPass on _ZN7PRIMATE6outputI5udp_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 8)
  ret void
}
; *** IR Dump After CallSiteSplittingPass on _ZN7PRIMATE6outputI5udp_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 8)
  ret void
}
; *** IR Dump After OpenMPOptPass on [module] ***
; ModuleID = 'tcp_parse.cpp'
source_filename = "tcp_parse.cpp"
target datalayout = "e-G1-m:e-p:32:32-i64:64-n32-S128"
target triple = "primate32-unknown-linux-gnu"

%struct.ethernet_t = type { i48, i48, i16 }
%struct.ipv4_t = type { i72, i8, i80 }
%struct.tcp_t = type { i96, i4, i60 }
%struct.udp_t = type { i64 }

$_ZN7PRIMATE5inputI10ethernet_tEET_v = comdat any

$_ZN7PRIMATE6outputI10ethernet_tEEvT_ = comdat any

$_ZN7PRIMATE5inputI6ipv4_tEET_v = comdat any

$_ZN7PRIMATE6outputI6ipv4_tEEvT_ = comdat any

$_ZN7PRIMATE5inputI5tcp_tEET_v = comdat any

$_ZN7PRIMATE6outputI5tcp_tEEvT_ = comdat any

$_ZN7PRIMATE5inputIDU8_EET_v = comdat any

$_ZN7PRIMATE6outputIDU8_EEvT_ = comdat any

$_ZN7PRIMATE5inputIDU128_EET_v = comdat any

$_ZN7PRIMATE6outputIDU128_EEvT_ = comdat any

$_ZN7PRIMATE5inputI5udp_tEET_v = comdat any

$_ZN7PRIMATE6outputI5udp_tEEvT_ = comdat any

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.done() #1

; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() #2 {
entry:
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %udp = alloca %struct.udp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %hdr_byte_left = alloca i32, align 4
  %n = alloca i32, align 4
  %kind = alloca i8, align 1
  %tcp_option = alloca i8, align 1
  %i = alloca i32, align 4
  %padding = alloca i128, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %tcp_option24 = alloca i8, align 1
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.start.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr %ref.tmp) #1
  call void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind writable sret(%struct.ethernet_t) align 8 %ref.tmp), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %eth, ptr align 8 %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp, ptr align 8 %eth, i32 24, i1 false), !tbaa.struct !8
  call void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %agg.tmp), !primate !7
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %0 = load i16, ptr %etherType, align 8, !tbaa !15
  %conv = zext i16 %0 to i32
  %cmp = icmp eq i32 %conv, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr %ref.tmp1) #1
  call void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind writable sret(%struct.ipv4_t) align 8 %ref.tmp1), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %ipv4, ptr align 8 %ref.tmp1, i32 40, i1 false), !tbaa.struct !17
  call void @llvm.lifetime.end.p0(i64 40, ptr %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp2, ptr align 8 %ipv4, i32 40, i1 false), !tbaa.struct !17
  call void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %agg.tmp2), !primate !7
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %1 = load i8, ptr %protocol, align 8, !tbaa !24
  %conv3 = zext i8 %1 to i32
  %cmp4 = icmp eq i32 %conv3, 6
  br i1 %cmp4, label %if.then5, label %if.else29

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr %ref.tmp6) #1
  call void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind writable sret(%struct.tcp_t) align 8 %ref.tmp6), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %tcp, ptr align 8 %ref.tmp6, i32 32, i1 false), !tbaa.struct !26
  call void @llvm.lifetime.end.p0(i64 32, ptr %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp7, ptr align 8 %tcp, i32 32, i1 false), !tbaa.struct !26
  call void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %agg.tmp7), !primate !7
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %2 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv8 = sext i4 %2 to i32
  %cmp9 = icmp sgt i32 %conv8, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  call void @llvm.lifetime.start.p0(i64 4, ptr %hdr_byte_left) #1
  %3 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv12 = sext i4 %3 to i32
  %sub = sub i32 %conv12, 5
  %mul = mul i32 4, %sub
  store i32 %mul, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 4, ptr %n) #1
  store i32 0, ptr %n, align 4, !tbaa !35
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %4 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp13 = icmp sgt i32 %4, 0
  br i1 %cmp13, label %while.body, label %while.end27

while.body:                                       ; preds = %while.cond
  call void @llvm.lifetime.start.p0(i64 1, ptr %kind) #1
  %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
  store i8 %call, ptr %kind, align 1, !tbaa !20
  %conv14 = zext i8 %call to i32
  %cmp15 = icmp eq i32 %conv14, 0
  br i1 %cmp15, label %if.then16, label %if.else

if.then16:                                        ; preds = %while.body
  %5 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec = add nsw i32 %5, -1
  store i32 %dec, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option) #1
  %6 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %6, ptr %tcp_option, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %6), !primate !7
  call void @llvm.lifetime.start.p0(i64 4, ptr %i) #1
  store i32 0, ptr %i, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 16, ptr %padding) #1
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %7 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp18 = icmp sgt i32 %7, 0
  br i1 %cmp18, label %while.body19, label %while.end

while.body19:                                     ; preds = %while.cond17
  call void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind writable sret(i128) align 8 %tmp), !primate !7
  %8 = load i128, ptr %tmp, align 8, !tbaa !37
  store i128 %8, ptr %padding, align 8, !tbaa !37
  store i128 %8, ptr %indirect-arg-temp, align 8, !tbaa !37
  call void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %indirect-arg-temp), !primate !7
  %9 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %sub20 = sub nsw i32 %9, 16
  store i32 %sub20, ptr %hdr_byte_left, align 4, !tbaa !35
  br label %while.cond17, !llvm.loop !39

while.end:                                        ; preds = %while.cond17
  store i32 3, ptr %cleanup.dest.slot, align 4
  call void @llvm.lifetime.end.p0(i64 16, ptr %padding) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %i) #1
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option) #1
  br label %cleanup

if.else:                                          ; preds = %while.body
  %cmp22 = icmp eq i32 %conv14, 1
  br i1 %cmp22, label %if.then23, label %if.end26

if.then23:                                        ; preds = %if.else
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option24) #1
  %10 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %10, ptr %tcp_option24, align 1, !tbaa !20
  %11 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec25 = add nsw i32 %11, -1
  store i32 %dec25, ptr %hdr_byte_left, align 4, !tbaa !35
  %12 = load i8, ptr %tcp_option24, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %12), !primate !7
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option24) #1
  br label %if.end26

if.end26:                                         ; preds = %if.else, %if.then23
  %13 = load i32, ptr %n, align 4, !tbaa !35
  %inc = add nsw i32 %13, 1
  store i32 %inc, ptr %n, align 4, !tbaa !35
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end26, %while.end
  call void @llvm.lifetime.end.p0(i64 1, ptr %kind) #1
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %while.cond
    i32 3, label %while.end27
  ], !llvm.loop !41

while.end27:                                      ; preds = %cleanup, %while.cond
  call void @llvm.lifetime.end.p0(i64 4, ptr %n) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %hdr_byte_left) #1
  br label %if.end38

if.else29:                                        ; preds = %if.then
  %cmp32 = icmp eq i32 %conv3, 17
  br i1 %cmp32, label %if.then33, label %if.end38

if.then33:                                        ; preds = %if.else29
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp34) #1
  call void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind writable sret(%struct.udp_t) align 8 %ref.tmp34), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %udp, ptr align 8 %ref.tmp34, i32 8, i1 false), !tbaa.struct !42
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp34) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp35, ptr align 8 %udp, i32 8, i1 false), !tbaa.struct !42
  call void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %agg.tmp35), !primate !7
  br label %if.end38

if.end38:                                         ; preds = %while.end27, %if.then5, %if.then33, %if.else29, %entry
  call void @_ZN7PRIMATE10input_doneEv(), !primate !7
  call void @llvm.lifetime.end.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.end.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr %eth) #1
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ethernet_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 24, i1 false), !tbaa.struct !8
  ret void
}

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i32(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i32, i1 immarg) #4

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 24)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ipv4_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 40)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 40, i1 false), !tbaa.struct !17
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 40)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.tcp_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 32)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 32, i1 false), !tbaa.struct !26
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 32)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v() #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %1 = load i8, ptr %0, align 1, !tbaa !20
  ret i8 %1
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %out) #0 comdat !primate !7 {
entry:
  %out.addr = alloca i8, align 1
  store i8 %out, ptr %out.addr, align 1, !tbaa !20
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 1)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind noalias writable sret(i128) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 16)
  %1 = load i128, ptr %0, align 8, !tbaa !37
  store i128 %1, ptr %agg.result, align 8, !tbaa !37
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %0) #0 comdat !primate !7 {
entry:
  %out.addr = alloca i128, align 8
  %out = load i128, ptr %0, align 8, !tbaa !37
  store i128 %out, ptr %out.addr, align 8, !tbaa !37
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 16)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.udp_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 8)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 8, i1 false), !tbaa.struct !42
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 8)
  ret void
}

; Function Attrs: nounwind
declare !primate !7 ptr @llvm.primate.input.p0.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.p0.i32(ptr, i32) #1

attributes #0 = { alwaysinline mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #1 = { nounwind }
attributes #2 = { mustprogress "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #3 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5}
!llvm.ident = !{!6}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"ilp32"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{i32 8, !"SmallDataLimit", i32 8}
!6 = !{!"clang version 18.1.8 (git@github.com:FAST-Research-Group/primate-arch-gen.git e8582d4315ec2267abfc97212fa19f342d0812e8)"}
!7 = !{!"blue", !"IO", i64 1, i64 1}
!8 = !{i64 0, i64 8, !9, i64 8, i64 8, !9, i64 16, i64 2, !13}
!9 = !{!10, !10, i64 0}
!10 = !{!"_BitInt(48)", !11, i64 0}
!11 = !{!"omnipotent char", !12, i64 0}
!12 = !{!"Simple C++ TBAA"}
!13 = !{!14, !14, i64 0}
!14 = !{!"_BitInt(16)", !11, i64 0}
!15 = !{!16, !14, i64 16}
!16 = !{!"_ZTS10ethernet_t", !10, i64 0, !10, i64 8, !14, i64 16}
!17 = !{i64 0, i64 16, !18, i64 16, i64 1, !20, i64 24, i64 16, !22}
!18 = !{!19, !19, i64 0}
!19 = !{!"_BitInt(72)", !11, i64 0}
!20 = !{!21, !21, i64 0}
!21 = !{!"_BitInt(8)", !11, i64 0}
!22 = !{!23, !23, i64 0}
!23 = !{!"_BitInt(80)", !11, i64 0}
!24 = !{!25, !21, i64 16}
!25 = !{!"_ZTS6ipv4_t", !19, i64 0, !21, i64 16, !23, i64 24}
!26 = !{i64 0, i64 16, !27, i64 16, i64 1, !29, i64 24, i64 8, !31}
!27 = !{!28, !28, i64 0}
!28 = !{!"_BitInt(96)", !11, i64 0}
!29 = !{!30, !30, i64 0}
!30 = !{!"_BitInt(4)", !11, i64 0}
!31 = !{!32, !32, i64 0}
!32 = !{!"_BitInt(60)", !11, i64 0}
!33 = !{!34, !30, i64 16}
!34 = !{!"_ZTS5tcp_t", !28, i64 0, !30, i64 16, !32, i64 24}
!35 = !{!36, !36, i64 0}
!36 = !{!"int", !11, i64 0}
!37 = !{!38, !38, i64 0}
!38 = !{!"_BitInt(128)", !11, i64 0}
!39 = distinct !{!39, !40}
!40 = !{!"llvm.loop.mustprogress"}
!41 = distinct !{!41, !40}
!42 = !{i64 0, i64 8, !43}
!43 = !{!44, !44, i64 0}
!44 = !{!"_BitInt(64)", !11, i64 0}
Marking Block Executable: entry
Marking Block Executable: entry
Visiting   %conv3 = zext i8 %1 to i32
Rename Stack is empty
Current DFS numbers are (1,34)
Rename Stack is empty
Current DFS numbers are (2,29)
Rename Stack Top DFS numbers are (2,29)
Current DFS numbers are (30,33)
Rename Stack Top DFS numbers are (30,33)
Current DFS numbers are (30,33)
Found replacement   %conv3.0 = call i32 @llvm.ssa.copy.i32(i32 %conv3) for   %conv3 = zext i8 %1 to i32 in   %cmp32 = icmp eq i32 %conv3, 17
Rename Stack Top DFS numbers are (30,33)
Current DFS numbers are (30,33)
Rename Stack Top DFS numbers are (30,33)
Current DFS numbers are (31,32)
Visiting   %conv14 = zext i8 %call to i32
Rename Stack is empty
Current DFS numbers are (5,24)
Rename Stack is empty
Current DFS numbers are (6,13)
Rename Stack Top DFS numbers are (6,13)
Current DFS numbers are (18,23)
Rename Stack Top DFS numbers are (18,23)
Current DFS numbers are (18,23)
Found replacement   %conv14.0 = call i32 @llvm.ssa.copy.i32(i32 %conv14) for   %conv14 = zext i8 %call to i32 in   %cmp22 = icmp eq i32 %conv14, 1
Rename Stack Top DFS numbers are (18,23)
Current DFS numbers are (18,23)
Rename Stack Top DFS numbers are (18,23)
Current DFS numbers are (19,20)
Marking Block Executable: entry
Marking Block Executable: entry
markOverdefined: ptr %agg.result
Marking Block Executable: entry
markOverdefined: ptr %out
Marking Block Executable: entry
markOverdefined: ptr %agg.result
Marking Block Executable: entry
markOverdefined: ptr %out
Marking Block Executable: entry
markOverdefined: ptr %agg.result
Marking Block Executable: entry
markOverdefined: ptr %out
Marking Block Executable: entry
Marking Block Executable: entry
markOverdefined: i8 %out
Marking Block Executable: entry
markOverdefined: ptr %agg.result
Marking Block Executable: entry
markOverdefined: ptr %0
Marking Block Executable: entry
markOverdefined: ptr %agg.result
Marking Block Executable: entry
markOverdefined: ptr %out

Popped off OI-WL: ptr %out

Popped off OI-WL: ptr %agg.result

Popped off OI-WL: ptr %0
Merged overdefined into   %out = load i128, ptr %0, align 8, !tbaa !8 : overdefined

Popped off OI-WL:   %out = load i128, ptr %0, align 8, !tbaa !8

Popped off OI-WL: ptr %agg.result

Popped off OI-WL: i8 %out

Popped off OI-WL: ptr %out

Popped off OI-WL: ptr %agg.result

Popped off OI-WL: ptr %out

Popped off OI-WL: ptr %agg.result

Popped off OI-WL: ptr %out

Popped off OI-WL: ptr %agg.result

Popped off BBWL: 
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 8)
  ret void


Popped off BBWL: 
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 8)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 8, i1 false), !tbaa.struct !8
  ret void

Merged overdefined into   %0 = call ptr @llvm.primate.input.p0.i32(i32 8) : overdefined

Popped off BBWL: 
entry:
  %out.addr = alloca i128, align 8
  %out = load i128, ptr %0, align 8, !tbaa !8
  store i128 %out, ptr %out.addr, align 8, !tbaa !8
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 16)
  ret void

SCCP: Don't know how to handle:   %out.addr = alloca i128, align 8
markOverdefined:   %out.addr = alloca i128, align 8

Popped off BBWL: 
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 16)
  %1 = load i128, ptr %0, align 8, !tbaa !8
  store i128 %1, ptr %agg.result, align 8, !tbaa !8
  ret void

Merged overdefined into   %0 = call ptr @llvm.primate.input.p0.i32(i32 16) : overdefined
Merged overdefined into   %1 = load i128, ptr %0, align 8, !tbaa !8 : overdefined

Popped off BBWL: 
entry:
  %out.addr = alloca i8, align 1
  store i8 %out, ptr %out.addr, align 1, !tbaa !8
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 1)
  ret void

SCCP: Don't know how to handle:   %out.addr = alloca i8, align 1
markOverdefined:   %out.addr = alloca i8, align 1

Popped off BBWL: 
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %1 = load i8, ptr %0, align 1, !tbaa !8
  ret i8 %1

Merged overdefined into   %0 = call ptr @llvm.primate.input.p0.i32(i32 1) : overdefined
Merged overdefined into   %1 = load i8, ptr %0, align 1, !tbaa !8 : overdefined

Popped off BBWL: 
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 32)
  ret void


Popped off BBWL: 
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 32)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 32, i1 false), !tbaa.struct !8
  ret void

Merged overdefined into   %0 = call ptr @llvm.primate.input.p0.i32(i32 32) : overdefined

Popped off BBWL: 
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 40)
  ret void


Popped off BBWL: 
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 40)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 40, i1 false), !tbaa.struct !8
  ret void

Merged overdefined into   %0 = call ptr @llvm.primate.input.p0.i32(i32 40) : overdefined

Popped off BBWL: 
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 24)
  ret void


Popped off BBWL: 
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 24, i1 false), !tbaa.struct !8
  ret void

Merged overdefined into   %0 = call ptr @llvm.primate.input.p0.i32(i32 24) : overdefined

Popped off BBWL: 
entry:
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %udp = alloca %struct.udp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %hdr_byte_left = alloca i32, align 4
  %n = alloca i32, align 4
  %kind = alloca i8, align 1
  %tcp_option = alloca i8, align 1
  %i = alloca i32, align 4
  %padding = alloca i128, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %tcp_option24 = alloca i8, align 1
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.start.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr %ref.tmp) #1
  call void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind writable sret(%struct.ethernet_t) align 8 %ref.tmp), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %eth, ptr align 8 %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp, ptr align 8 %eth, i32 24, i1 false), !tbaa.struct !8
  call void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %agg.tmp), !primate !7
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %0 = load i16, ptr %etherType, align 8, !tbaa !15
  %conv = zext i16 %0 to i32
  %cmp = icmp eq i32 %conv, 2048
  br i1 %cmp, label %if.then, label %if.end38

SCCP: Don't know how to handle:   %eth = alloca %struct.ethernet_t, align 8
markOverdefined:   %eth = alloca %struct.ethernet_t, align 8
SCCP: Don't know how to handle:   %ipv4 = alloca %struct.ipv4_t, align 8
markOverdefined:   %ipv4 = alloca %struct.ipv4_t, align 8
SCCP: Don't know how to handle:   %tcp = alloca %struct.tcp_t, align 8
markOverdefined:   %tcp = alloca %struct.tcp_t, align 8
SCCP: Don't know how to handle:   %udp = alloca %struct.udp_t, align 8
markOverdefined:   %udp = alloca %struct.udp_t, align 8
SCCP: Don't know how to handle:   %ref.tmp = alloca %struct.ethernet_t, align 8
markOverdefined:   %ref.tmp = alloca %struct.ethernet_t, align 8
SCCP: Don't know how to handle:   %agg.tmp = alloca %struct.ethernet_t, align 8
markOverdefined:   %agg.tmp = alloca %struct.ethernet_t, align 8
SCCP: Don't know how to handle:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
markOverdefined:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
SCCP: Don't know how to handle:   %agg.tmp2 = alloca %struct.ipv4_t, align 8
markOverdefined:   %agg.tmp2 = alloca %struct.ipv4_t, align 8
SCCP: Don't know how to handle:   %ref.tmp6 = alloca %struct.tcp_t, align 8
markOverdefined:   %ref.tmp6 = alloca %struct.tcp_t, align 8
SCCP: Don't know how to handle:   %agg.tmp7 = alloca %struct.tcp_t, align 8
markOverdefined:   %agg.tmp7 = alloca %struct.tcp_t, align 8
SCCP: Don't know how to handle:   %hdr_byte_left = alloca i32, align 4
markOverdefined:   %hdr_byte_left = alloca i32, align 4
SCCP: Don't know how to handle:   %n = alloca i32, align 4
markOverdefined:   %n = alloca i32, align 4
SCCP: Don't know how to handle:   %kind = alloca i8, align 1
markOverdefined:   %kind = alloca i8, align 1
SCCP: Don't know how to handle:   %tcp_option = alloca i8, align 1
markOverdefined:   %tcp_option = alloca i8, align 1
SCCP: Don't know how to handle:   %i = alloca i32, align 4
markOverdefined:   %i = alloca i32, align 4
SCCP: Don't know how to handle:   %padding = alloca i128, align 8
markOverdefined:   %padding = alloca i128, align 8
SCCP: Don't know how to handle:   %tmp = alloca i128, align 8
markOverdefined:   %tmp = alloca i128, align 8
SCCP: Don't know how to handle:   %indirect-arg-temp = alloca i128, align 8
markOverdefined:   %indirect-arg-temp = alloca i128, align 8
SCCP: Don't know how to handle:   %cleanup.dest.slot = alloca i32, align 4
markOverdefined:   %cleanup.dest.slot = alloca i32, align 4
SCCP: Don't know how to handle:   %tcp_option24 = alloca i8, align 1
markOverdefined:   %tcp_option24 = alloca i8, align 1
SCCP: Don't know how to handle:   %ref.tmp34 = alloca %struct.udp_t, align 8
markOverdefined:   %ref.tmp34 = alloca %struct.udp_t, align 8
SCCP: Don't know how to handle:   %agg.tmp35 = alloca %struct.udp_t, align 8
markOverdefined:   %agg.tmp35 = alloca %struct.udp_t, align 8
markOverdefined:   %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
Merged overdefined into   %0 = load i16, ptr %etherType, align 8, !tbaa !15 : overdefined
Merged constantrange<0, 65536> into   %conv = zext i16 %0 to i32 : constantrange<0, 65536>
markOverdefined:   %cmp = icmp eq i32 %conv, 2048
Marking Block Executable: if.then
Marking Block Executable: if.end38

Popped off BBWL: 
if.end38:                                         ; preds = %while.end27, %if.then5, %if.then33, %if.else29, %entry
  call void @_ZN7PRIMATE10input_doneEv(), !primate !7
  call void @llvm.lifetime.end.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.end.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr %eth) #1
  ret void


Popped off BBWL: 
if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr %ref.tmp1) #1
  call void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind writable sret(%struct.ipv4_t) align 8 %ref.tmp1), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %ipv4, ptr align 8 %ref.tmp1, i32 40, i1 false), !tbaa.struct !17
  call void @llvm.lifetime.end.p0(i64 40, ptr %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp2, ptr align 8 %ipv4, i32 40, i1 false), !tbaa.struct !17
  call void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %agg.tmp2), !primate !7
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %1 = load i8, ptr %protocol, align 8, !tbaa !24
  %conv3 = zext i8 %1 to i32
  %cmp4 = icmp eq i32 %conv3, 6
  %conv3.0 = call i32 @llvm.ssa.copy.i32(i32 %conv3)
  br i1 %cmp4, label %if.then5, label %if.else29

markOverdefined:   %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
Merged overdefined into   %1 = load i8, ptr %protocol, align 8, !tbaa !24 : overdefined
Merged constantrange<0, 256> into   %conv3 = zext i8 %1 to i32 : constantrange<0, 256>
markOverdefined:   %cmp4 = icmp eq i32 %conv3, 6
Merged constantrange<0, 256> into   %conv3.0 = call i32 @llvm.ssa.copy.i32(i32 %conv3) : constantrange<0, 256>
Marking Block Executable: if.then5
Marking Block Executable: if.else29

Popped off BBWL: 
if.else29:                                        ; preds = %if.then
  %cmp32 = icmp eq i32 %conv3.0, 17
  br i1 %cmp32, label %if.then33, label %if.end38

markOverdefined:   %cmp32 = icmp eq i32 %conv3.0, 17
Marking Block Executable: if.then33
Marking Edge Executable: if.else29 -> if.end38

Popped off BBWL: 
if.then33:                                        ; preds = %if.else29
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp34) #1
  call void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind writable sret(%struct.udp_t) align 8 %ref.tmp34), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %udp, ptr align 8 %ref.tmp34, i32 8, i1 false), !tbaa.struct !42
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp34) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp35, ptr align 8 %udp, i32 8, i1 false), !tbaa.struct !42
  call void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %agg.tmp35), !primate !7
  br label %if.end38

Marking Edge Executable: if.then33 -> if.end38

Popped off BBWL: 
if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr %ref.tmp6) #1
  call void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind writable sret(%struct.tcp_t) align 8 %ref.tmp6), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %tcp, ptr align 8 %ref.tmp6, i32 32, i1 false), !tbaa.struct !26
  call void @llvm.lifetime.end.p0(i64 32, ptr %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp7, ptr align 8 %tcp, i32 32, i1 false), !tbaa.struct !26
  call void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %agg.tmp7), !primate !7
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %2 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv8 = sext i4 %2 to i32
  %cmp9 = icmp sgt i32 %conv8, 0
  br i1 %cmp9, label %if.then10, label %if.end38

markOverdefined:   %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
Merged overdefined into   %2 = load i4, ptr %dataOffset, align 8, !tbaa !33 : overdefined
Merged constantrange<-8, 8> into   %conv8 = sext i4 %2 to i32 : constantrange<-8, 8>
markOverdefined:   %cmp9 = icmp sgt i32 %conv8, 0
Marking Block Executable: if.then10
Marking Edge Executable: if.then5 -> if.end38

Popped off BBWL: 
if.then10:                                        ; preds = %if.then5
  call void @llvm.lifetime.start.p0(i64 4, ptr %hdr_byte_left) #1
  %3 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv12 = sext i4 %3 to i32
  %sub = sub i32 %conv12, 5
  %mul = mul i32 4, %sub
  store i32 %mul, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 4, ptr %n) #1
  store i32 0, ptr %n, align 4, !tbaa !35
  br label %while.cond

Merged overdefined into   %3 = load i4, ptr %dataOffset, align 8, !tbaa !33 : overdefined
Merged constantrange<-8, 8> into   %conv12 = sext i4 %3 to i32 : constantrange<-8, 8>
Merged constantrange<-13, 3> into   %sub = sub i32 %conv12, 5 : constantrange<-13, 3>
Merged constantrange<-52, 9> into   %mul = mul i32 4, %sub : constantrange<-52, 9>
Marking Block Executable: while.cond

Popped off BBWL: 
while.cond:                                       ; preds = %cleanup, %if.then10
  %4 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp13 = icmp sgt i32 %4, 0
  br i1 %cmp13, label %while.body, label %while.end27

Merged overdefined into   %4 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35 : overdefined
markOverdefined:   %cmp13 = icmp sgt i32 %4, 0
Marking Block Executable: while.body
Marking Block Executable: while.end27

Popped off BBWL: 
while.end27:                                      ; preds = %cleanup, %while.cond
  call void @llvm.lifetime.end.p0(i64 4, ptr %n) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %hdr_byte_left) #1
  br label %if.end38

Marking Edge Executable: while.end27 -> if.end38

Popped off BBWL: 
while.body:                                       ; preds = %while.cond
  call void @llvm.lifetime.start.p0(i64 1, ptr %kind) #1
  %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
  store i8 %call, ptr %kind, align 1, !tbaa !20
  %conv14 = zext i8 %call to i32
  %cmp15 = icmp eq i32 %conv14, 0
  %conv14.0 = call i32 @llvm.ssa.copy.i32(i32 %conv14)
  br i1 %cmp15, label %if.then16, label %if.else

Merged overdefined into   %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7 : overdefined
Merged constantrange<0, 256> into   %conv14 = zext i8 %call to i32 : constantrange<0, 256>
markOverdefined:   %cmp15 = icmp eq i32 %conv14, 0
Merged constantrange<1, 256> into   %conv14.0 = call i32 @llvm.ssa.copy.i32(i32 %conv14) : constantrange<1, 256>
Marking Block Executable: if.then16
Marking Block Executable: if.else

Popped off BBWL: 
if.else:                                          ; preds = %while.body
  %cmp22 = icmp eq i32 %conv14.0, 1
  br i1 %cmp22, label %if.then23, label %if.end26

markOverdefined:   %cmp22 = icmp eq i32 %conv14.0, 1
Marking Block Executable: if.then23
Marking Block Executable: if.end26

Popped off BBWL: 
if.end26:                                         ; preds = %if.else, %if.then23
  %13 = load i32, ptr %n, align 4, !tbaa !35
  %inc = add nsw i32 %13, 1
  store i32 %inc, ptr %n, align 4, !tbaa !35
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

Merged overdefined into   %13 = load i32, ptr %n, align 4, !tbaa !35 : overdefined
Merged overdefined into   %inc = add nsw i32 %13, 1 : overdefined
Marking Block Executable: cleanup

Popped off BBWL: 
cleanup:                                          ; preds = %if.end26, %while.end
  call void @llvm.lifetime.end.p0(i64 1, ptr %kind) #1
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %while.cond
    i32 3, label %while.end27
  ], !llvm.loop !41

Merged overdefined into   %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4 : overdefined
Marking Block Executable: unreachable
Marking Edge Executable: cleanup -> while.cond
Marking Edge Executable: cleanup -> while.end27

Popped off BBWL: 
unreachable:                                      ; preds = %cleanup
  unreachable


Popped off BBWL: 
if.then23:                                        ; preds = %if.else
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option24) #1
  %10 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %10, ptr %tcp_option24, align 1, !tbaa !20
  %11 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec25 = add nsw i32 %11, -1
  store i32 %dec25, ptr %hdr_byte_left, align 4, !tbaa !35
  %12 = load i8, ptr %tcp_option24, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %12), !primate !7
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option24) #1
  br label %if.end26

Merged overdefined into   %10 = load i8, ptr %kind, align 1, !tbaa !20 : overdefined
Merged overdefined into   %11 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35 : overdefined
Merged overdefined into   %dec25 = add nsw i32 %11, -1 : overdefined
Merged overdefined into   %12 = load i8, ptr %tcp_option24, align 1, !tbaa !20 : overdefined
Marking Edge Executable: if.then23 -> if.end26

Popped off BBWL: 
if.then16:                                        ; preds = %while.body
  %5 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec = add nsw i32 %5, -1
  store i32 %dec, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option) #1
  %6 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %6, ptr %tcp_option, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %6), !primate !7
  call void @llvm.lifetime.start.p0(i64 4, ptr %i) #1
  store i32 0, ptr %i, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 16, ptr %padding) #1
  br label %while.cond17

Merged overdefined into   %5 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35 : overdefined
Merged overdefined into   %dec = add nsw i32 %5, -1 : overdefined
Merged overdefined into   %6 = load i8, ptr %kind, align 1, !tbaa !20 : overdefined
Marking Block Executable: while.cond17

Popped off BBWL: 
while.cond17:                                     ; preds = %while.body19, %if.then16
  %7 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp18 = icmp sgt i32 %7, 0
  br i1 %cmp18, label %while.body19, label %while.end

Merged overdefined into   %7 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35 : overdefined
markOverdefined:   %cmp18 = icmp sgt i32 %7, 0
Marking Block Executable: while.body19
Marking Block Executable: while.end

Popped off BBWL: 
while.end:                                        ; preds = %while.cond17
  store i32 3, ptr %cleanup.dest.slot, align 4
  call void @llvm.lifetime.end.p0(i64 16, ptr %padding) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %i) #1
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option) #1
  br label %cleanup

Marking Edge Executable: while.end -> cleanup

Popped off BBWL: 
while.body19:                                     ; preds = %while.cond17
  call void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind writable sret(i128) align 8 %tmp), !primate !7
  %8 = load i128, ptr %tmp, align 8, !tbaa !37
  store i128 %8, ptr %padding, align 8, !tbaa !37
  store i128 %8, ptr %indirect-arg-temp, align 8, !tbaa !37
  call void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %indirect-arg-temp), !primate !7
  %9 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %sub20 = sub nsw i32 %9, 16
  store i32 %sub20, ptr %hdr_byte_left, align 4, !tbaa !35
  br label %while.cond17, !llvm.loop !39

Merged overdefined into   %8 = load i128, ptr %tmp, align 8, !tbaa !37 : overdefined
Merged overdefined into   %9 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35 : overdefined
Merged overdefined into   %sub20 = sub nsw i32 %9, 16 : overdefined
Marking Edge Executable: while.body19 -> while.cond17

Popped off BBWL: 
entry:
  call void @llvm.primate.output.done()
  ret void


Popped off BBWL: 
entry:
  call void @llvm.primate.input.done()
  ret void


Popped off OI-WL:   %sub20 = sub nsw i32 %9, 16

Popped off OI-WL:   %9 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35

Popped off OI-WL:   %8 = load i128, ptr %tmp, align 8, !tbaa !37

Popped off OI-WL:   %cmp18 = icmp sgt i32 %7, 0

Popped off OI-WL:   %7 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35

Popped off OI-WL:   %6 = load i8, ptr %kind, align 1, !tbaa !20

Popped off OI-WL:   %dec = add nsw i32 %5, -1

Popped off OI-WL:   %5 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35

Popped off OI-WL:   %12 = load i8, ptr %tcp_option24, align 1, !tbaa !20

Popped off OI-WL:   %dec25 = add nsw i32 %11, -1

Popped off OI-WL:   %11 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35

Popped off OI-WL:   %10 = load i8, ptr %kind, align 1, !tbaa !20

Popped off OI-WL:   %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4

Popped off OI-WL:   %inc = add nsw i32 %13, 1

Popped off OI-WL:   %13 = load i32, ptr %n, align 4, !tbaa !35

Popped off OI-WL:   %cmp22 = icmp eq i32 %conv14.0, 1

Popped off OI-WL:   %cmp15 = icmp eq i32 %conv14, 0

Popped off OI-WL:   %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7

Popped off OI-WL:   %cmp13 = icmp sgt i32 %4, 0

Popped off OI-WL:   %4 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35

Popped off OI-WL:   %3 = load i4, ptr %dataOffset, align 8, !tbaa !33

Popped off OI-WL:   %cmp9 = icmp sgt i32 %conv8, 0

Popped off OI-WL:   %2 = load i4, ptr %dataOffset, align 8, !tbaa !33

Popped off OI-WL:   %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1

Popped off OI-WL:   %cmp32 = icmp eq i32 %conv3.0, 17

Popped off OI-WL:   %cmp4 = icmp eq i32 %conv3, 6

Popped off OI-WL:   %1 = load i8, ptr %protocol, align 8, !tbaa !24

Popped off OI-WL:   %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1

Popped off OI-WL:   %cmp = icmp eq i32 %conv, 2048

Popped off OI-WL:   %0 = load i16, ptr %etherType, align 8, !tbaa !15

Popped off OI-WL:   %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2

Popped off OI-WL:   %agg.tmp35 = alloca %struct.udp_t, align 8

Popped off OI-WL:   %ref.tmp34 = alloca %struct.udp_t, align 8

Popped off OI-WL:   %tcp_option24 = alloca i8, align 1

Popped off OI-WL:   %cleanup.dest.slot = alloca i32, align 4

Popped off OI-WL:   %indirect-arg-temp = alloca i128, align 8

Popped off OI-WL:   %tmp = alloca i128, align 8

Popped off OI-WL:   %padding = alloca i128, align 8

Popped off OI-WL:   %i = alloca i32, align 4

Popped off OI-WL:   %tcp_option = alloca i8, align 1

Popped off OI-WL:   %kind = alloca i8, align 1

Popped off OI-WL:   %n = alloca i32, align 4

Popped off OI-WL:   %hdr_byte_left = alloca i32, align 4

Popped off OI-WL:   %agg.tmp7 = alloca %struct.tcp_t, align 8

Popped off OI-WL:   %ref.tmp6 = alloca %struct.tcp_t, align 8

Popped off OI-WL:   %agg.tmp2 = alloca %struct.ipv4_t, align 8

Popped off OI-WL:   %ref.tmp1 = alloca %struct.ipv4_t, align 8

Popped off OI-WL:   %agg.tmp = alloca %struct.ethernet_t, align 8

Popped off OI-WL:   %ref.tmp = alloca %struct.ethernet_t, align 8

Popped off OI-WL:   %udp = alloca %struct.udp_t, align 8

Popped off OI-WL:   %tcp = alloca %struct.tcp_t, align 8

Popped off OI-WL:   %ipv4 = alloca %struct.ipv4_t, align 8

Popped off OI-WL:   %eth = alloca %struct.ethernet_t, align 8

Popped off OI-WL:   %0 = call ptr @llvm.primate.input.p0.i32(i32 24)

Popped off OI-WL:   %0 = call ptr @llvm.primate.input.p0.i32(i32 40)

Popped off OI-WL:   %0 = call ptr @llvm.primate.input.p0.i32(i32 32)

Popped off OI-WL:   %1 = load i8, ptr %0, align 1, !tbaa !8

Popped off OI-WL:   %0 = call ptr @llvm.primate.input.p0.i32(i32 1)

Popped off OI-WL:   %out.addr = alloca i8, align 1

Popped off OI-WL:   %1 = load i128, ptr %0, align 8, !tbaa !8

Popped off OI-WL:   %0 = call ptr @llvm.primate.input.p0.i32(i32 16)

Popped off OI-WL:   %out.addr = alloca i128, align 8

Popped off OI-WL:   %0 = call ptr @llvm.primate.input.p0.i32(i32 8)

Popped off I-WL:   %conv14.0 = call i32 @llvm.ssa.copy.i32(i32 %conv14)

Popped off I-WL:   %conv14 = zext i8 %call to i32

Popped off I-WL:   %mul = mul i32 4, %sub

Popped off I-WL:   %sub = sub i32 %conv12, 5

Popped off I-WL:   %conv12 = sext i4 %3 to i32

Popped off I-WL:   %conv8 = sext i4 %2 to i32

Popped off I-WL:   %conv3.0 = call i32 @llvm.ssa.copy.i32(i32 %conv3)

Popped off I-WL:   %conv3 = zext i8 %1 to i32

Popped off I-WL:   %conv = zext i16 %0 to i32
FnSpecialization: No possible specializations found in module
; *** IR Dump After IPSCCPPass on [module] ***
; ModuleID = 'tcp_parse.cpp'
source_filename = "tcp_parse.cpp"
target datalayout = "e-G1-m:e-p:32:32-i64:64-n32-S128"
target triple = "primate32-unknown-linux-gnu"

%struct.ethernet_t = type { i48, i48, i16 }
%struct.ipv4_t = type { i72, i8, i80 }
%struct.tcp_t = type { i96, i4, i60 }
%struct.udp_t = type { i64 }

$_ZN7PRIMATE5inputI10ethernet_tEET_v = comdat any

$_ZN7PRIMATE6outputI10ethernet_tEEvT_ = comdat any

$_ZN7PRIMATE5inputI6ipv4_tEET_v = comdat any

$_ZN7PRIMATE6outputI6ipv4_tEEvT_ = comdat any

$_ZN7PRIMATE5inputI5tcp_tEET_v = comdat any

$_ZN7PRIMATE6outputI5tcp_tEEvT_ = comdat any

$_ZN7PRIMATE5inputIDU8_EET_v = comdat any

$_ZN7PRIMATE6outputIDU8_EEvT_ = comdat any

$_ZN7PRIMATE5inputIDU128_EET_v = comdat any

$_ZN7PRIMATE6outputIDU128_EEvT_ = comdat any

$_ZN7PRIMATE5inputI5udp_tEET_v = comdat any

$_ZN7PRIMATE6outputI5udp_tEEvT_ = comdat any

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.done() #1

; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() #2 {
entry:
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %udp = alloca %struct.udp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %hdr_byte_left = alloca i32, align 4
  %n = alloca i32, align 4
  %kind = alloca i8, align 1
  %tcp_option = alloca i8, align 1
  %i = alloca i32, align 4
  %padding = alloca i128, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %tcp_option24 = alloca i8, align 1
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.start.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr %ref.tmp) #1
  call void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind writable sret(%struct.ethernet_t) align 8 %ref.tmp), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %eth, ptr align 8 %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp, ptr align 8 %eth, i32 24, i1 false), !tbaa.struct !8
  call void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %agg.tmp), !primate !7
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %0 = load i16, ptr %etherType, align 8, !tbaa !15
  %conv = zext i16 %0 to i32
  %cmp = icmp eq i32 %conv, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr %ref.tmp1) #1
  call void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind writable sret(%struct.ipv4_t) align 8 %ref.tmp1), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %ipv4, ptr align 8 %ref.tmp1, i32 40, i1 false), !tbaa.struct !17
  call void @llvm.lifetime.end.p0(i64 40, ptr %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp2, ptr align 8 %ipv4, i32 40, i1 false), !tbaa.struct !17
  call void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %agg.tmp2), !primate !7
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %1 = load i8, ptr %protocol, align 8, !tbaa !24
  %conv3 = zext i8 %1 to i32
  %cmp4 = icmp eq i32 %conv3, 6
  br i1 %cmp4, label %if.then5, label %if.else29

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr %ref.tmp6) #1
  call void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind writable sret(%struct.tcp_t) align 8 %ref.tmp6), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %tcp, ptr align 8 %ref.tmp6, i32 32, i1 false), !tbaa.struct !26
  call void @llvm.lifetime.end.p0(i64 32, ptr %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp7, ptr align 8 %tcp, i32 32, i1 false), !tbaa.struct !26
  call void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %agg.tmp7), !primate !7
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %2 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv8 = sext i4 %2 to i32
  %cmp9 = icmp sgt i32 %conv8, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  call void @llvm.lifetime.start.p0(i64 4, ptr %hdr_byte_left) #1
  %3 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv12 = sext i4 %3 to i32
  %sub = sub nsw i32 %conv12, 5
  %mul = mul nsw i32 4, %sub
  store i32 %mul, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 4, ptr %n) #1
  store i32 0, ptr %n, align 4, !tbaa !35
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %4 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp13 = icmp sgt i32 %4, 0
  br i1 %cmp13, label %while.body, label %while.end27

while.body:                                       ; preds = %while.cond
  call void @llvm.lifetime.start.p0(i64 1, ptr %kind) #1
  %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
  store i8 %call, ptr %kind, align 1, !tbaa !20
  %conv14 = zext i8 %call to i32
  %cmp15 = icmp eq i32 %conv14, 0
  br i1 %cmp15, label %if.then16, label %if.else

if.then16:                                        ; preds = %while.body
  %5 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec = add nsw i32 %5, -1
  store i32 %dec, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option) #1
  %6 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %6, ptr %tcp_option, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %6), !primate !7
  call void @llvm.lifetime.start.p0(i64 4, ptr %i) #1
  store i32 0, ptr %i, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 16, ptr %padding) #1
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %7 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp18 = icmp sgt i32 %7, 0
  br i1 %cmp18, label %while.body19, label %while.end

while.body19:                                     ; preds = %while.cond17
  call void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind writable sret(i128) align 8 %tmp), !primate !7
  %8 = load i128, ptr %tmp, align 8, !tbaa !37
  store i128 %8, ptr %padding, align 8, !tbaa !37
  store i128 %8, ptr %indirect-arg-temp, align 8, !tbaa !37
  call void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %indirect-arg-temp), !primate !7
  %9 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %sub20 = sub nsw i32 %9, 16
  store i32 %sub20, ptr %hdr_byte_left, align 4, !tbaa !35
  br label %while.cond17, !llvm.loop !39

while.end:                                        ; preds = %while.cond17
  store i32 3, ptr %cleanup.dest.slot, align 4
  call void @llvm.lifetime.end.p0(i64 16, ptr %padding) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %i) #1
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option) #1
  br label %cleanup

if.else:                                          ; preds = %while.body
  %cmp22 = icmp eq i32 %conv14, 1
  br i1 %cmp22, label %if.then23, label %if.end26

if.then23:                                        ; preds = %if.else
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option24) #1
  %10 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %10, ptr %tcp_option24, align 1, !tbaa !20
  %11 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec25 = add nsw i32 %11, -1
  store i32 %dec25, ptr %hdr_byte_left, align 4, !tbaa !35
  %12 = load i8, ptr %tcp_option24, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %12), !primate !7
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option24) #1
  br label %if.end26

if.end26:                                         ; preds = %if.else, %if.then23
  %13 = load i32, ptr %n, align 4, !tbaa !35
  %inc = add nsw i32 %13, 1
  store i32 %inc, ptr %n, align 4, !tbaa !35
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end26, %while.end
  call void @llvm.lifetime.end.p0(i64 1, ptr %kind) #1
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %while.cond
    i32 3, label %while.end27
  ], !llvm.loop !41

while.end27:                                      ; preds = %cleanup, %while.cond
  call void @llvm.lifetime.end.p0(i64 4, ptr %n) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %hdr_byte_left) #1
  br label %if.end38

if.else29:                                        ; preds = %if.then
  %cmp32 = icmp eq i32 %conv3, 17
  br i1 %cmp32, label %if.then33, label %if.end38

if.then33:                                        ; preds = %if.else29
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp34) #1
  call void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind writable sret(%struct.udp_t) align 8 %ref.tmp34), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %udp, ptr align 8 %ref.tmp34, i32 8, i1 false), !tbaa.struct !42
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp34) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp35, ptr align 8 %udp, i32 8, i1 false), !tbaa.struct !42
  call void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %agg.tmp35), !primate !7
  br label %if.end38

if.end38:                                         ; preds = %while.end27, %if.then5, %if.then33, %if.else29, %entry
  call void @_ZN7PRIMATE10input_doneEv(), !primate !7
  call void @llvm.lifetime.end.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.end.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr %eth) #1
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ethernet_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 24, i1 false), !tbaa.struct !8
  ret void
}

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i32(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i32, i1 immarg) #4

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 24)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ipv4_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 40)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 40, i1 false), !tbaa.struct !17
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 40)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.tcp_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 32)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 32, i1 false), !tbaa.struct !26
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 32)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v() #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %1 = load i8, ptr %0, align 1, !tbaa !20
  ret i8 %1
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %out) #0 comdat !primate !7 {
entry:
  %out.addr = alloca i8, align 1
  store i8 %out, ptr %out.addr, align 1, !tbaa !20
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 1)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind noalias writable sret(i128) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 16)
  %1 = load i128, ptr %0, align 8, !tbaa !37
  store i128 %1, ptr %agg.result, align 8, !tbaa !37
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %0) #0 comdat !primate !7 {
entry:
  %out.addr = alloca i128, align 8
  %out = load i128, ptr %0, align 8, !tbaa !37
  store i128 %out, ptr %out.addr, align 8, !tbaa !37
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 16)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.udp_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 8)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 8, i1 false), !tbaa.struct !42
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 8)
  ret void
}

; Function Attrs: nounwind
declare !primate !7 ptr @llvm.primate.input.p0.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.p0.i32(ptr, i32) #1

attributes #0 = { alwaysinline mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #1 = { nounwind }
attributes #2 = { mustprogress "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #3 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5}
!llvm.ident = !{!6}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"ilp32"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{i32 8, !"SmallDataLimit", i32 8}
!6 = !{!"clang version 18.1.8 (git@github.com:FAST-Research-Group/primate-arch-gen.git e8582d4315ec2267abfc97212fa19f342d0812e8)"}
!7 = !{!"blue", !"IO", i64 1, i64 1}
!8 = !{i64 0, i64 8, !9, i64 8, i64 8, !9, i64 16, i64 2, !13}
!9 = !{!10, !10, i64 0}
!10 = !{!"_BitInt(48)", !11, i64 0}
!11 = !{!"omnipotent char", !12, i64 0}
!12 = !{!"Simple C++ TBAA"}
!13 = !{!14, !14, i64 0}
!14 = !{!"_BitInt(16)", !11, i64 0}
!15 = !{!16, !14, i64 16}
!16 = !{!"_ZTS10ethernet_t", !10, i64 0, !10, i64 8, !14, i64 16}
!17 = !{i64 0, i64 16, !18, i64 16, i64 1, !20, i64 24, i64 16, !22}
!18 = !{!19, !19, i64 0}
!19 = !{!"_BitInt(72)", !11, i64 0}
!20 = !{!21, !21, i64 0}
!21 = !{!"_BitInt(8)", !11, i64 0}
!22 = !{!23, !23, i64 0}
!23 = !{!"_BitInt(80)", !11, i64 0}
!24 = !{!25, !21, i64 16}
!25 = !{!"_ZTS6ipv4_t", !19, i64 0, !21, i64 16, !23, i64 24}
!26 = !{i64 0, i64 16, !27, i64 16, i64 1, !29, i64 24, i64 8, !31}
!27 = !{!28, !28, i64 0}
!28 = !{!"_BitInt(96)", !11, i64 0}
!29 = !{!30, !30, i64 0}
!30 = !{!"_BitInt(4)", !11, i64 0}
!31 = !{!32, !32, i64 0}
!32 = !{!"_BitInt(60)", !11, i64 0}
!33 = !{!34, !30, i64 16}
!34 = !{!"_ZTS5tcp_t", !28, i64 0, !30, i64 16, !32, i64 24}
!35 = !{!36, !36, i64 0}
!36 = !{!"int", !11, i64 0}
!37 = !{!38, !38, i64 0}
!38 = !{!"_BitInt(128)", !11, i64 0}
!39 = distinct !{!39, !40}
!40 = !{!"llvm.loop.mustprogress"}
!41 = distinct !{!41, !40}
!42 = !{i64 0, i64 8, !43}
!43 = !{!44, !44, i64 0}
!44 = !{!"_BitInt(64)", !11, i64 0}
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry
Marking Block Executable: entry

Popped off BBWL: 
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 8)
  ret void

Popped off BBWL: 
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 8)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 8, i1 false), !tbaa.struct !8
  ret void

Popped off BBWL: 
entry:
  %out.addr = alloca i128, align 8
  %out = load i128, ptr %0, align 8, !tbaa !8
  store i128 %out, ptr %out.addr, align 8, !tbaa !8
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 16)
  ret void

Popped off BBWL: 
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 16)
  %1 = load i128, ptr %0, align 8, !tbaa !8
  store i128 %1, ptr %agg.result, align 8, !tbaa !8
  ret void

Popped off BBWL: 
entry:
  %out.addr = alloca i8, align 1
  store i8 %out, ptr %out.addr, align 1, !tbaa !8
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 1)
  ret void

Popped off BBWL: 
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %1 = load i8, ptr %0, align 1, !tbaa !8
  ret i8 %1

Popped off BBWL: 
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 32)
  ret void

Popped off BBWL: 
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 32)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 32, i1 false), !tbaa.struct !8
  ret void

Popped off BBWL: 
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 40)
  ret void

Popped off BBWL: 
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 40)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 40, i1 false), !tbaa.struct !8
  ret void

Popped off BBWL: 
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 24)
  ret void

Popped off BBWL: 
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 24, i1 false), !tbaa.struct !8
  ret void

Popped off BBWL: 
entry:
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %udp = alloca %struct.udp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %hdr_byte_left = alloca i32, align 4
  %n = alloca i32, align 4
  %kind = alloca i8, align 1
  %tcp_option = alloca i8, align 1
  %i = alloca i32, align 4
  %padding = alloca i128, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %tcp_option24 = alloca i8, align 1
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.start.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr %ref.tmp) #1
  call void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind writable sret(%struct.ethernet_t) align 8 %ref.tmp), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %eth, ptr align 8 %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp, ptr align 8 %eth, i32 24, i1 false), !tbaa.struct !8
  call void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %agg.tmp), !primate !7
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %0 = load i16, ptr %etherType, align 8, !tbaa !15
  %conv = zext i16 %0 to i32
  %cmp = icmp eq i32 %conv, 2048
  br i1 %cmp, label %if.then, label %if.end38
Marking Edge Executable: entry -> if.then
Marking Block Executable: if.then
Marking Edge Executable: entry -> if.end38
Marking Block Executable: if.end38

Popped off BBWL: 
if.end38:                                         ; preds = %while.end27, %if.then5, %if.then33, %if.else29, %entry
  call void @_ZN7PRIMATE10input_doneEv(), !primate !7
  call void @llvm.lifetime.end.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.end.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr %eth) #1
  ret void

Popped off BBWL: 
if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr %ref.tmp1) #1
  call void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind writable sret(%struct.ipv4_t) align 8 %ref.tmp1), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %ipv4, ptr align 8 %ref.tmp1, i32 40, i1 false), !tbaa.struct !17
  call void @llvm.lifetime.end.p0(i64 40, ptr %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp2, ptr align 8 %ipv4, i32 40, i1 false), !tbaa.struct !17
  call void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %agg.tmp2), !primate !7
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %1 = load i8, ptr %protocol, align 8, !tbaa !24
  %conv3 = zext i8 %1 to i32
  %cmp4 = icmp eq i32 %conv3, 6
  br i1 %cmp4, label %if.then5, label %if.else29
Marking Edge Executable: if.then -> if.then5
Marking Block Executable: if.then5
Marking Edge Executable: if.then -> if.else29
Marking Block Executable: if.else29

Popped off BBWL: 
if.else29:                                        ; preds = %if.then
  %cmp32 = icmp eq i32 %conv3, 17
  br i1 %cmp32, label %if.then33, label %if.end38
Marking Edge Executable: if.else29 -> if.then33
Marking Block Executable: if.then33
Marking Edge Executable: if.else29 -> if.end38

Popped off BBWL: 
if.then33:                                        ; preds = %if.else29
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp34) #1
  call void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind writable sret(%struct.udp_t) align 8 %ref.tmp34), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %udp, ptr align 8 %ref.tmp34, i32 8, i1 false), !tbaa.struct !42
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp34) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp35, ptr align 8 %udp, i32 8, i1 false), !tbaa.struct !42
  call void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %agg.tmp35), !primate !7
  br label %if.end38
Marking Edge Executable: if.then33 -> if.end38

Popped off BBWL: 
if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr %ref.tmp6) #1
  call void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind writable sret(%struct.tcp_t) align 8 %ref.tmp6), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %tcp, ptr align 8 %ref.tmp6, i32 32, i1 false), !tbaa.struct !26
  call void @llvm.lifetime.end.p0(i64 32, ptr %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp7, ptr align 8 %tcp, i32 32, i1 false), !tbaa.struct !26
  call void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %agg.tmp7), !primate !7
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %2 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv8 = sext i4 %2 to i32
  %cmp9 = icmp sgt i32 %conv8, 0
  br i1 %cmp9, label %if.then10, label %if.end38
Marking Edge Executable: if.then5 -> if.then10
Marking Block Executable: if.then10
Marking Edge Executable: if.then5 -> if.end38

Popped off BBWL: 
if.then10:                                        ; preds = %if.then5
  call void @llvm.lifetime.start.p0(i64 4, ptr %hdr_byte_left) #1
  %3 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv12 = sext i4 %3 to i32
  %sub = sub nsw i32 %conv12, 5
  %mul = mul nsw i32 4, %sub
  store i32 %mul, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 4, ptr %n) #1
  store i32 0, ptr %n, align 4, !tbaa !35
  br label %while.cond
Marking Edge Executable: if.then10 -> while.cond
Marking Block Executable: while.cond

Popped off BBWL: 
while.cond:                                       ; preds = %cleanup, %if.then10
  %4 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp13 = icmp sgt i32 %4, 0
  br i1 %cmp13, label %while.body, label %while.end27
Marking Edge Executable: while.cond -> while.body
Marking Block Executable: while.body
Marking Edge Executable: while.cond -> while.end27
Marking Block Executable: while.end27

Popped off BBWL: 
while.end27:                                      ; preds = %cleanup, %while.cond
  call void @llvm.lifetime.end.p0(i64 4, ptr %n) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %hdr_byte_left) #1
  br label %if.end38
Marking Edge Executable: while.end27 -> if.end38

Popped off BBWL: 
while.body:                                       ; preds = %while.cond
  call void @llvm.lifetime.start.p0(i64 1, ptr %kind) #1
  %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
  store i8 %call, ptr %kind, align 1, !tbaa !20
  %conv14 = zext i8 %call to i32
  %cmp15 = icmp eq i32 %conv14, 0
  br i1 %cmp15, label %if.then16, label %if.else
Marking Edge Executable: while.body -> if.then16
Marking Block Executable: if.then16
Marking Edge Executable: while.body -> if.else
Marking Block Executable: if.else

Popped off BBWL: 
if.else:                                          ; preds = %while.body
  %cmp22 = icmp eq i32 %conv14, 1
  br i1 %cmp22, label %if.then23, label %if.end26
Marking Edge Executable: if.else -> if.then23
Marking Block Executable: if.then23
Marking Edge Executable: if.else -> if.end26
Marking Block Executable: if.end26

Popped off BBWL: 
if.end26:                                         ; preds = %if.else, %if.then23
  %13 = load i32, ptr %n, align 4, !tbaa !35
  %inc = add nsw i32 %13, 1
  store i32 %inc, ptr %n, align 4, !tbaa !35
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup
Marking Edge Executable: if.end26 -> cleanup
Marking Block Executable: cleanup

Popped off BBWL: 
cleanup:                                          ; preds = %if.end26, %while.end
  call void @llvm.lifetime.end.p0(i64 1, ptr %kind) #1
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %while.cond
    i32 3, label %while.end27
  ], !llvm.loop !41
Marking Edge Executable: cleanup -> unreachable
Marking Block Executable: unreachable
Marking Edge Executable: cleanup -> while.cond
Marking Edge Executable: cleanup -> while.end27

Popped off BBWL: 
unreachable:                                      ; preds = %cleanup
  unreachable

Popped off BBWL: 
if.then23:                                        ; preds = %if.else
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option24) #1
  %10 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %10, ptr %tcp_option24, align 1, !tbaa !20
  %11 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec25 = add nsw i32 %11, -1
  store i32 %dec25, ptr %hdr_byte_left, align 4, !tbaa !35
  %12 = load i8, ptr %tcp_option24, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %12), !primate !7
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option24) #1
  br label %if.end26
Marking Edge Executable: if.then23 -> if.end26

Popped off BBWL: 
if.then16:                                        ; preds = %while.body
  %5 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec = add nsw i32 %5, -1
  store i32 %dec, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option) #1
  %6 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %6, ptr %tcp_option, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %6), !primate !7
  call void @llvm.lifetime.start.p0(i64 4, ptr %i) #1
  store i32 0, ptr %i, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 16, ptr %padding) #1
  br label %while.cond17
Marking Edge Executable: if.then16 -> while.cond17
Marking Block Executable: while.cond17

Popped off BBWL: 
while.cond17:                                     ; preds = %while.body19, %if.then16
  %7 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp18 = icmp sgt i32 %7, 0
  br i1 %cmp18, label %while.body19, label %while.end
Marking Edge Executable: while.cond17 -> while.body19
Marking Block Executable: while.body19
Marking Edge Executable: while.cond17 -> while.end
Marking Block Executable: while.end

Popped off BBWL: 
while.end:                                        ; preds = %while.cond17
  store i32 3, ptr %cleanup.dest.slot, align 4
  call void @llvm.lifetime.end.p0(i64 16, ptr %padding) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %i) #1
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option) #1
  br label %cleanup
Marking Edge Executable: while.end -> cleanup

Popped off BBWL: 
while.body19:                                     ; preds = %while.cond17
  call void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind writable sret(i128) align 8 %tmp), !primate !7
  %8 = load i128, ptr %tmp, align 8, !tbaa !37
  store i128 %8, ptr %padding, align 8, !tbaa !37
  store i128 %8, ptr %indirect-arg-temp, align 8, !tbaa !37
  call void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %indirect-arg-temp), !primate !7
  %9 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %sub20 = sub nsw i32 %9, 16
  store i32 %sub20, ptr %hdr_byte_left, align 4, !tbaa !35
  br label %while.cond17, !llvm.loop !39
Marking Edge Executable: while.body19 -> while.cond17

Popped off BBWL: 
entry:
  call void @llvm.primate.output.done()
  ret void

Popped off BBWL: 
entry:
  call void @llvm.primate.input.done()
  ret void

Popped off V-WL:   %sub20 = sub nsw i32 %9, 16

Popped off V-WL:   %9 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35

Popped off V-WL:   %8 = load i128, ptr %tmp, align 8, !tbaa !37

Popped off V-WL:   %cmp18 = icmp sgt i32 %7, 0

Popped off V-WL:   %7 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35

Popped off V-WL:   %6 = load i8, ptr %kind, align 1, !tbaa !20

Popped off V-WL:   %dec = add nsw i32 %5, -1

Popped off V-WL:   %5 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35

Popped off V-WL:   %12 = load i8, ptr %tcp_option24, align 1, !tbaa !20

Popped off V-WL:   %dec25 = add nsw i32 %11, -1

Popped off V-WL:   %11 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35

Popped off V-WL:   %10 = load i8, ptr %kind, align 1, !tbaa !20

Popped off V-WL:   %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4

Popped off V-WL:   %inc = add nsw i32 %13, 1

Popped off V-WL:   %13 = load i32, ptr %n, align 4, !tbaa !35

Popped off V-WL:   %cmp22 = icmp eq i32 %conv14, 1

Popped off V-WL:   %cmp15 = icmp eq i32 %conv14, 0

Popped off V-WL:   %conv14 = zext i8 %call to i32

Popped off V-WL:   %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7

Popped off V-WL:   %cmp13 = icmp sgt i32 %4, 0

Popped off V-WL:   %4 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35

Popped off V-WL:   %mul = mul nsw i32 4, %sub

Popped off V-WL:   %sub = sub nsw i32 %conv12, 5

Popped off V-WL:   %conv12 = sext i4 %3 to i32

Popped off V-WL:   %3 = load i4, ptr %dataOffset, align 8, !tbaa !33

Popped off V-WL:   %cmp9 = icmp sgt i32 %conv8, 0

Popped off V-WL:   %conv8 = sext i4 %2 to i32

Popped off V-WL:   %2 = load i4, ptr %dataOffset, align 8, !tbaa !33

Popped off V-WL:   %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1

Popped off V-WL:   %cmp32 = icmp eq i32 %conv3, 17

Popped off V-WL:   %cmp4 = icmp eq i32 %conv3, 6

Popped off V-WL:   %conv3 = zext i8 %1 to i32

Popped off V-WL:   %1 = load i8, ptr %protocol, align 8, !tbaa !24

Popped off V-WL:   %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1

Popped off V-WL:   %cmp = icmp eq i32 %conv, 2048

Popped off V-WL:   %conv = zext i16 %0 to i32

Popped off V-WL:   %0 = load i16, ptr %etherType, align 8, !tbaa !15

Popped off V-WL:   %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2

Popped off V-WL:   %agg.tmp35 = alloca %struct.udp_t, align 8

Popped off V-WL:   %ref.tmp34 = alloca %struct.udp_t, align 8

Popped off V-WL:   %tcp_option24 = alloca i8, align 1

Popped off V-WL:   %cleanup.dest.slot = alloca i32, align 4

Popped off V-WL:   %indirect-arg-temp = alloca i128, align 8

Popped off V-WL:   %tmp = alloca i128, align 8

Popped off V-WL:   %padding = alloca i128, align 8

Popped off V-WL:   %i = alloca i32, align 4

Popped off V-WL:   %tcp_option = alloca i8, align 1

Popped off V-WL:   %kind = alloca i8, align 1

Popped off V-WL:   %n = alloca i32, align 4

Popped off V-WL:   %hdr_byte_left = alloca i32, align 4

Popped off V-WL:   %agg.tmp7 = alloca %struct.tcp_t, align 8

Popped off V-WL:   %ref.tmp6 = alloca %struct.tcp_t, align 8

Popped off V-WL:   %agg.tmp2 = alloca %struct.ipv4_t, align 8

Popped off V-WL:   %ref.tmp1 = alloca %struct.ipv4_t, align 8

Popped off V-WL:   %agg.tmp = alloca %struct.ethernet_t, align 8

Popped off V-WL:   %ref.tmp = alloca %struct.ethernet_t, align 8

Popped off V-WL:   %udp = alloca %struct.udp_t, align 8

Popped off V-WL:   %tcp = alloca %struct.tcp_t, align 8

Popped off V-WL:   %ipv4 = alloca %struct.ipv4_t, align 8

Popped off V-WL:   %eth = alloca %struct.ethernet_t, align 8

Popped off V-WL:   %0 = call ptr @llvm.primate.input.p0.i32(i32 24)

Popped off V-WL:   %0 = call ptr @llvm.primate.input.p0.i32(i32 40)

Popped off V-WL:   %0 = call ptr @llvm.primate.input.p0.i32(i32 32)

Popped off V-WL:   %1 = load i8, ptr %0, align 1, !tbaa !8

Popped off V-WL:   %0 = call ptr @llvm.primate.input.p0.i32(i32 1)

Popped off V-WL:   %out.addr = alloca i8, align 1

Popped off V-WL:   %1 = load i128, ptr %0, align 8, !tbaa !8

Popped off V-WL:   %0 = call ptr @llvm.primate.input.p0.i32(i32 16)

Popped off V-WL:   %out = load i128, ptr %0, align 8, !tbaa !8

Popped off V-WL:   %out.addr = alloca i128, align 8

Popped off V-WL:   %0 = call ptr @llvm.primate.input.p0.i32(i32 8)
; *** IR Dump After CalledValuePropagationPass on [module] ***
; ModuleID = 'tcp_parse.cpp'
source_filename = "tcp_parse.cpp"
target datalayout = "e-G1-m:e-p:32:32-i64:64-n32-S128"
target triple = "primate32-unknown-linux-gnu"

%struct.ethernet_t = type { i48, i48, i16 }
%struct.ipv4_t = type { i72, i8, i80 }
%struct.tcp_t = type { i96, i4, i60 }
%struct.udp_t = type { i64 }

$_ZN7PRIMATE5inputI10ethernet_tEET_v = comdat any

$_ZN7PRIMATE6outputI10ethernet_tEEvT_ = comdat any

$_ZN7PRIMATE5inputI6ipv4_tEET_v = comdat any

$_ZN7PRIMATE6outputI6ipv4_tEEvT_ = comdat any

$_ZN7PRIMATE5inputI5tcp_tEET_v = comdat any

$_ZN7PRIMATE6outputI5tcp_tEEvT_ = comdat any

$_ZN7PRIMATE5inputIDU8_EET_v = comdat any

$_ZN7PRIMATE6outputIDU8_EEvT_ = comdat any

$_ZN7PRIMATE5inputIDU128_EET_v = comdat any

$_ZN7PRIMATE6outputIDU128_EEvT_ = comdat any

$_ZN7PRIMATE5inputI5udp_tEET_v = comdat any

$_ZN7PRIMATE6outputI5udp_tEEvT_ = comdat any

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.done() #1

; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() #2 {
entry:
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %udp = alloca %struct.udp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %hdr_byte_left = alloca i32, align 4
  %n = alloca i32, align 4
  %kind = alloca i8, align 1
  %tcp_option = alloca i8, align 1
  %i = alloca i32, align 4
  %padding = alloca i128, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %tcp_option24 = alloca i8, align 1
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.start.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr %ref.tmp) #1
  call void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind writable sret(%struct.ethernet_t) align 8 %ref.tmp), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %eth, ptr align 8 %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp, ptr align 8 %eth, i32 24, i1 false), !tbaa.struct !8
  call void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %agg.tmp), !primate !7
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %0 = load i16, ptr %etherType, align 8, !tbaa !15
  %conv = zext i16 %0 to i32
  %cmp = icmp eq i32 %conv, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr %ref.tmp1) #1
  call void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind writable sret(%struct.ipv4_t) align 8 %ref.tmp1), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %ipv4, ptr align 8 %ref.tmp1, i32 40, i1 false), !tbaa.struct !17
  call void @llvm.lifetime.end.p0(i64 40, ptr %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp2, ptr align 8 %ipv4, i32 40, i1 false), !tbaa.struct !17
  call void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %agg.tmp2), !primate !7
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %1 = load i8, ptr %protocol, align 8, !tbaa !24
  %conv3 = zext i8 %1 to i32
  %cmp4 = icmp eq i32 %conv3, 6
  br i1 %cmp4, label %if.then5, label %if.else29

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr %ref.tmp6) #1
  call void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind writable sret(%struct.tcp_t) align 8 %ref.tmp6), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %tcp, ptr align 8 %ref.tmp6, i32 32, i1 false), !tbaa.struct !26
  call void @llvm.lifetime.end.p0(i64 32, ptr %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp7, ptr align 8 %tcp, i32 32, i1 false), !tbaa.struct !26
  call void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %agg.tmp7), !primate !7
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %2 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv8 = sext i4 %2 to i32
  %cmp9 = icmp sgt i32 %conv8, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  call void @llvm.lifetime.start.p0(i64 4, ptr %hdr_byte_left) #1
  %3 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv12 = sext i4 %3 to i32
  %sub = sub nsw i32 %conv12, 5
  %mul = mul nsw i32 4, %sub
  store i32 %mul, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 4, ptr %n) #1
  store i32 0, ptr %n, align 4, !tbaa !35
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %4 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp13 = icmp sgt i32 %4, 0
  br i1 %cmp13, label %while.body, label %while.end27

while.body:                                       ; preds = %while.cond
  call void @llvm.lifetime.start.p0(i64 1, ptr %kind) #1
  %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
  store i8 %call, ptr %kind, align 1, !tbaa !20
  %conv14 = zext i8 %call to i32
  %cmp15 = icmp eq i32 %conv14, 0
  br i1 %cmp15, label %if.then16, label %if.else

if.then16:                                        ; preds = %while.body
  %5 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec = add nsw i32 %5, -1
  store i32 %dec, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option) #1
  %6 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %6, ptr %tcp_option, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %6), !primate !7
  call void @llvm.lifetime.start.p0(i64 4, ptr %i) #1
  store i32 0, ptr %i, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 16, ptr %padding) #1
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %7 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp18 = icmp sgt i32 %7, 0
  br i1 %cmp18, label %while.body19, label %while.end

while.body19:                                     ; preds = %while.cond17
  call void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind writable sret(i128) align 8 %tmp), !primate !7
  %8 = load i128, ptr %tmp, align 8, !tbaa !37
  store i128 %8, ptr %padding, align 8, !tbaa !37
  store i128 %8, ptr %indirect-arg-temp, align 8, !tbaa !37
  call void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %indirect-arg-temp), !primate !7
  %9 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %sub20 = sub nsw i32 %9, 16
  store i32 %sub20, ptr %hdr_byte_left, align 4, !tbaa !35
  br label %while.cond17, !llvm.loop !39

while.end:                                        ; preds = %while.cond17
  store i32 3, ptr %cleanup.dest.slot, align 4
  call void @llvm.lifetime.end.p0(i64 16, ptr %padding) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %i) #1
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option) #1
  br label %cleanup

if.else:                                          ; preds = %while.body
  %cmp22 = icmp eq i32 %conv14, 1
  br i1 %cmp22, label %if.then23, label %if.end26

if.then23:                                        ; preds = %if.else
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option24) #1
  %10 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %10, ptr %tcp_option24, align 1, !tbaa !20
  %11 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec25 = add nsw i32 %11, -1
  store i32 %dec25, ptr %hdr_byte_left, align 4, !tbaa !35
  %12 = load i8, ptr %tcp_option24, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %12), !primate !7
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option24) #1
  br label %if.end26

if.end26:                                         ; preds = %if.else, %if.then23
  %13 = load i32, ptr %n, align 4, !tbaa !35
  %inc = add nsw i32 %13, 1
  store i32 %inc, ptr %n, align 4, !tbaa !35
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end26, %while.end
  call void @llvm.lifetime.end.p0(i64 1, ptr %kind) #1
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %while.cond
    i32 3, label %while.end27
  ], !llvm.loop !41

while.end27:                                      ; preds = %cleanup, %while.cond
  call void @llvm.lifetime.end.p0(i64 4, ptr %n) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %hdr_byte_left) #1
  br label %if.end38

if.else29:                                        ; preds = %if.then
  %cmp32 = icmp eq i32 %conv3, 17
  br i1 %cmp32, label %if.then33, label %if.end38

if.then33:                                        ; preds = %if.else29
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp34) #1
  call void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind writable sret(%struct.udp_t) align 8 %ref.tmp34), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %udp, ptr align 8 %ref.tmp34, i32 8, i1 false), !tbaa.struct !42
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp34) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp35, ptr align 8 %udp, i32 8, i1 false), !tbaa.struct !42
  call void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %agg.tmp35), !primate !7
  br label %if.end38

if.end38:                                         ; preds = %while.end27, %if.then5, %if.then33, %if.else29, %entry
  call void @_ZN7PRIMATE10input_doneEv(), !primate !7
  call void @llvm.lifetime.end.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.end.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr %eth) #1
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ethernet_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 24, i1 false), !tbaa.struct !8
  ret void
}

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i32(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i32, i1 immarg) #4

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 24)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ipv4_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 40)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 40, i1 false), !tbaa.struct !17
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 40)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.tcp_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 32)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 32, i1 false), !tbaa.struct !26
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 32)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v() #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %1 = load i8, ptr %0, align 1, !tbaa !20
  ret i8 %1
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %out) #0 comdat !primate !7 {
entry:
  %out.addr = alloca i8, align 1
  store i8 %out, ptr %out.addr, align 1, !tbaa !20
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 1)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind noalias writable sret(i128) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 16)
  %1 = load i128, ptr %0, align 8, !tbaa !37
  store i128 %1, ptr %agg.result, align 8, !tbaa !37
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %0) #0 comdat !primate !7 {
entry:
  %out.addr = alloca i128, align 8
  %out = load i128, ptr %0, align 8, !tbaa !37
  store i128 %out, ptr %out.addr, align 8, !tbaa !37
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 16)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.udp_t) align 8 %agg.result) #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 8)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 8, i1 false), !tbaa.struct !42
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %out) #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 8)
  ret void
}

; Function Attrs: nounwind
declare !primate !7 ptr @llvm.primate.input.p0.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.p0.i32(ptr, i32) #1

attributes #0 = { alwaysinline mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #1 = { nounwind }
attributes #2 = { mustprogress "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #3 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5}
!llvm.ident = !{!6}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"ilp32"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{i32 8, !"SmallDataLimit", i32 8}
!6 = !{!"clang version 18.1.8 (git@github.com:FAST-Research-Group/primate-arch-gen.git e8582d4315ec2267abfc97212fa19f342d0812e8)"}
!7 = !{!"blue", !"IO", i64 1, i64 1}
!8 = !{i64 0, i64 8, !9, i64 8, i64 8, !9, i64 16, i64 2, !13}
!9 = !{!10, !10, i64 0}
!10 = !{!"_BitInt(48)", !11, i64 0}
!11 = !{!"omnipotent char", !12, i64 0}
!12 = !{!"Simple C++ TBAA"}
!13 = !{!14, !14, i64 0}
!14 = !{!"_BitInt(16)", !11, i64 0}
!15 = !{!16, !14, i64 16}
!16 = !{!"_ZTS10ethernet_t", !10, i64 0, !10, i64 8, !14, i64 16}
!17 = !{i64 0, i64 16, !18, i64 16, i64 1, !20, i64 24, i64 16, !22}
!18 = !{!19, !19, i64 0}
!19 = !{!"_BitInt(72)", !11, i64 0}
!20 = !{!21, !21, i64 0}
!21 = !{!"_BitInt(8)", !11, i64 0}
!22 = !{!23, !23, i64 0}
!23 = !{!"_BitInt(80)", !11, i64 0}
!24 = !{!25, !21, i64 16}
!25 = !{!"_ZTS6ipv4_t", !19, i64 0, !21, i64 16, !23, i64 24}
!26 = !{i64 0, i64 16, !27, i64 16, i64 1, !29, i64 24, i64 8, !31}
!27 = !{!28, !28, i64 0}
!28 = !{!"_BitInt(96)", !11, i64 0}
!29 = !{!30, !30, i64 0}
!30 = !{!"_BitInt(4)", !11, i64 0}
!31 = !{!32, !32, i64 0}
!32 = !{!"_BitInt(60)", !11, i64 0}
!33 = !{!34, !30, i64 16}
!34 = !{!"_ZTS5tcp_t", !28, i64 0, !30, i64 16, !32, i64 24}
!35 = !{!36, !36, i64 0}
!36 = !{!"int", !11, i64 0}
!37 = !{!38, !38, i64 0}
!38 = !{!"_BitInt(128)", !11, i64 0}
!39 = distinct !{!39, !40}
!40 = !{!"llvm.loop.mustprogress"}
!41 = distinct !{!41, !40}
!42 = !{i64 0, i64 8, !43}
!43 = !{!44, !44, i64 0}
!44 = !{!"_BitInt(64)", !11, i64 0}
; *** IR Dump After GlobalOptPass on [module] ***
; ModuleID = 'tcp_parse.cpp'
source_filename = "tcp_parse.cpp"
target datalayout = "e-G1-m:e-p:32:32-i64:64-n32-S128"
target triple = "primate32-unknown-linux-gnu"

%struct.ethernet_t = type { i48, i48, i16 }
%struct.ipv4_t = type { i72, i8, i80 }
%struct.tcp_t = type { i96, i4, i60 }
%struct.udp_t = type { i64 }

$_ZN7PRIMATE5inputI10ethernet_tEET_v = comdat any

$_ZN7PRIMATE6outputI10ethernet_tEEvT_ = comdat any

$_ZN7PRIMATE5inputI6ipv4_tEET_v = comdat any

$_ZN7PRIMATE6outputI6ipv4_tEEvT_ = comdat any

$_ZN7PRIMATE5inputI5tcp_tEET_v = comdat any

$_ZN7PRIMATE6outputI5tcp_tEEvT_ = comdat any

$_ZN7PRIMATE5inputIDU8_EET_v = comdat any

$_ZN7PRIMATE6outputIDU8_EEvT_ = comdat any

$_ZN7PRIMATE5inputIDU128_EET_v = comdat any

$_ZN7PRIMATE6outputIDU128_EEvT_ = comdat any

$_ZN7PRIMATE5inputI5udp_tEET_v = comdat any

$_ZN7PRIMATE6outputI5udp_tEEvT_ = comdat any

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.done() #1

; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %udp = alloca %struct.udp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %hdr_byte_left = alloca i32, align 4
  %n = alloca i32, align 4
  %kind = alloca i8, align 1
  %tcp_option = alloca i8, align 1
  %i = alloca i32, align 4
  %padding = alloca i128, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %cleanup.dest.slot = alloca i32, align 4
  %tcp_option24 = alloca i8, align 1
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.start.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr %ref.tmp) #1
  call void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind writable sret(%struct.ethernet_t) align 8 %ref.tmp), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %eth, ptr align 8 %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp, ptr align 8 %eth, i32 24, i1 false), !tbaa.struct !8
  call void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %agg.tmp), !primate !7
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %0 = load i16, ptr %etherType, align 8, !tbaa !15
  %conv = zext i16 %0 to i32
  %cmp = icmp eq i32 %conv, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr %ref.tmp1) #1
  call void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind writable sret(%struct.ipv4_t) align 8 %ref.tmp1), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %ipv4, ptr align 8 %ref.tmp1, i32 40, i1 false), !tbaa.struct !17
  call void @llvm.lifetime.end.p0(i64 40, ptr %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp2, ptr align 8 %ipv4, i32 40, i1 false), !tbaa.struct !17
  call void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %agg.tmp2), !primate !7
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %1 = load i8, ptr %protocol, align 8, !tbaa !24
  %conv3 = zext i8 %1 to i32
  %cmp4 = icmp eq i32 %conv3, 6
  br i1 %cmp4, label %if.then5, label %if.else29

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr %ref.tmp6) #1
  call void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind writable sret(%struct.tcp_t) align 8 %ref.tmp6), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %tcp, ptr align 8 %ref.tmp6, i32 32, i1 false), !tbaa.struct !26
  call void @llvm.lifetime.end.p0(i64 32, ptr %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp7, ptr align 8 %tcp, i32 32, i1 false), !tbaa.struct !26
  call void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %agg.tmp7), !primate !7
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %2 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv8 = sext i4 %2 to i32
  %cmp9 = icmp sgt i32 %conv8, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  call void @llvm.lifetime.start.p0(i64 4, ptr %hdr_byte_left) #1
  %3 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv12 = sext i4 %3 to i32
  %sub = sub nsw i32 %conv12, 5
  %mul = mul nsw i32 4, %sub
  store i32 %mul, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 4, ptr %n) #1
  store i32 0, ptr %n, align 4, !tbaa !35
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %4 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp13 = icmp sgt i32 %4, 0
  br i1 %cmp13, label %while.body, label %while.end27

while.body:                                       ; preds = %while.cond
  call void @llvm.lifetime.start.p0(i64 1, ptr %kind) #1
  %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
  store i8 %call, ptr %kind, align 1, !tbaa !20
  %conv14 = zext i8 %call to i32
  %cmp15 = icmp eq i32 %conv14, 0
  br i1 %cmp15, label %if.then16, label %if.else

if.then16:                                        ; preds = %while.body
  %5 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec = add nsw i32 %5, -1
  store i32 %dec, ptr %hdr_byte_left, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option) #1
  %6 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %6, ptr %tcp_option, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %6), !primate !7
  call void @llvm.lifetime.start.p0(i64 4, ptr %i) #1
  store i32 0, ptr %i, align 4, !tbaa !35
  call void @llvm.lifetime.start.p0(i64 16, ptr %padding) #1
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %7 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %cmp18 = icmp sgt i32 %7, 0
  br i1 %cmp18, label %while.body19, label %while.end

while.body19:                                     ; preds = %while.cond17
  call void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind writable sret(i128) align 8 %tmp), !primate !7
  %8 = load i128, ptr %tmp, align 8, !tbaa !37
  store i128 %8, ptr %padding, align 8, !tbaa !37
  store i128 %8, ptr %indirect-arg-temp, align 8, !tbaa !37
  call void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %indirect-arg-temp), !primate !7
  %9 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %sub20 = sub nsw i32 %9, 16
  store i32 %sub20, ptr %hdr_byte_left, align 4, !tbaa !35
  br label %while.cond17, !llvm.loop !39

while.end:                                        ; preds = %while.cond17
  store i32 3, ptr %cleanup.dest.slot, align 4
  call void @llvm.lifetime.end.p0(i64 16, ptr %padding) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %i) #1
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option) #1
  br label %cleanup

if.else:                                          ; preds = %while.body
  %cmp22 = icmp eq i32 %conv14, 1
  br i1 %cmp22, label %if.then23, label %if.end26

if.then23:                                        ; preds = %if.else
  call void @llvm.lifetime.start.p0(i64 1, ptr %tcp_option24) #1
  %10 = load i8, ptr %kind, align 1, !tbaa !20
  store i8 %10, ptr %tcp_option24, align 1, !tbaa !20
  %11 = load i32, ptr %hdr_byte_left, align 4, !tbaa !35
  %dec25 = add nsw i32 %11, -1
  store i32 %dec25, ptr %hdr_byte_left, align 4, !tbaa !35
  %12 = load i8, ptr %tcp_option24, align 1, !tbaa !20
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %12), !primate !7
  call void @llvm.lifetime.end.p0(i64 1, ptr %tcp_option24) #1
  br label %if.end26

if.end26:                                         ; preds = %if.else, %if.then23
  %13 = load i32, ptr %n, align 4, !tbaa !35
  %inc = add nsw i32 %13, 1
  store i32 %inc, ptr %n, align 4, !tbaa !35
  store i32 0, ptr %cleanup.dest.slot, align 4
  br label %cleanup

cleanup:                                          ; preds = %if.end26, %while.end
  call void @llvm.lifetime.end.p0(i64 1, ptr %kind) #1
  %cleanup.dest = load i32, ptr %cleanup.dest.slot, align 4
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %while.cond
    i32 3, label %while.end27
  ], !llvm.loop !41

while.end27:                                      ; preds = %cleanup, %while.cond
  call void @llvm.lifetime.end.p0(i64 4, ptr %n) #1
  call void @llvm.lifetime.end.p0(i64 4, ptr %hdr_byte_left) #1
  br label %if.end38

if.else29:                                        ; preds = %if.then
  %cmp32 = icmp eq i32 %conv3, 17
  br i1 %cmp32, label %if.then33, label %if.end38

if.then33:                                        ; preds = %if.else29
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp34) #1
  call void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind writable sret(%struct.udp_t) align 8 %ref.tmp34), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %udp, ptr align 8 %ref.tmp34, i32 8, i1 false), !tbaa.struct !42
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp34) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp35, ptr align 8 %udp, i32 8, i1 false), !tbaa.struct !42
  call void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %agg.tmp35), !primate !7
  br label %if.end38

if.end38:                                         ; preds = %while.end27, %if.then5, %if.then33, %if.else29, %entry
  call void @_ZN7PRIMATE10input_doneEv(), !primate !7
  call void @llvm.lifetime.end.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.end.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr %eth) #1
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ethernet_t) align 8 %agg.result) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 24, i1 false), !tbaa.struct !8
  ret void
}

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i32(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i32, i1 immarg) #4

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %out) local_unnamed_addr #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 24)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ipv4_t) align 8 %agg.result) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 40)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 40, i1 false), !tbaa.struct !17
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %out) local_unnamed_addr #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 40)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.tcp_t) align 8 %agg.result) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 32)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 32, i1 false), !tbaa.struct !26
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %out) local_unnamed_addr #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 32)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v() local_unnamed_addr #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %1 = load i8, ptr %0, align 1, !tbaa !20
  ret i8 %1
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %out) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %out.addr = alloca i8, align 1
  store i8 %out, ptr %out.addr, align 1, !tbaa !20
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 1)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind noalias writable sret(i128) align 8 %agg.result) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 16)
  %1 = load i128, ptr %0, align 8, !tbaa !37
  store i128 %1, ptr %agg.result, align 8, !tbaa !37
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %0) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %out.addr = alloca i128, align 8
  %out = load i128, ptr %0, align 8, !tbaa !37
  store i128 %out, ptr %out.addr, align 8, !tbaa !37
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 16)
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.udp_t) align 8 %agg.result) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 8)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 8, i1 false), !tbaa.struct !42
  ret void
}

; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %out) local_unnamed_addr #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 8)
  ret void
}

; Function Attrs: nounwind
declare !primate !7 ptr @llvm.primate.input.p0.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.p0.i32(ptr, i32) #1

attributes #0 = { alwaysinline mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #1 = { nounwind }
attributes #2 = { mustprogress "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #3 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5}
!llvm.ident = !{!6}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"ilp32"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{i32 8, !"SmallDataLimit", i32 8}
!6 = !{!"clang version 18.1.8 (git@github.com:FAST-Research-Group/primate-arch-gen.git e8582d4315ec2267abfc97212fa19f342d0812e8)"}
!7 = !{!"blue", !"IO", i64 1, i64 1}
!8 = !{i64 0, i64 8, !9, i64 8, i64 8, !9, i64 16, i64 2, !13}
!9 = !{!10, !10, i64 0}
!10 = !{!"_BitInt(48)", !11, i64 0}
!11 = !{!"omnipotent char", !12, i64 0}
!12 = !{!"Simple C++ TBAA"}
!13 = !{!14, !14, i64 0}
!14 = !{!"_BitInt(16)", !11, i64 0}
!15 = !{!16, !14, i64 16}
!16 = !{!"_ZTS10ethernet_t", !10, i64 0, !10, i64 8, !14, i64 16}
!17 = !{i64 0, i64 16, !18, i64 16, i64 1, !20, i64 24, i64 16, !22}
!18 = !{!19, !19, i64 0}
!19 = !{!"_BitInt(72)", !11, i64 0}
!20 = !{!21, !21, i64 0}
!21 = !{!"_BitInt(8)", !11, i64 0}
!22 = !{!23, !23, i64 0}
!23 = !{!"_BitInt(80)", !11, i64 0}
!24 = !{!25, !21, i64 16}
!25 = !{!"_ZTS6ipv4_t", !19, i64 0, !21, i64 16, !23, i64 24}
!26 = !{i64 0, i64 16, !27, i64 16, i64 1, !29, i64 24, i64 8, !31}
!27 = !{!28, !28, i64 0}
!28 = !{!"_BitInt(96)", !11, i64 0}
!29 = !{!30, !30, i64 0}
!30 = !{!"_BitInt(4)", !11, i64 0}
!31 = !{!32, !32, i64 0}
!32 = !{!"_BitInt(60)", !11, i64 0}
!33 = !{!34, !30, i64 16}
!34 = !{!"_ZTS5tcp_t", !28, i64 0, !30, i64 16, !32, i64 24}
!35 = !{!36, !36, i64 0}
!36 = !{!"int", !11, i64 0}
!37 = !{!38, !38, i64 0}
!38 = !{!"_BitInt(128)", !11, i64 0}
!39 = distinct !{!39, !40}
!40 = !{!"llvm.loop.mustprogress"}
!41 = distinct !{!41, !40}
!42 = !{i64 0, i64 8, !43}
!43 = !{!44, !44, i64 0}
!44 = !{!"_BitInt(64)", !11, i64 0}
; *** IR Dump After PromotePass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE10input_doneEv
ADD:   ret void
ADD:   call void @llvm.primate.input.done()
IC: Visiting:   call void @llvm.primate.input.done()
IC: Visiting:   ret void
; *** IR Dump After InstCombinePass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After PromotePass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE11output_doneEv
ADD:   ret void
ADD:   call void @llvm.primate.output.done()
IC: Visiting:   call void @llvm.primate.output.done()
IC: Visiting:   ret void
; *** IR Dump After InstCombinePass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After PromotePass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %udp = alloca %struct.udp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.start.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr %ref.tmp) #1
  call void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind writable sret(%struct.ethernet_t) align 8 %ref.tmp), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %eth, ptr align 8 %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp, ptr align 8 %eth, i32 24, i1 false), !tbaa.struct !8
  call void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %agg.tmp), !primate !7
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %0 = load i16, ptr %etherType, align 8, !tbaa !15
  %conv = zext i16 %0 to i32
  %cmp = icmp eq i32 %conv, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr %ref.tmp1) #1
  call void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind writable sret(%struct.ipv4_t) align 8 %ref.tmp1), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %ipv4, ptr align 8 %ref.tmp1, i32 40, i1 false), !tbaa.struct !17
  call void @llvm.lifetime.end.p0(i64 40, ptr %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp2, ptr align 8 %ipv4, i32 40, i1 false), !tbaa.struct !17
  call void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %agg.tmp2), !primate !7
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %1 = load i8, ptr %protocol, align 8, !tbaa !24
  %conv3 = zext i8 %1 to i32
  %cmp4 = icmp eq i32 %conv3, 6
  br i1 %cmp4, label %if.then5, label %if.else29

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr %ref.tmp6) #1
  call void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind writable sret(%struct.tcp_t) align 8 %ref.tmp6), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %tcp, ptr align 8 %ref.tmp6, i32 32, i1 false), !tbaa.struct !26
  call void @llvm.lifetime.end.p0(i64 32, ptr %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp7, ptr align 8 %tcp, i32 32, i1 false), !tbaa.struct !26
  call void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %agg.tmp7), !primate !7
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %2 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv8 = sext i4 %2 to i32
  %cmp9 = icmp sgt i32 %conv8, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %3 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv12 = sext i4 %3 to i32
  %sub = sub nsw i32 %conv12, 5
  %mul = mul nsw i32 4, %sub
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %n.0 = phi i32 [ 0, %if.then10 ], [ %n.1, %cleanup ]
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %while.end27

while.body:                                       ; preds = %while.cond
  %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
  %conv14 = zext i8 %call to i32
  %cmp15 = icmp eq i32 %conv14, 0
  br i1 %cmp15, label %if.then16, label %if.else

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %call), !primate !7
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %while.end

while.body19:                                     ; preds = %while.cond17
  call void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind writable sret(i128) align 8 %tmp), !primate !7
  %4 = load i128, ptr %tmp, align 8, !tbaa !35
  store i128 %4, ptr %indirect-arg-temp, align 8, !tbaa !35
  call void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %indirect-arg-temp), !primate !7
  %sub20 = sub nsw i32 %hdr_byte_left.1, 16
  br label %while.cond17, !llvm.loop !37

while.end:                                        ; preds = %while.cond17
  br label %cleanup

if.else:                                          ; preds = %while.body
  %cmp22 = icmp eq i32 %conv14, 1
  br i1 %cmp22, label %if.then23, label %if.end26

if.then23:                                        ; preds = %if.else
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %call), !primate !7
  br label %if.end26

if.end26:                                         ; preds = %if.else, %if.then23
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %if.else ]
  %inc = add nsw i32 %n.0, 1
  br label %cleanup

cleanup:                                          ; preds = %if.end26, %while.end
  %cleanup.dest.slot.0 = phi i32 [ 3, %while.end ], [ 0, %if.end26 ]
  %n.1 = phi i32 [ %n.0, %while.end ], [ %inc, %if.end26 ]
  %hdr_byte_left.3 = phi i32 [ %hdr_byte_left.1, %while.end ], [ %hdr_byte_left.2, %if.end26 ]
  switch i32 %cleanup.dest.slot.0, label %unreachable [
    i32 0, label %while.cond
    i32 3, label %while.end27
  ], !llvm.loop !39

while.end27:                                      ; preds = %cleanup, %while.cond
  br label %if.end38

if.else29:                                        ; preds = %if.then
  %cmp32 = icmp eq i32 %conv3, 17
  br i1 %cmp32, label %if.then33, label %if.end38

if.then33:                                        ; preds = %if.else29
  call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp34) #1
  call void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind writable sret(%struct.udp_t) align 8 %ref.tmp34), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %udp, ptr align 8 %ref.tmp34, i32 8, i1 false), !tbaa.struct !40
  call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp34) #1
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp35, ptr align 8 %udp, i32 8, i1 false), !tbaa.struct !40
  call void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %agg.tmp35), !primate !7
  br label %if.end38

if.end38:                                         ; preds = %while.end27, %if.then5, %if.then33, %if.else29, %entry
  call void @_ZN7PRIMATE10input_doneEv(), !primate !7
  call void @llvm.lifetime.end.p0(i64 8, ptr %udp) #1
  call void @llvm.lifetime.end.p0(i64 32, ptr %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr %eth) #1
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}


INSTCOMBINE ITERATION #1 on _Z12primate_mainv
ADD:   br label %while.cond17, !llvm.loop !37
ADD:   %sub20 = sub nsw i32 %hdr_byte_left.1, 16
ADD:   call void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %indirect-arg-temp), !primate !7
ADD:   store i128 %4, ptr %indirect-arg-temp, align 8, !tbaa !35
ADD:   %4 = load i128, ptr %tmp, align 8, !tbaa !35
ADD:   call void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind writable sret(i128) align 8 %tmp), !primate !7
ADD:   unreachable
ADD:   ret void
ADD:   call void @llvm.lifetime.end.p0(i64 24, ptr %eth) #1
ADD:   call void @llvm.lifetime.end.p0(i64 40, ptr %ipv4) #1
ADD:   call void @llvm.lifetime.end.p0(i64 32, ptr %tcp) #1
ADD:   call void @llvm.lifetime.end.p0(i64 8, ptr %udp) #1
ADD:   call void @_ZN7PRIMATE10input_doneEv(), !primate !7
ADD:   br label %if.end38
ADD:   switch i32 %cleanup.dest.slot.0, label %unreachable [
    i32 0, label %while.cond
    i32 3, label %while.end27
  ], !llvm.loop !39
ADD:   %hdr_byte_left.3 = phi i32 [ %hdr_byte_left.1, %while.end ], [ %hdr_byte_left.2, %if.end26 ]
ADD:   %n.1 = phi i32 [ %n.0, %while.end ], [ %inc, %if.end26 ]
ADD:   %cleanup.dest.slot.0 = phi i32 [ 3, %while.end ], [ 0, %if.end26 ]
ADD:   br label %cleanup
ADD:   br i1 %cmp18, label %while.body19, label %while.end
ADD:   %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
ADD:   %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
ADD:   br label %while.cond17
ADD:   call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %call), !primate !7
ADD:   %dec = add nsw i32 %hdr_byte_left.0, -1
ADD:   br label %cleanup
ADD:   %inc = add nsw i32 %n.0, 1
ADD:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %if.else ]
ADD:   br label %if.end26
ADD:   call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %call), !primate !7
ADD:   %dec25 = add nsw i32 %hdr_byte_left.0, -1
ADD:   br i1 %cmp22, label %if.then23, label %if.end26
ADD:   %cmp22 = icmp eq i32 %conv14, 1
ADD:   br i1 %cmp15, label %if.then16, label %if.else
ADD:   %cmp15 = icmp eq i32 %conv14, 0
ADD:   %conv14 = zext i8 %call to i32
ADD:   %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
ADD:   br i1 %cmp13, label %while.body, label %while.end27
ADD:   %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
ADD:   %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ]
ADD:   %n.0 = phi i32 [ 0, %if.then10 ], [ %n.1, %cleanup ]
ADD:   br label %while.cond
ADD:   %mul = mul nsw i32 4, %sub
ADD:   %sub = sub nsw i32 %conv12, 5
ADD:   %conv12 = sext i4 %3 to i32
ADD:   %3 = load i4, ptr %dataOffset, align 8, !tbaa !33
ADD:   br i1 %cmp9, label %if.then10, label %if.end38
ADD:   %cmp9 = icmp sgt i32 %conv8, 0
ADD:   %conv8 = sext i4 %2 to i32
ADD:   %2 = load i4, ptr %dataOffset, align 8, !tbaa !33
ADD:   %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
ADD:   call void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %agg.tmp7), !primate !7
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp7, ptr align 8 %tcp, i32 32, i1 false), !tbaa.struct !26
ADD:   call void @llvm.lifetime.end.p0(i64 32, ptr %ref.tmp6) #1
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %tcp, ptr align 8 %ref.tmp6, i32 32, i1 false), !tbaa.struct !26
ADD:   call void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind writable sret(%struct.tcp_t) align 8 %ref.tmp6), !primate !7
ADD:   call void @llvm.lifetime.start.p0(i64 32, ptr %ref.tmp6) #1
ADD:   br label %if.end38
ADD:   call void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %agg.tmp35), !primate !7
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp35, ptr align 8 %udp, i32 8, i1 false), !tbaa.struct !40
ADD:   call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp34) #1
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %udp, ptr align 8 %ref.tmp34, i32 8, i1 false), !tbaa.struct !40
ADD:   call void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind writable sret(%struct.udp_t) align 8 %ref.tmp34), !primate !7
ADD:   call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp34) #1
ADD:   br i1 %cmp32, label %if.then33, label %if.end38
ADD:   %cmp32 = icmp eq i32 %conv3, 17
ADD:   br i1 %cmp4, label %if.then5, label %if.else29
ADD:   %cmp4 = icmp eq i32 %conv3, 6
ADD:   %conv3 = zext i8 %1 to i32
ADD:   %1 = load i8, ptr %protocol, align 8, !tbaa !24
ADD:   %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
ADD:   call void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %agg.tmp2), !primate !7
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp2, ptr align 8 %ipv4, i32 40, i1 false), !tbaa.struct !17
ADD:   call void @llvm.lifetime.end.p0(i64 40, ptr %ref.tmp1) #1
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %ipv4, ptr align 8 %ref.tmp1, i32 40, i1 false), !tbaa.struct !17
ADD:   call void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind writable sret(%struct.ipv4_t) align 8 %ref.tmp1), !primate !7
ADD:   call void @llvm.lifetime.start.p0(i64 40, ptr %ref.tmp1) #1
ADD:   br i1 %cmp, label %if.then, label %if.end38
ADD:   %cmp = icmp eq i32 %conv, 2048
ADD:   %conv = zext i16 %0 to i32
ADD:   %0 = load i16, ptr %etherType, align 8, !tbaa !15
ADD:   %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
ADD:   call void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %agg.tmp), !primate !7
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp, ptr align 8 %eth, i32 24, i1 false), !tbaa.struct !8
ADD:   call void @llvm.lifetime.end.p0(i64 24, ptr %ref.tmp) #1
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %eth, ptr align 8 %ref.tmp, i32 24, i1 false), !tbaa.struct !8
ADD:   call void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind writable sret(%struct.ethernet_t) align 8 %ref.tmp), !primate !7
ADD:   call void @llvm.lifetime.start.p0(i64 24, ptr %ref.tmp) #1
ADD:   call void @llvm.lifetime.start.p0(i64 8, ptr %udp) #1
ADD:   call void @llvm.lifetime.start.p0(i64 32, ptr %tcp) #1
ADD:   call void @llvm.lifetime.start.p0(i64 40, ptr %ipv4) #1
ADD:   call void @llvm.lifetime.start.p0(i64 24, ptr %eth) #1
ADD:   %agg.tmp35 = alloca %struct.udp_t, align 8
ADD:   %ref.tmp34 = alloca %struct.udp_t, align 8
ADD:   %indirect-arg-temp = alloca i128, align 8
ADD:   %tmp = alloca i128, align 8
ADD:   %agg.tmp7 = alloca %struct.tcp_t, align 8
ADD:   %ref.tmp6 = alloca %struct.tcp_t, align 8
ADD:   %agg.tmp2 = alloca %struct.ipv4_t, align 8
ADD:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
ADD:   %agg.tmp = alloca %struct.ethernet_t, align 8
ADD:   %ref.tmp = alloca %struct.ethernet_t, align 8
ADD:   %udp = alloca %struct.udp_t, align 8
ADD:   %tcp = alloca %struct.tcp_t, align 8
ADD:   %ipv4 = alloca %struct.ipv4_t, align 8
ADD:   %eth = alloca %struct.ethernet_t, align 8
IC: Visiting:   %eth = alloca %struct.ethernet_t, align 8
IC: Visiting:   %ipv4 = alloca %struct.ipv4_t, align 8
IC: Visiting:   %tcp = alloca %struct.tcp_t, align 8
IC: Visiting:   %udp = alloca %struct.udp_t, align 8
IC: Visiting:   %ref.tmp = alloca %struct.ethernet_t, align 8
IC: Visiting:   %agg.tmp = alloca %struct.ethernet_t, align 8
IC: Visiting:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
IC: Visiting:   %agg.tmp2 = alloca %struct.ipv4_t, align 8
IC: Visiting:   %ref.tmp6 = alloca %struct.tcp_t, align 8
IC: Visiting:   %agg.tmp7 = alloca %struct.tcp_t, align 8
IC: Visiting:   %tmp = alloca i128, align 8
IC: Visiting:   %indirect-arg-temp = alloca i128, align 8
IC: Visiting:   %ref.tmp34 = alloca %struct.udp_t, align 8
IC: Visiting:   %agg.tmp35 = alloca %struct.udp_t, align 8
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 24, ptr %eth) #1
IC: Mod =   call void @llvm.lifetime.start.p0(i64 24, ptr %eth) #1
    New =   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
ADD:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 40, ptr %ipv4) #1
IC: Mod =   call void @llvm.lifetime.start.p0(i64 40, ptr %ipv4) #1
    New =   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
ADD:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 32, ptr %tcp) #1
IC: Mod =   call void @llvm.lifetime.start.p0(i64 32, ptr %tcp) #1
    New =   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
ADD:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 8, ptr %udp) #1
IC: Mod =   call void @llvm.lifetime.start.p0(i64 8, ptr %udp) #1
    New =   call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %udp) #1
ADD:   call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %udp) #1
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %udp) #1
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 24, ptr %ref.tmp) #1
IC: Mod =   call void @llvm.lifetime.start.p0(i64 24, ptr %ref.tmp) #1
    New =   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
ADD:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
IC: Visiting:   call void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind writable sret(%struct.ethernet_t) align 8 %ref.tmp), !primate !7
IC: Mod =   call void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind writable sret(%struct.ethernet_t) align 8 %ref.tmp), !primate !7
    New =   call void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind nonnull writable sret(%struct.ethernet_t) align 8 %ref.tmp), !primate !7
ADD:   call void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind nonnull writable sret(%struct.ethernet_t) align 8 %ref.tmp), !primate !7
IC: Visiting:   call void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind nonnull writable sret(%struct.ethernet_t) align 8 %ref.tmp), !primate !7
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %eth, ptr align 8 %ref.tmp, i32 24, i1 false), !tbaa.struct !8
IC: Mod =   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %eth, ptr align 8 %ref.tmp, i32 24, i1 false), !tbaa.struct !8
    New =   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 24, ptr %ref.tmp) #1
IC: Mod =   call void @llvm.lifetime.end.p0(i64 24, ptr %ref.tmp) #1
    New =   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
ADD:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp, ptr align 8 %eth, i32 24, i1 false), !tbaa.struct !8
IC: Mod =   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp, ptr align 8 %eth, i32 24, i1 false), !tbaa.struct !8
    New =   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
IC: Visiting:   call void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %agg.tmp), !primate !7
IC: Mod =   call void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %agg.tmp), !primate !7
    New =   call void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef nonnull byval(%struct.ethernet_t) align 8 %agg.tmp), !primate !7
ADD:   call void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef nonnull byval(%struct.ethernet_t) align 8 %agg.tmp), !primate !7
IC: Visiting:   call void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef nonnull byval(%struct.ethernet_t) align 8 %agg.tmp), !primate !7
IC: Visiting:   %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
IC: Visiting:   %0 = load i16, ptr %etherType, align 8, !tbaa !15
IC: Visiting:   %conv = zext i16 %0 to i32
IC: Visiting:   %cmp = icmp eq i32 %conv, 2048
IC: Old =   %cmp = icmp eq i32 %conv, 2048
    New =   <badref> = icmp eq i16 %0, 2048
ADD:   %cmp = icmp eq i16 %0, 2048
IC: ERASE   %1 = icmp eq i32 %conv, 2048
ADD DEFERRED:   %conv = zext i16 %0 to i32
IC: ERASE   %conv = zext i16 %0 to i32
ADD DEFERRED:   %0 = load i16, ptr %etherType, align 8, !tbaa !15
ADD DEFERRED:   %cmp = icmp eq i16 %0, 2048
ADD:   %0 = load i16, ptr %etherType, align 8, !tbaa !15
IC: Visiting:   %0 = load i16, ptr %etherType, align 8, !tbaa !15
IC: Visiting:   %cmp = icmp eq i16 %0, 2048
IC: Visiting:   br i1 %cmp, label %if.then, label %if.end38
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 40, ptr %ref.tmp1) #1
IC: Mod =   call void @llvm.lifetime.start.p0(i64 40, ptr %ref.tmp1) #1
    New =   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
ADD:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
IC: Visiting:   call void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind writable sret(%struct.ipv4_t) align 8 %ref.tmp1), !primate !7
IC: Mod =   call void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind writable sret(%struct.ipv4_t) align 8 %ref.tmp1), !primate !7
    New =   call void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind nonnull writable sret(%struct.ipv4_t) align 8 %ref.tmp1), !primate !7
ADD:   call void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind nonnull writable sret(%struct.ipv4_t) align 8 %ref.tmp1), !primate !7
IC: Visiting:   call void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind nonnull writable sret(%struct.ipv4_t) align 8 %ref.tmp1), !primate !7
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %ipv4, ptr align 8 %ref.tmp1, i32 40, i1 false), !tbaa.struct !17
IC: Mod =   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %ipv4, ptr align 8 %ref.tmp1, i32 40, i1 false), !tbaa.struct !17
    New =   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !17
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !17
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !17
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 40, ptr %ref.tmp1) #1
IC: Mod =   call void @llvm.lifetime.end.p0(i64 40, ptr %ref.tmp1) #1
    New =   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
ADD:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp2, ptr align 8 %ipv4, i32 40, i1 false), !tbaa.struct !17
IC: Mod =   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp2, ptr align 8 %ipv4, i32 40, i1 false), !tbaa.struct !17
    New =   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !17
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !17
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !17
IC: Visiting:   call void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %agg.tmp2), !primate !7
IC: Mod =   call void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %agg.tmp2), !primate !7
    New =   call void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef nonnull byval(%struct.ipv4_t) align 8 %agg.tmp2), !primate !7
ADD:   call void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef nonnull byval(%struct.ipv4_t) align 8 %agg.tmp2), !primate !7
IC: Visiting:   call void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef nonnull byval(%struct.ipv4_t) align 8 %agg.tmp2), !primate !7
IC: Visiting:   %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
IC: Visiting:   %1 = load i8, ptr %protocol, align 8, !tbaa !24
IC: Visiting:   %conv3 = zext i8 %1 to i32
IC: Visiting:   %cmp4 = icmp eq i32 %conv3, 6
IC: Old =   %cmp4 = icmp eq i32 %conv3, 6
    New =   <badref> = icmp eq i8 %1, 6
ADD:   %cmp4 = icmp eq i8 %1, 6
IC: ERASE   %2 = icmp eq i32 %conv3, 6
ADD DEFERRED:   %conv3 = zext i8 %1 to i32
ADD DEFERRED:   %cmp32 = icmp eq i32 %conv3, 17
ADD:   %conv3 = zext i8 %1 to i32
IC: Sink:   %conv3 = zext i8 %1 to i32
ADD:   %1 = load i8, ptr %protocol, align 8, !tbaa !24
IC: Visiting:   %conv3 = zext i8 %1 to i32
IC: Visiting:   %1 = load i8, ptr %protocol, align 8, !tbaa !24
IC: Visiting:   %cmp4 = icmp eq i8 %1, 6
IC: Visiting:   br i1 %cmp4, label %if.then5, label %if.else29
IC: Visiting:   %cmp32 = icmp eq i32 %conv3, 17
IC: Old =   %cmp32 = icmp eq i32 %conv3, 17
    New =   <badref> = icmp eq i8 %1, 17
ADD:   %cmp32 = icmp eq i8 %1, 17
IC: ERASE   %5 = icmp eq i32 %conv3, 17
ADD DEFERRED:   %conv3 = zext i8 %1 to i32
IC: ERASE   %conv3 = zext i8 %1 to i32
ADD DEFERRED:   %1 = load i8, ptr %protocol, align 8, !tbaa !24
ADD:   %1 = load i8, ptr %protocol, align 8, !tbaa !24
IC: Visiting:   %1 = load i8, ptr %protocol, align 8, !tbaa !24
IC: Visiting:   %cmp32 = icmp eq i8 %1, 17
IC: Visiting:   br i1 %cmp32, label %if.then33, label %if.end38
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp34) #1
IC: Mod =   call void @llvm.lifetime.start.p0(i64 8, ptr %ref.tmp34) #1
    New =   call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
ADD:   call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
IC: Visiting:   call void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind writable sret(%struct.udp_t) align 8 %ref.tmp34), !primate !7
IC: Mod =   call void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind writable sret(%struct.udp_t) align 8 %ref.tmp34), !primate !7
    New =   call void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind nonnull writable sret(%struct.udp_t) align 8 %ref.tmp34), !primate !7
ADD:   call void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind nonnull writable sret(%struct.udp_t) align 8 %ref.tmp34), !primate !7
IC: Visiting:   call void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind nonnull writable sret(%struct.udp_t) align 8 %ref.tmp34), !primate !7
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %udp, ptr align 8 %ref.tmp34, i32 8, i1 false), !tbaa.struct !40
ADD DEFERRED:   %5 = load i64, ptr %ref.tmp34, align 8
ADD DEFERRED:   store i64 %5, ptr %udp, align 8
IC: Mod =   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %udp, ptr align 8 %ref.tmp34, i32 8, i1 false), !tbaa.struct !40
    New =   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %udp, ptr align 8 %ref.tmp34, i32 0, i1 false), !tbaa.struct !42
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %udp, ptr align 8 %ref.tmp34, i32 0, i1 false), !tbaa.struct !42
ADD:   store i64 %5, ptr %udp, align 8, !tbaa !40
ADD:   %5 = load i64, ptr %ref.tmp34, align 8, !tbaa !40
IC: Visiting:   %5 = load i64, ptr %ref.tmp34, align 8, !tbaa !40
IC: Visiting:   store i64 %5, ptr %udp, align 8, !tbaa !40
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %udp, ptr align 8 %ref.tmp34, i32 0, i1 false), !tbaa.struct !42
IC: ERASE   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %udp, ptr align 8 %ref.tmp34, i32 0, i1 false), !tbaa.struct !42
ADD DEFERRED:   %udp = alloca %struct.udp_t, align 8
ADD DEFERRED:   %ref.tmp34 = alloca %struct.udp_t, align 8
ADD:   %ref.tmp34 = alloca %struct.udp_t, align 8
ADD:   %udp = alloca %struct.udp_t, align 8
IC: Visiting:   %udp = alloca %struct.udp_t, align 8
IC: Visiting:   %ref.tmp34 = alloca %struct.udp_t, align 8
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp34) #1
IC: Mod =   call void @llvm.lifetime.end.p0(i64 8, ptr %ref.tmp34) #1
    New =   call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
ADD:   call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp35, ptr align 8 %udp, i32 8, i1 false), !tbaa.struct !42
ADD DEFERRED:   %6 = load i64, ptr %udp, align 8
ADD DEFERRED:   store i64 %6, ptr %agg.tmp35, align 8
IC: Mod =   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp35, ptr align 8 %udp, i32 8, i1 false), !tbaa.struct !42
    New =   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp35, ptr align 8 %udp, i32 0, i1 false), !tbaa.struct !42
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp35, ptr align 8 %udp, i32 0, i1 false), !tbaa.struct !42
ADD:   store i64 %6, ptr %agg.tmp35, align 8, !tbaa !40
ADD:   %6 = load i64, ptr %udp, align 8, !tbaa !40
IC: Visiting:   %6 = load i64, ptr %udp, align 8, !tbaa !40
Captured?:   %udp = alloca %struct.udp_t, align 8 = not captured
IC: Replacing   %6 = load i64, ptr %udp, align 8, !tbaa !40
    with   %5 = load i64, ptr %ref.tmp34, align 8, !tbaa !40
IC: Mod =   %6 = load i64, ptr %udp, align 8, !tbaa !40
    New =   %6 = load i64, ptr %udp, align 8, !tbaa !40
IC: ERASE   %6 = load i64, ptr %udp, align 8, !tbaa !40
ADD DEFERRED:   %udp = alloca %struct.udp_t, align 8
ADD:   %udp = alloca %struct.udp_t, align 8
IC: Visiting:   %udp = alloca %struct.udp_t, align 8
IC: Visiting:   store i64 %5, ptr %agg.tmp35, align 8, !tbaa !40
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp35, ptr align 8 %udp, i32 0, i1 false), !tbaa.struct !42
IC: ERASE   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp35, ptr align 8 %udp, i32 0, i1 false), !tbaa.struct !42
ADD DEFERRED:   %agg.tmp35 = alloca %struct.udp_t, align 8
ADD DEFERRED:   %udp = alloca %struct.udp_t, align 8
ADD:   %udp = alloca %struct.udp_t, align 8
ADD:   %agg.tmp35 = alloca %struct.udp_t, align 8
IC: Visiting:   %agg.tmp35 = alloca %struct.udp_t, align 8
IC: Visiting:   %udp = alloca %struct.udp_t, align 8
IC: ERASE   store i64 %5, ptr %udp, align 8, !tbaa !40
ADD DEFERRED:   %5 = load i64, ptr %ref.tmp34, align 8, !tbaa !40
ADD DEFERRED:   store i64 %5, ptr %agg.tmp35, align 8, !tbaa !40
ADD DEFERRED:   %udp = alloca %struct.udp_t, align 8
IC: ERASE   call void @llvm.lifetime.end.p0(i64 8, ptr %udp) #1
ADD DEFERRED:   call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %udp) #1
IC: ERASE   call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %udp) #1
IC: ERASE   %udp = alloca %struct.udp_t, align 8
ADD:   store i64 %5, ptr %agg.tmp35, align 8, !tbaa !40
ADD:   %5 = load i64, ptr %ref.tmp34, align 8, !tbaa !40
IC: Visiting:   %5 = load i64, ptr %ref.tmp34, align 8, !tbaa !40
IC: Visiting:   store i64 %5, ptr %agg.tmp35, align 8, !tbaa !40
IC: Visiting:   call void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %agg.tmp35), !primate !7
IC: Mod =   call void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %agg.tmp35), !primate !7
    New =   call void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef nonnull byval(%struct.udp_t) align 8 %agg.tmp35), !primate !7
ADD:   call void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef nonnull byval(%struct.udp_t) align 8 %agg.tmp35), !primate !7
IC: Visiting:   call void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef nonnull byval(%struct.udp_t) align 8 %agg.tmp35), !primate !7
IC: Visiting:   br label %if.end38
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 32, ptr %ref.tmp6) #1
IC: Mod =   call void @llvm.lifetime.start.p0(i64 32, ptr %ref.tmp6) #1
    New =   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
ADD:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
IC: Visiting:   call void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind writable sret(%struct.tcp_t) align 8 %ref.tmp6), !primate !7
IC: Mod =   call void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind writable sret(%struct.tcp_t) align 8 %ref.tmp6), !primate !7
    New =   call void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind nonnull writable sret(%struct.tcp_t) align 8 %ref.tmp6), !primate !7
ADD:   call void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind nonnull writable sret(%struct.tcp_t) align 8 %ref.tmp6), !primate !7
IC: Visiting:   call void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind nonnull writable sret(%struct.tcp_t) align 8 %ref.tmp6), !primate !7
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %tcp, ptr align 8 %ref.tmp6, i32 32, i1 false), !tbaa.struct !26
IC: Mod =   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %tcp, ptr align 8 %ref.tmp6, i32 32, i1 false), !tbaa.struct !26
    New =   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !26
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !26
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !26
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 32, ptr %ref.tmp6) #1
IC: Mod =   call void @llvm.lifetime.end.p0(i64 32, ptr %ref.tmp6) #1
    New =   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
ADD:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp7, ptr align 8 %tcp, i32 32, i1 false), !tbaa.struct !26
IC: Mod =   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.tmp7, ptr align 8 %tcp, i32 32, i1 false), !tbaa.struct !26
    New =   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !26
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !26
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !26
IC: Visiting:   call void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %agg.tmp7), !primate !7
IC: Mod =   call void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %agg.tmp7), !primate !7
    New =   call void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef nonnull byval(%struct.tcp_t) align 8 %agg.tmp7), !primate !7
ADD:   call void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef nonnull byval(%struct.tcp_t) align 8 %agg.tmp7), !primate !7
IC: Visiting:   call void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef nonnull byval(%struct.tcp_t) align 8 %agg.tmp7), !primate !7
IC: Visiting:   %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
IC: Visiting:   %2 = load i4, ptr %dataOffset, align 8, !tbaa !33
IC: Visiting:   %conv8 = sext i4 %2 to i32
IC: Visiting:   %cmp9 = icmp sgt i32 %conv8, 0
IC: Old =   %cmp9 = icmp sgt i32 %conv8, 0
    New =   <badref> = icmp sgt i4 %2, 0
ADD:   %cmp9 = icmp sgt i4 %2, 0
IC: ERASE   %3 = icmp sgt i32 %conv8, 0
ADD DEFERRED:   %conv8 = sext i4 %2 to i32
IC: ERASE   %conv8 = sext i4 %2 to i32
ADD DEFERRED:   %2 = load i4, ptr %dataOffset, align 8, !tbaa !33
ADD DEFERRED:   %cmp9 = icmp sgt i4 %2, 0
ADD:   %2 = load i4, ptr %dataOffset, align 8, !tbaa !33
IC: Visiting:   %2 = load i4, ptr %dataOffset, align 8, !tbaa !33
IC: Visiting:   %cmp9 = icmp sgt i4 %2, 0
IC: Visiting:   br i1 %cmp9, label %if.then10, label %if.end38
IC: Visiting:   %3 = load i4, ptr %dataOffset, align 8, !tbaa !33
IC: Visiting:   %conv12 = sext i4 %3 to i32
IC: Visiting:   %sub = sub nsw i32 %conv12, 5
IC: Old =   %sub = sub nsw i32 %conv12, 5
    New =   <badref> = add nsw i32 %conv12, -5
ADD:   %sub = add nsw i32 %conv12, -5
IC: ERASE   %4 = sub nsw i32 %conv12, 5
ADD DEFERRED:   %conv12 = sext i4 %3 to i32
ADD DEFERRED:   %sub = add nsw i32 %conv12, -5
ADD:   %conv12 = sext i4 %3 to i32
IC: Visiting:   %conv12 = sext i4 %3 to i32
IC: Visiting:   %sub = add nsw i32 %conv12, -5
IC: Visiting:   %mul = mul nsw i32 4, %sub
IC: Mod =   %mul = mul nsw i32 4, %sub
    New =   %mul = mul nsw i32 %sub, 4
ADD:   %mul = mul nsw i32 %sub, 4
IC: Visiting:   %mul = mul nsw i32 %sub, 4
IC: Old =   %mul = mul nsw i32 %sub, 4
    New =   <badref> = shl nsw i32 %sub, 2
ADD:   %mul = shl nsw i32 %sub, 2
IC: ERASE   %4 = mul nsw i32 %sub, 4
ADD DEFERRED:   %sub = add nsw i32 %conv12, -5
ADD DEFERRED:   %mul = shl nsw i32 %sub, 2
ADD:   %sub = add nsw i32 %conv12, -5
IC: Visiting:   %sub = add nsw i32 %conv12, -5
IC: Visiting:   %mul = shl nsw i32 %sub, 2
ADD DEFERRED:   %4 = shl i32 %conv12, 2
IC: Old =   %mul = shl nsw i32 %4, 2
    New =   <badref> = add i32 %sub, -20
ADD:   %mul = add i32 %sub, -20
IC: ERASE   %5 = shl nsw i32 %4, 2
ADD DEFERRED:   %4 = add nsw i32 %conv12, -5
IC: ERASE   %4 = add nsw i32 %conv12, -5
ADD DEFERRED:   %conv12 = sext i4 %3 to i32
ADD:   %conv12 = sext i4 %3 to i32
ADD:   %sub = shl i32 %conv12, 2
IC: Visiting:   %sub = shl i32 %conv12, 2
IC: Mod =   %sub = shl i32 %conv12, 2
    New =   %sub = shl nsw i32 %conv12, 2
ADD:   %sub = shl nsw i32 %conv12, 2
IC: Visiting:   %sub = shl nsw i32 %conv12, 2
IC: Visiting:   %conv12 = sext i4 %3 to i32
IC: Visiting:   %mul = add i32 %sub, -20
IC: Mod =   %mul = add i32 %sub, -20
    New =   %mul = add nsw i32 %sub, -20
ADD:   %mul = add nsw i32 %sub, -20
IC: Visiting:   %mul = add nsw i32 %sub, -20
IC: Visiting:   br label %while.cond
IC: Visiting:   %n.0 = phi i32 [ 0, %if.then10 ], [ %n.1, %cleanup ]
IC: Visiting:   %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ]
IC: Visiting:   %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
IC: Visiting:   br i1 %cmp13, label %while.body, label %while.end27
IC: Visiting:   %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
IC: Visiting:   %conv14 = zext i8 %call to i32
IC: Visiting:   %cmp15 = icmp eq i32 %conv14, 0
IC: Old =   %cmp15 = icmp eq i32 %conv14, 0
    New =   <badref> = icmp eq i8 %call, 0
ADD:   %cmp15 = icmp eq i8 %call, 0
IC: ERASE   %4 = icmp eq i32 %conv14, 0
ADD DEFERRED:   %conv14 = zext i8 %call to i32
ADD DEFERRED:   %cmp22 = icmp eq i32 %conv14, 1
ADD:   %conv14 = zext i8 %call to i32
IC: Sink:   %conv14 = zext i8 %call to i32
ADD:   %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
IC: Visiting:   %conv14 = zext i8 %call to i32
IC: Visiting:   %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
IC: Visiting:   %cmp15 = icmp eq i8 %call, 0
IC: Visiting:   br i1 %cmp15, label %if.then16, label %if.else
IC: Visiting:   %cmp22 = icmp eq i32 %conv14, 1
IC: Old =   %cmp22 = icmp eq i32 %conv14, 1
    New =   <badref> = icmp eq i8 %call, 1
ADD:   %cmp22 = icmp eq i8 %call, 1
IC: ERASE   %5 = icmp eq i32 %conv14, 1
ADD DEFERRED:   %conv14 = zext i8 %call to i32
IC: ERASE   %conv14 = zext i8 %call to i32
ADD DEFERRED:   %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
ADD:   %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
IC: Visiting:   %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
IC: Visiting:   %cmp22 = icmp eq i8 %call, 1
IC: Visiting:   br i1 %cmp22, label %if.then23, label %if.end26
IC: Visiting:   %dec25 = add nsw i32 %hdr_byte_left.0, -1
IC: Visiting:   call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %call), !primate !7
IC: Visiting:   br label %if.end26
IC: Visiting:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %if.else ]
IC: Visiting:   %inc = add nsw i32 %n.0, 1
IC: Visiting:   br label %cleanup
IC: Visiting:   %dec = add nsw i32 %hdr_byte_left.0, -1
IC: Visiting:   call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %call), !primate !7
IC: Visiting:   br label %while.cond17
IC: Visiting:   %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
IC: Visiting:   %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
IC: Visiting:   br i1 %cmp18, label %while.body19, label %while.end
IC: Visiting:   br label %cleanup
IC: Visiting:   %cleanup.dest.slot.0 = phi i32 [ 3, %while.end ], [ 0, %if.end26 ]
IC: Visiting:   %n.1 = phi i32 [ %n.0, %while.end ], [ %inc, %if.end26 ]
IC: Visiting:   %hdr_byte_left.3 = phi i32 [ %hdr_byte_left.1, %while.end ], [ %hdr_byte_left.2, %if.end26 ]
IC: Visiting:   switch i32 %cleanup.dest.slot.0, label %unreachable [
    i32 0, label %while.cond
    i32 3, label %while.end27
  ], !llvm.loop !39
IC: Visiting:   br label %if.end38
IC: Visiting:   call void @_ZN7PRIMATE10input_doneEv(), !primate !7
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 32, ptr %tcp) #1
IC: Mod =   call void @llvm.lifetime.end.p0(i64 32, ptr %tcp) #1
    New =   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
ADD:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 40, ptr %ipv4) #1
IC: Mod =   call void @llvm.lifetime.end.p0(i64 40, ptr %ipv4) #1
    New =   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
ADD:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 24, ptr %eth) #1
IC: Mod =   call void @llvm.lifetime.end.p0(i64 24, ptr %eth) #1
    New =   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
ADD:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
IC: Visiting:   ret void
IC: Visiting:   unreachable
IC: Visiting:   call void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind writable sret(i128) align 8 %tmp), !primate !7
IC: Mod =   call void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind writable sret(i128) align 8 %tmp), !primate !7
    New =   call void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind nonnull writable sret(i128) align 8 %tmp), !primate !7
ADD:   call void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind nonnull writable sret(i128) align 8 %tmp), !primate !7
IC: Visiting:   call void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind nonnull writable sret(i128) align 8 %tmp), !primate !7
IC: Visiting:   %4 = load i128, ptr %tmp, align 8, !tbaa !35
IC: Visiting:   store i128 %4, ptr %indirect-arg-temp, align 8, !tbaa !35
IC: Visiting:   call void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %indirect-arg-temp), !primate !7
IC: Mod =   call void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %indirect-arg-temp), !primate !7
    New =   call void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef nonnull byval(i128) align 8 %indirect-arg-temp), !primate !7
ADD:   call void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef nonnull byval(i128) align 8 %indirect-arg-temp), !primate !7
IC: Visiting:   call void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef nonnull byval(i128) align 8 %indirect-arg-temp), !primate !7
IC: Visiting:   %sub20 = sub nsw i32 %hdr_byte_left.1, 16
IC: Old =   %sub20 = sub nsw i32 %hdr_byte_left.1, 16
    New =   <badref> = add nsw i32 %hdr_byte_left.1, -16
ADD:   %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
ADD:   %sub20 = add nsw i32 %hdr_byte_left.1, -16
IC: ERASE   %5 = sub nsw i32 %hdr_byte_left.1, 16
ADD DEFERRED:   %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
IC: Visiting:   %sub20 = add nsw i32 %hdr_byte_left.1, -16
IC: Visiting:   %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
IC: Visiting:   br label %while.cond17, !llvm.loop !37


[IC] Iteration limit #1 on _Z12primate_mainv reached; stopping without verifying fixpoint
; *** IR Dump After InstCombinePass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind nonnull writable sret(%struct.ethernet_t) align 8 %ref.tmp), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
  call void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef nonnull byval(%struct.ethernet_t) align 8 %agg.tmp), !primate !7
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %0 = load i16, ptr %etherType, align 8, !tbaa !15
  %cmp = icmp eq i16 %0, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind nonnull writable sret(%struct.ipv4_t) align 8 %ref.tmp1), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !17
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !17
  call void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef nonnull byval(%struct.ipv4_t) align 8 %agg.tmp2), !primate !7
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %1 = load i8, ptr %protocol, align 8, !tbaa !24
  %cmp4 = icmp eq i8 %1, 6
  br i1 %cmp4, label %if.then5, label %if.else29

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind nonnull writable sret(%struct.tcp_t) align 8 %ref.tmp6), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !26
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !26
  call void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef nonnull byval(%struct.tcp_t) align 8 %agg.tmp7), !primate !7
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %2 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %cmp9 = icmp sgt i4 %2, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %3 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv12 = sext i4 %3 to i32
  %sub = shl nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %n.0 = phi i32 [ 0, %if.then10 ], [ %n.1, %cleanup ]
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %while.end27

while.body:                                       ; preds = %while.cond
  %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
  %cmp15 = icmp eq i8 %call, 0
  br i1 %cmp15, label %if.then16, label %if.else

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %call), !primate !7
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %while.end

while.body19:                                     ; preds = %while.cond17
  call void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind nonnull writable sret(i128) align 8 %tmp), !primate !7
  %4 = load i128, ptr %tmp, align 8, !tbaa !35
  store i128 %4, ptr %indirect-arg-temp, align 8, !tbaa !35
  call void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef nonnull byval(i128) align 8 %indirect-arg-temp), !primate !7
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !37

while.end:                                        ; preds = %while.cond17
  br label %cleanup

if.else:                                          ; preds = %while.body
  %cmp22 = icmp eq i8 %call, 1
  br i1 %cmp22, label %if.then23, label %if.end26

if.then23:                                        ; preds = %if.else
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %call), !primate !7
  br label %if.end26

if.end26:                                         ; preds = %if.else, %if.then23
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %if.else ]
  %inc = add nsw i32 %n.0, 1
  br label %cleanup

cleanup:                                          ; preds = %if.end26, %while.end
  %cleanup.dest.slot.0 = phi i32 [ 3, %while.end ], [ 0, %if.end26 ]
  %n.1 = phi i32 [ %n.0, %while.end ], [ %inc, %if.end26 ]
  %hdr_byte_left.3 = phi i32 [ %hdr_byte_left.1, %while.end ], [ %hdr_byte_left.2, %if.end26 ]
  switch i32 %cleanup.dest.slot.0, label %unreachable [
    i32 0, label %while.cond
    i32 3, label %while.end27
  ], !llvm.loop !39

while.end27:                                      ; preds = %cleanup, %while.cond
  br label %if.end38

if.else29:                                        ; preds = %if.then
  %cmp32 = icmp eq i8 %1, 17
  br i1 %cmp32, label %if.then33, label %if.end38

if.then33:                                        ; preds = %if.else29
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
  call void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind nonnull writable sret(%struct.udp_t) align 8 %ref.tmp34), !primate !7
  %5 = load i64, ptr %ref.tmp34, align 8, !tbaa !40
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
  store i64 %5, ptr %agg.tmp35, align 8, !tbaa !40
  call void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef nonnull byval(%struct.udp_t) align 8 %agg.tmp35), !primate !7
  br label %if.end38

if.end38:                                         ; preds = %while.end27, %if.then5, %if.then33, %if.else29, %entry
  call void @_ZN7PRIMATE10input_doneEv(), !primate !7
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}
Looking to fold while.end into cleanup
Killing Trivial BB: 

while.end:                                        ; preds = %while.cond17
  br label %cleanup
Removing BB: 

if.else:                                          ; No predecessors!
  %cmp22 = icmp eq i8 %call, 1
  br i1 %cmp22, label %if.then23, label %if.end26
SimplifyCFG: switch default is dead.
Looking to fold while.end27 into if.end38
Killing Trivial BB: 

while.end27:                                      ; preds = %cleanup, %while.cond
  br label %if.end38
Removing BB: 

if.else29:                                        ; No predecessors!
  %cmp32 = icmp eq i8 %1, 17
  br i1 %cmp32, label %if.then33, label %if.end38
Removing BB: 

cleanup.unreachabledefault:                       ; No predecessors!
  unreachable
Removing BB: 

unreachable:                                      ; No predecessors!
  unreachable
; *** IR Dump After SimplifyCFGPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind nonnull writable sret(%struct.ethernet_t) align 8 %ref.tmp), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
  call void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef nonnull byval(%struct.ethernet_t) align 8 %agg.tmp), !primate !7
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %0 = load i16, ptr %etherType, align 8, !tbaa !15
  %cmp = icmp eq i16 %0, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind nonnull writable sret(%struct.ipv4_t) align 8 %ref.tmp1), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !17
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !17
  call void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef nonnull byval(%struct.ipv4_t) align 8 %agg.tmp2), !primate !7
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %1 = load i8, ptr %protocol, align 8, !tbaa !24
  switch i8 %1, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind nonnull writable sret(%struct.tcp_t) align 8 %ref.tmp6), !primate !7
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !26
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !26
  call void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef nonnull byval(%struct.tcp_t) align 8 %agg.tmp7), !primate !7
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %2 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %cmp9 = icmp sgt i4 %2, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %3 = load i4, ptr %dataOffset, align 8, !tbaa !33
  %conv12 = sext i4 %3 to i32
  %sub = shl nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %n.0 = phi i32 [ 0, %if.then10 ], [ %n.1, %cleanup ]
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38

while.body:                                       ; preds = %while.cond
  %call = call noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v(), !primate !7
  switch i8 %call, label %if.end26 [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %call), !primate !7
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %cleanup

while.body19:                                     ; preds = %while.cond17
  call void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind nonnull writable sret(i128) align 8 %tmp), !primate !7
  %4 = load i128, ptr %tmp, align 8, !tbaa !35
  store i128 %4, ptr %indirect-arg-temp, align 8, !tbaa !35
  call void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef nonnull byval(i128) align 8 %indirect-arg-temp), !primate !7
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !37

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  call void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %call), !primate !7
  br label %if.end26

if.end26:                                         ; preds = %while.body, %if.then23
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  %inc = add nsw i32 %n.0, 1
  br label %cleanup

cleanup:                                          ; preds = %while.cond17, %if.end26
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end26 ], [ 3, %while.cond17 ]
  %n.1 = phi i32 [ %inc, %if.end26 ], [ %n.0, %while.cond17 ]
  %hdr_byte_left.3 = phi i32 [ %hdr_byte_left.2, %if.end26 ], [ %hdr_byte_left.1, %while.cond17 ]
  %switch = icmp ult i32 %cleanup.dest.slot.0, 1
  br i1 %switch, label %while.cond, label %if.end38

if.then33:                                        ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
  call void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind nonnull writable sret(%struct.udp_t) align 8 %ref.tmp34), !primate !7
  %5 = load i64, ptr %ref.tmp34, align 8, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
  store i64 %5, ptr %agg.tmp35, align 8, !tbaa !39
  call void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef nonnull byval(%struct.udp_t) align 8 %agg.tmp35), !primate !7
  br label %if.end38

if.end38:                                         ; preds = %if.then, %while.cond, %cleanup, %if.then5, %if.then33, %entry
  call void @_ZN7PRIMATE10input_doneEv(), !primate !7
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
; *** IR Dump After PromotePass on _ZN7PRIMATE5inputI10ethernet_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ethernet_t) align 8 %agg.result) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 24, i1 false), !tbaa.struct !8
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE5inputI10ethernet_tEET_v
ADD:   ret void
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 24, i1 false), !tbaa.struct !8
ADD:   %0 = call ptr @llvm.primate.input.p0.i32(i32 24)
IC: Visiting:   %0 = call ptr @llvm.primate.input.p0.i32(i32 24)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 24, i1 false), !tbaa.struct !8
IC: Visiting:   ret void
; *** IR Dump After InstCombinePass on _ZN7PRIMATE5inputI10ethernet_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ethernet_t) align 8 %agg.result) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24)
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.result, ptr noundef nonnull align 8 dereferenceable(24) %0, i32 24, i1 false), !tbaa.struct !8
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE5inputI10ethernet_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI10ethernet_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ethernet_t) align 8 %agg.result) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24)
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.result, ptr noundef nonnull align 8 dereferenceable(24) %0, i32 24, i1 false), !tbaa.struct !8
  ret void
}
; *** IR Dump After PromotePass on _ZN7PRIMATE6outputI10ethernet_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %out) local_unnamed_addr #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 24)
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE6outputI10ethernet_tEEvT_
ADD:   ret void
ADD:   call void @llvm.primate.output.p0.i32(ptr %out, i32 24)
IC: Visiting:   call void @llvm.primate.output.p0.i32(ptr %out, i32 24)
IC: Mod =   call void @llvm.primate.output.p0.i32(ptr %out, i32 24)
    New =   call void @llvm.primate.output.p0.i32(ptr nonnull %out, i32 24)
ADD:   call void @llvm.primate.output.p0.i32(ptr nonnull %out, i32 24)
IC: Visiting:   call void @llvm.primate.output.p0.i32(ptr nonnull %out, i32 24)
IC: Visiting:   ret void


[IC] Iteration limit #1 on _ZN7PRIMATE6outputI10ethernet_tEEvT_ reached; stopping without verifying fixpoint
; *** IR Dump After InstCombinePass on _ZN7PRIMATE6outputI10ethernet_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %out) local_unnamed_addr #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr nonnull %out, i32 24)
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE6outputI10ethernet_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI10ethernet_tEEvT_(ptr noundef byval(%struct.ethernet_t) align 8 %out) local_unnamed_addr #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr nonnull %out, i32 24)
  ret void
}
; *** IR Dump After PromotePass on _ZN7PRIMATE5inputI6ipv4_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ipv4_t) align 8 %agg.result) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 40)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 40, i1 false), !tbaa.struct !17
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE5inputI6ipv4_tEET_v
ADD:   ret void
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 40, i1 false), !tbaa.struct !8
ADD:   %0 = call ptr @llvm.primate.input.p0.i32(i32 40)
IC: Visiting:   %0 = call ptr @llvm.primate.input.p0.i32(i32 40)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 40, i1 false), !tbaa.struct !8
IC: Visiting:   ret void
; *** IR Dump After InstCombinePass on _ZN7PRIMATE5inputI6ipv4_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ipv4_t) align 8 %agg.result) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 40)
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.result, ptr noundef nonnull align 8 dereferenceable(40) %0, i32 40, i1 false), !tbaa.struct !17
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE5inputI6ipv4_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI6ipv4_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.ipv4_t) align 8 %agg.result) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 40)
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.result, ptr noundef nonnull align 8 dereferenceable(40) %0, i32 40, i1 false), !tbaa.struct !17
  ret void
}
; *** IR Dump After PromotePass on _ZN7PRIMATE6outputI6ipv4_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %out) local_unnamed_addr #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 40)
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE6outputI6ipv4_tEEvT_
ADD:   ret void
ADD:   call void @llvm.primate.output.p0.i32(ptr %out, i32 40)
IC: Visiting:   call void @llvm.primate.output.p0.i32(ptr %out, i32 40)
IC: Mod =   call void @llvm.primate.output.p0.i32(ptr %out, i32 40)
    New =   call void @llvm.primate.output.p0.i32(ptr nonnull %out, i32 40)
ADD:   call void @llvm.primate.output.p0.i32(ptr nonnull %out, i32 40)
IC: Visiting:   call void @llvm.primate.output.p0.i32(ptr nonnull %out, i32 40)
IC: Visiting:   ret void


[IC] Iteration limit #1 on _ZN7PRIMATE6outputI6ipv4_tEEvT_ reached; stopping without verifying fixpoint
; *** IR Dump After InstCombinePass on _ZN7PRIMATE6outputI6ipv4_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %out) local_unnamed_addr #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr nonnull %out, i32 40)
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE6outputI6ipv4_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI6ipv4_tEEvT_(ptr noundef byval(%struct.ipv4_t) align 8 %out) local_unnamed_addr #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr nonnull %out, i32 40)
  ret void
}
; *** IR Dump After PromotePass on _ZN7PRIMATE5inputI5tcp_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.tcp_t) align 8 %agg.result) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 32)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 32, i1 false), !tbaa.struct !26
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE5inputI5tcp_tEET_v
ADD:   ret void
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 32, i1 false), !tbaa.struct !8
ADD:   %0 = call ptr @llvm.primate.input.p0.i32(i32 32)
IC: Visiting:   %0 = call ptr @llvm.primate.input.p0.i32(i32 32)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 32, i1 false), !tbaa.struct !8
IC: Visiting:   ret void
; *** IR Dump After InstCombinePass on _ZN7PRIMATE5inputI5tcp_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.tcp_t) align 8 %agg.result) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 32)
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %0, i32 32, i1 false), !tbaa.struct !26
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE5inputI5tcp_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5tcp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.tcp_t) align 8 %agg.result) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 32)
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.result, ptr noundef nonnull align 8 dereferenceable(32) %0, i32 32, i1 false), !tbaa.struct !26
  ret void
}
; *** IR Dump After PromotePass on _ZN7PRIMATE6outputI5tcp_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %out) local_unnamed_addr #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 32)
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE6outputI5tcp_tEEvT_
ADD:   ret void
ADD:   call void @llvm.primate.output.p0.i32(ptr %out, i32 32)
IC: Visiting:   call void @llvm.primate.output.p0.i32(ptr %out, i32 32)
IC: Mod =   call void @llvm.primate.output.p0.i32(ptr %out, i32 32)
    New =   call void @llvm.primate.output.p0.i32(ptr nonnull %out, i32 32)
ADD:   call void @llvm.primate.output.p0.i32(ptr nonnull %out, i32 32)
IC: Visiting:   call void @llvm.primate.output.p0.i32(ptr nonnull %out, i32 32)
IC: Visiting:   ret void


[IC] Iteration limit #1 on _ZN7PRIMATE6outputI5tcp_tEEvT_ reached; stopping without verifying fixpoint
; *** IR Dump After InstCombinePass on _ZN7PRIMATE6outputI5tcp_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %out) local_unnamed_addr #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr nonnull %out, i32 32)
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE6outputI5tcp_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5tcp_tEEvT_(ptr noundef byval(%struct.tcp_t) align 8 %out) local_unnamed_addr #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr nonnull %out, i32 32)
  ret void
}
; *** IR Dump After PromotePass on _ZN7PRIMATE5inputIDU8_EET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v() local_unnamed_addr #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %1 = load i8, ptr %0, align 1, !tbaa !20
  ret i8 %1
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE5inputIDU8_EET_v
ADD:   ret i8 %1
ADD:   %1 = load i8, ptr %0, align 1, !tbaa !8
ADD:   %0 = call ptr @llvm.primate.input.p0.i32(i32 1)
IC: Visiting:   %0 = call ptr @llvm.primate.input.p0.i32(i32 1)
IC: Visiting:   %1 = load i8, ptr %0, align 1, !tbaa !8
IC: Visiting:   ret i8 %1
; *** IR Dump After InstCombinePass on _ZN7PRIMATE5inputIDU8_EET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v() local_unnamed_addr #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %1 = load i8, ptr %0, align 1, !tbaa !20
  ret i8 %1
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE5inputIDU8_EET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local noundef zeroext i8 @_ZN7PRIMATE5inputIDU8_EET_v() local_unnamed_addr #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %1 = load i8, ptr %0, align 1, !tbaa !20
  ret i8 %1
}
; *** IR Dump After PromotePass on _ZN7PRIMATE6outputIDU8_EEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %out) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %out.addr = alloca i8, align 1
  store i8 %out, ptr %out.addr, align 1, !tbaa !20
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 1)
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE6outputIDU8_EEvT_
ADD:   ret void
ADD:   call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 1)
ADD:   store i8 %out, ptr %out.addr, align 1, !tbaa !8
ADD:   %out.addr = alloca i8, align 1
IC: Visiting:   %out.addr = alloca i8, align 1
IC: Visiting:   store i8 %out, ptr %out.addr, align 1, !tbaa !8
IC: Visiting:   call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 1)
IC: Mod =   call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 1)
    New =   call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr, i32 1)
ADD:   call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr, i32 1)
IC: Visiting:   call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr, i32 1)
IC: Visiting:   ret void


[IC] Iteration limit #1 on _ZN7PRIMATE6outputIDU8_EEvT_ reached; stopping without verifying fixpoint
; *** IR Dump After InstCombinePass on _ZN7PRIMATE6outputIDU8_EEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %out) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %out.addr = alloca i8, align 1
  store i8 %out, ptr %out.addr, align 1, !tbaa !20
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr, i32 1)
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE6outputIDU8_EEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU8_EEvT_(i8 noundef zeroext %out) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %out.addr = alloca i8, align 1
  store i8 %out, ptr %out.addr, align 1, !tbaa !20
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr, i32 1)
  ret void
}
; *** IR Dump After PromotePass on _ZN7PRIMATE5inputIDU128_EET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind noalias writable sret(i128) align 8 %agg.result) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 16)
  %1 = load i128, ptr %0, align 8, !tbaa !35
  store i128 %1, ptr %agg.result, align 8, !tbaa !35
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE5inputIDU128_EET_v
ADD:   ret void
ADD:   store i128 %1, ptr %agg.result, align 8, !tbaa !8
ADD:   %1 = load i128, ptr %0, align 8, !tbaa !8
ADD:   %0 = call ptr @llvm.primate.input.p0.i32(i32 16)
IC: Visiting:   %0 = call ptr @llvm.primate.input.p0.i32(i32 16)
IC: Visiting:   %1 = load i128, ptr %0, align 8, !tbaa !8
IC: Visiting:   store i128 %1, ptr %agg.result, align 8, !tbaa !8
IC: Visiting:   ret void
; *** IR Dump After InstCombinePass on _ZN7PRIMATE5inputIDU128_EET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind noalias writable sret(i128) align 8 %agg.result) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 16)
  %1 = load i128, ptr %0, align 8, !tbaa !35
  store i128 %1, ptr %agg.result, align 8, !tbaa !35
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE5inputIDU128_EET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputIDU128_EET_v(ptr dead_on_unwind noalias writable sret(i128) align 8 %agg.result) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 16)
  %1 = load i128, ptr %0, align 8, !tbaa !35
  store i128 %1, ptr %agg.result, align 8, !tbaa !35
  ret void
}
; *** IR Dump After PromotePass on _ZN7PRIMATE6outputIDU128_EEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %0) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %out.addr = alloca i128, align 8
  %out = load i128, ptr %0, align 8, !tbaa !35
  store i128 %out, ptr %out.addr, align 8, !tbaa !35
  call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 16)
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE6outputIDU128_EEvT_
ADD:   ret void
ADD:   call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 16)
ADD:   store i128 %out, ptr %out.addr, align 8, !tbaa !8
ADD:   %out = load i128, ptr %0, align 8, !tbaa !8
ADD:   %out.addr = alloca i128, align 8
IC: Visiting:   %out.addr = alloca i128, align 8
IC: Visiting:   %out = load i128, ptr %0, align 8, !tbaa !8
IC: Visiting:   store i128 %out, ptr %out.addr, align 8, !tbaa !8
IC: Visiting:   call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 16)
IC: Mod =   call void @llvm.primate.output.p0.i32(ptr %out.addr, i32 16)
    New =   call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr, i32 16)
ADD:   call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr, i32 16)
IC: Visiting:   call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr, i32 16)
IC: Visiting:   ret void


[IC] Iteration limit #1 on _ZN7PRIMATE6outputIDU128_EEvT_ reached; stopping without verifying fixpoint
; *** IR Dump After InstCombinePass on _ZN7PRIMATE6outputIDU128_EEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %0) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %out.addr = alloca i128, align 8
  %out = load i128, ptr %0, align 8, !tbaa !35
  store i128 %out, ptr %out.addr, align 8, !tbaa !35
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr, i32 16)
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE6outputIDU128_EEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputIDU128_EEvT_(ptr noundef byval(i128) align 8 %0) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %out.addr = alloca i128, align 8
  %out = load i128, ptr %0, align 8, !tbaa !35
  store i128 %out, ptr %out.addr, align 8, !tbaa !35
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr, i32 16)
  ret void
}
; *** IR Dump After PromotePass on _ZN7PRIMATE5inputI5udp_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.udp_t) align 8 %agg.result) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 8)
  call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 8, i1 false), !tbaa.struct !41
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE5inputI5udp_tEET_v
ADD:   ret void
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 8, i1 false), !tbaa.struct !8
ADD:   %0 = call ptr @llvm.primate.input.p0.i32(i32 8)
IC: Visiting:   %0 = call ptr @llvm.primate.input.p0.i32(i32 8)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 8, i1 false), !tbaa.struct !8
ADD DEFERRED:   %1 = load i64, ptr %0, align 8
ADD DEFERRED:   store i64 %1, ptr %agg.result, align 8
IC: Mod =   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 8, i1 false), !tbaa.struct !8
    New =   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 0, i1 false), !tbaa.struct !12
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 0, i1 false), !tbaa.struct !12
ADD:   store i64 %1, ptr %agg.result, align 8, !tbaa !8
ADD:   %1 = load i64, ptr %0, align 8, !tbaa !8
IC: Visiting:   %1 = load i64, ptr %0, align 8, !tbaa !8
IC: Visiting:   store i64 %1, ptr %agg.result, align 8, !tbaa !8
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 0, i1 false), !tbaa.struct !12
IC: ERASE   call void @llvm.memcpy.p0.p0.i32(ptr align 8 %agg.result, ptr align 8 %0, i32 0, i1 false), !tbaa.struct !12
ADD DEFERRED:   %0 = call ptr @llvm.primate.input.p0.i32(i32 8)
ADD DEFERRED:   %1 = load i64, ptr %0, align 8, !tbaa !8
ADD:   %1 = load i64, ptr %0, align 8, !tbaa !8
ADD:   %0 = call ptr @llvm.primate.input.p0.i32(i32 8)
IC: Visiting:   %0 = call ptr @llvm.primate.input.p0.i32(i32 8)
IC: Visiting:   %1 = load i64, ptr %0, align 8, !tbaa !8
IC: Visiting:   ret void


[IC] Iteration limit #1 on _ZN7PRIMATE5inputI5udp_tEET_v reached; stopping without verifying fixpoint
; *** IR Dump After InstCombinePass on _ZN7PRIMATE5inputI5udp_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.udp_t) align 8 %agg.result) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 8)
  %1 = load i64, ptr %0, align 8, !tbaa !39
  store i64 %1, ptr %agg.result, align 8, !tbaa !39
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE5inputI5udp_tEET_v ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE5inputI5udp_tEET_v(ptr dead_on_unwind noalias writable sret(%struct.udp_t) align 8 %agg.result) local_unnamed_addr #0 comdat !primate !7 {
entry:
  %0 = call ptr @llvm.primate.input.p0.i32(i32 8)
  %1 = load i64, ptr %0, align 8, !tbaa !39
  store i64 %1, ptr %agg.result, align 8, !tbaa !39
  ret void
}
; *** IR Dump After PromotePass on _ZN7PRIMATE6outputI5udp_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %out) local_unnamed_addr #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr %out, i32 8)
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE6outputI5udp_tEEvT_
ADD:   ret void
ADD:   call void @llvm.primate.output.p0.i32(ptr %out, i32 8)
IC: Visiting:   call void @llvm.primate.output.p0.i32(ptr %out, i32 8)
IC: Mod =   call void @llvm.primate.output.p0.i32(ptr %out, i32 8)
    New =   call void @llvm.primate.output.p0.i32(ptr nonnull %out, i32 8)
ADD:   call void @llvm.primate.output.p0.i32(ptr nonnull %out, i32 8)
IC: Visiting:   call void @llvm.primate.output.p0.i32(ptr nonnull %out, i32 8)
IC: Visiting:   ret void


[IC] Iteration limit #1 on _ZN7PRIMATE6outputI5udp_tEEvT_ reached; stopping without verifying fixpoint
; *** IR Dump After InstCombinePass on _ZN7PRIMATE6outputI5udp_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %out) local_unnamed_addr #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr nonnull %out, i32 8)
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE6outputI5udp_tEEvT_ ***
; Function Attrs: alwaysinline mustprogress nounwind
define linkonce_odr dso_local void @_ZN7PRIMATE6outputI5udp_tEEvT_(ptr noundef byval(%struct.udp_t) align 8 %out) local_unnamed_addr #0 comdat !primate !7 {
entry:
  call void @llvm.primate.output.p0.i32(ptr nonnull %out, i32 8)
  ret void
}
		Looking for trivial roots
Found a new trivial root: %if.end38
Last visited node: %while.body19
		Looking for non-trivial roots
Total: 14, Num: 15
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %if.end38
3: %entry
4: %if.then33
5: %if.then
6: %if.then5
7: %cleanup
8: %if.end26
9: %if.then23
10: %while.body
11: %while.cond
12: %if.then10
13: %while.cond17
14: %if.then16
15: %while.body19
Found roots: %if.end38 
---- Branch Probability Info : _Z12primate_mainv ----

BPI: SCC 1: if.then23 while.body19 while.cond17 if.then16 cleanup if.end26 while.body while.cond
Computing probabilities for if.end38
Computing probabilities for cleanup
eraseBlock cleanup
set edge cleanup -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge cleanup -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for if.end26
Computing probabilities for while.body19
Computing probabilities for while.cond17
eraseBlock while.cond17
set edge while.cond17 -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge while.cond17 -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for if.then16
Computing probabilities for if.then23
Computing probabilities for while.body
Computing probabilities for while.cond
eraseBlock while.cond
set edge while.cond -> 0 successor probability to 0x7c000000 / 0x80000000 = 96.88%
set edge while.cond -> 1 successor probability to 0x04000000 / 0x80000000 = 3.12%
Computing probabilities for if.then10
Computing probabilities for if.then5
eraseBlock if.then5
set edge if.then5 -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge if.then5 -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%
Computing probabilities for if.then33
Computing probabilities for if.then
Computing probabilities for entry

block-frequency: _Z12primate_mainv
==================================
reverse-post-order-traversal
 - 0: entry
 - 1: if.then
 - 2: if.then33
 - 3: if.then5
 - 4: if.then10
 - 5: while.cond
 - 6: while.body
 - 7: if.then23
 - 8: if.then16
 - 9: while.cond17
 - 10: while.body19
 - 11: if.end26
 - 12: cleanup
 - 13: if.end38
loop-detection
 - loop = while.cond
 - loop = while.cond17
 - loop = while.cond: member = while.body
 - loop = while.cond: member = if.then23
 - loop = while.cond: member = if.then16
 - loop = while.cond17: member = while.body19
 - loop = while.cond: member = if.end26
 - loop = while.cond: member = cleanup
compute-mass-in-loop: while.cond17*
 - node: while.cond17
  => [ local  ] weight = 2080374784, succ = while.body19
  => [  exit  ] weight = 67108864, succ = cleanup
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) to while.body19
  => assign 0800000000000000 (0000000000000000) [exit] to cleanup
 - node: while.body19
  => [backedge] weight = 2147483648
  => mass:  f7ffffffffffffff
  => assign f7ffffffffffffff (0000000000000000) [back] to while.cond17
compute-loop-scale: while.cond17*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: while.cond17*
 - node: while.cond17
 - node: while.body19
compute-mass-in-loop: while.cond*
 - node: while.cond
  => [ local  ] weight = 2080374784, succ = while.body
  => [  exit  ] weight = 67108864, succ = if.end38
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) to while.body
  => assign 0800000000000000 (0000000000000000) [exit] to if.end38
 - node: while.body
  => [ local  ] weight = 715827883, succ = if.end26
  => [ local  ] weight = 715827883, succ = if.then16
  => [ local  ] weight = 715827883, succ = if.then23
  => mass:  f7ffffffffffffff
  => assign 52aaaaab4fffffff (a5555554b0000000) to if.then23
  => assign 52aaaaaa58000000 (52aaaaaa58000000) to if.then16
  => assign 52aaaaaa58000000 (0000000000000000) to if.end26
 - node: if.then23
  => [ local  ] weight = 2147483648, succ = if.end26
  => mass:  52aaaaab4fffffff
  => assign 52aaaaab4fffffff (0000000000000000) to if.end26
 - node: if.then16
  => [ local  ] weight = 2147483648, succ = while.cond17
  => mass:  52aaaaaa58000000
  => assign 52aaaaaa58000000 (0000000000000000) to while.cond17
 - node: while.cond17
  => [ local  ] weight = 576460752303423488, succ = cleanup
  => mass:  52aaaaaa58000000
  => assign 52aaaaaa58000000 (0000000000000000) to cleanup
 - node: if.end26
  => [ local  ] weight = 2147483648, succ = cleanup
  => mass:  a5555555a7ffffff
  => assign a5555555a7ffffff (0000000000000000) to cleanup
 - node: cleanup
  => [backedge] weight = 2080374784
  => [  exit  ] weight = 67108864, succ = if.end38
  => mass:  f7ffffffffffffff
  => assign f03fffffffffffff (07c0000000000000) [back] to while.cond
  => assign 07c0000000000000 (0000000000000000) [exit] to if.end38
compute-loop-scale: while.cond*
 - exit-mass = 0fc0000000000000 (ffffffffffffffff - f03fffffffffffff)
 - scale = 16.25396825
packaging-loop: while.cond*
 - node: while.cond
 - node: while.body
 - node: if.then23
 - node: if.then16
 - node: while.cond17
 - node: if.end26
 - node: cleanup
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 1073741824, succ = if.then
  => [ local  ] weight = 1073741824, succ = if.end38
  => mass:  ffffffffffffffff
  => assign 7fffffffffffffff (8000000000000000) to if.then
  => assign 8000000000000000 (0000000000000000) to if.end38
 - node: if.then
  => [ local  ] weight = 715827883, succ = if.end38
  => [ local  ] weight = 715827883, succ = if.then5
  => [ local  ] weight = 715827883, succ = if.then33
  => mass:  7fffffffffffffff
  => assign 2aaaaaaaffffffff (5555555500000000) to if.then33
  => assign 2aaaaaaa80000000 (2aaaaaaa80000000) to if.then5
  => assign 2aaaaaaa80000000 (0000000000000000) to if.end38
 - node: if.then33
  => [ local  ] weight = 2147483648, succ = if.end38
  => mass:  2aaaaaaaffffffff
  => assign 2aaaaaaaffffffff (0000000000000000) to if.end38
 - node: if.then5
  => [ local  ] weight = 1342177280, succ = if.then10
  => [ local  ] weight = 805306368, succ = if.end38
  => mass:  2aaaaaaa80000000
  => assign 1aaaaaaa90000000 (0ffffffff0000000) to if.then10
  => assign 0ffffffff0000000 (0000000000000000) to if.end38
 - node: if.then10
  => [ local  ] weight = 2147483648, succ = while.cond
  => mass:  1aaaaaaa90000000
  => assign 1aaaaaaa90000000 (0000000000000000) to while.cond
 - node: while.cond
  => [ local  ] weight = 576460752303423488, succ = if.end38
  => [ local  ] weight = 558446353793941504, succ = if.end38
  => mass:  1aaaaaaa90000000
  => assign 1aaaaaaa90000000 (0000000000000000) to if.end38
 - node: if.end38
  => mass:  ffffffffffffffff
unwrap-loop-package: while.cond*: mass = 1aaaaaaa90000000, scale = 16.25396825
  => combined-scale = 1.693121693
 - while.cond: 1.0 => 1.693121693
 - while.body: 0.96875 => 1.64021164
 - if.then23: 0.3229166668 => 0.5467372135
 - if.then16: 0.3229166666 => 0.5467372131
 - while.cond17: 32.0 => 54.17989417
 - if.end26: 0.6458333334 => 1.093474427
 - cleanup: 0.96875 => 1.64021164
unwrap-loop-package: while.cond17*: mass = 52aaaaaa58000000, scale = 54.17989417
  => combined-scale = 17.49559082
 - while.cond17: 1.0 => 17.49559082
 - while.body19: 0.96875 => 16.94885361
float-to-int: min = 0.1041666666, max = 17.49559082, factor = 1029653624962966.3
 - entry: float = 1.0, scaled = 1029653624962966.3, int = 1029653624962966
 - if.then: float = 0.5, scaled = 514826812481483.1, int = 514826812481483
 - if.then33: float = 0.1666666667, scaled = 171608937573739.4, int = 171608937573739
 - if.then5: float = 0.1666666666, scaled = 171608937453871.9, int = 171608937453871
 - if.then10: float = 0.1041666666, scaled = 107255585908669.9, int = 107255585908669
 - while.cond: float = 1.693121693, scaled = 1743328888420285.9, int = 1743328888420285
 - while.body: float = 1.64021164, scaled = 1688849860657152.0, int = 1688849860657152
 - if.then23: float = 0.5467372135, scaled = 562949953814528.0, int = 562949953814528
 - if.then16: float = 0.5467372131, scaled = 562949953421312.0, int = 562949953421312
 - while.cond17: float = 17.49559082, scaled = 18014398509481984.0, int = 18014398509481984
 - while.body19: float = 16.94885361, scaled = 17451448556060672.0, int = 17451448556060671
 - if.end26: float = 1.093474427, scaled = 1125899907235840.0, int = 1125899907235840
 - cleanup: float = 1.64021164, scaled = 1688849860657152.0, int = 1688849860657152
 - if.end38: float = 1.0, scaled = 1029653624962966.3, int = 1029653624962966
block-frequency-info: _Z12primate_mainv
 - entry: float = 1.0, int = 1029653624962966
 - if.then: float = 0.5, int = 514826812481483
 - if.then5: float = 0.16667, int = 171608937453871
 - if.then10: float = 0.10417, int = 107255585908669
 - while.cond: float = 1.6931, int = 1743328888420285
 - while.body: float = 1.6402, int = 1688849860657152
 - if.then16: float = 0.54674, int = 562949953421312
 - while.cond17: float = 17.496, int = 18014398509481984
 - while.body19: float = 16.949, int = 17451448556060671
 - if.then23: float = 0.54674, int = 562949953814528
 - if.end26: float = 1.0935, int = 1125899907235840
 - cleanup: float = 1.6402, int = 1688849860657152
 - if.then33: float = 0.16667, int = 171608937573739
 - if.end38: float = 1.0, int = 1029653624962966

		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZN7PRIMATE10input_doneEv ----

Computing probabilities for entry

block-frequency: _ZN7PRIMATE10input_doneEv
==========================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 18014398509481984.0
 - entry: float = 1.0, scaled = 18014398509481984.0, int = 18014398509481984
block-frequency-info: _ZN7PRIMATE10input_doneEv
 - entry: float = 1.0, int = 18014398509481984

		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZN7PRIMATE5inputI10ethernet_tEET_v ----

Computing probabilities for entry

block-frequency: _ZN7PRIMATE5inputI10ethernet_tEET_v
====================================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 18014398509481984.0
 - entry: float = 1.0, scaled = 18014398509481984.0, int = 18014398509481984
block-frequency-info: _ZN7PRIMATE5inputI10ethernet_tEET_v
 - entry: float = 1.0, int = 18014398509481984

		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZN7PRIMATE6outputI10ethernet_tEEvT_ ----

Computing probabilities for entry

block-frequency: _ZN7PRIMATE6outputI10ethernet_tEEvT_
=====================================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 18014398509481984.0
 - entry: float = 1.0, scaled = 18014398509481984.0, int = 18014398509481984
block-frequency-info: _ZN7PRIMATE6outputI10ethernet_tEEvT_
 - entry: float = 1.0, int = 18014398509481984

		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZN7PRIMATE5inputI6ipv4_tEET_v ----

Computing probabilities for entry

block-frequency: _ZN7PRIMATE5inputI6ipv4_tEET_v
===============================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 18014398509481984.0
 - entry: float = 1.0, scaled = 18014398509481984.0, int = 18014398509481984
block-frequency-info: _ZN7PRIMATE5inputI6ipv4_tEET_v
 - entry: float = 1.0, int = 18014398509481984

		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZN7PRIMATE6outputI6ipv4_tEEvT_ ----

Computing probabilities for entry

block-frequency: _ZN7PRIMATE6outputI6ipv4_tEEvT_
================================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 18014398509481984.0
 - entry: float = 1.0, scaled = 18014398509481984.0, int = 18014398509481984
block-frequency-info: _ZN7PRIMATE6outputI6ipv4_tEEvT_
 - entry: float = 1.0, int = 18014398509481984

		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZN7PRIMATE5inputI5tcp_tEET_v ----

Computing probabilities for entry

block-frequency: _ZN7PRIMATE5inputI5tcp_tEET_v
==============================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 18014398509481984.0
 - entry: float = 1.0, scaled = 18014398509481984.0, int = 18014398509481984
block-frequency-info: _ZN7PRIMATE5inputI5tcp_tEET_v
 - entry: float = 1.0, int = 18014398509481984

		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZN7PRIMATE6outputI5tcp_tEEvT_ ----

Computing probabilities for entry

block-frequency: _ZN7PRIMATE6outputI5tcp_tEEvT_
===============================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 18014398509481984.0
 - entry: float = 1.0, scaled = 18014398509481984.0, int = 18014398509481984
block-frequency-info: _ZN7PRIMATE6outputI5tcp_tEEvT_
 - entry: float = 1.0, int = 18014398509481984

		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZN7PRIMATE5inputIDU8_EET_v ----

Computing probabilities for entry

block-frequency: _ZN7PRIMATE5inputIDU8_EET_v
============================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 18014398509481984.0
 - entry: float = 1.0, scaled = 18014398509481984.0, int = 18014398509481984
block-frequency-info: _ZN7PRIMATE5inputIDU8_EET_v
 - entry: float = 1.0, int = 18014398509481984

		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZN7PRIMATE6outputIDU8_EEvT_ ----

Computing probabilities for entry

block-frequency: _ZN7PRIMATE6outputIDU8_EEvT_
=============================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 18014398509481984.0
 - entry: float = 1.0, scaled = 18014398509481984.0, int = 18014398509481984
block-frequency-info: _ZN7PRIMATE6outputIDU8_EEvT_
 - entry: float = 1.0, int = 18014398509481984

		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZN7PRIMATE5inputIDU128_EET_v ----

Computing probabilities for entry

block-frequency: _ZN7PRIMATE5inputIDU128_EET_v
==============================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 18014398509481984.0
 - entry: float = 1.0, scaled = 18014398509481984.0, int = 18014398509481984
block-frequency-info: _ZN7PRIMATE5inputIDU128_EET_v
 - entry: float = 1.0, int = 18014398509481984

		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZN7PRIMATE6outputIDU128_EEvT_ ----

Computing probabilities for entry

block-frequency: _ZN7PRIMATE6outputIDU128_EEvT_
===============================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 18014398509481984.0
 - entry: float = 1.0, scaled = 18014398509481984.0, int = 18014398509481984
block-frequency-info: _ZN7PRIMATE6outputIDU128_EEvT_
 - entry: float = 1.0, int = 18014398509481984

		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZN7PRIMATE5inputI5udp_tEET_v ----

Computing probabilities for entry

block-frequency: _ZN7PRIMATE5inputI5udp_tEET_v
==============================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 18014398509481984.0
 - entry: float = 1.0, scaled = 18014398509481984.0, int = 18014398509481984
block-frequency-info: _ZN7PRIMATE5inputI5udp_tEET_v
 - entry: float = 1.0, int = 18014398509481984

		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : _ZN7PRIMATE6outputI5udp_tEEvT_ ----

Computing probabilities for entry

block-frequency: _ZN7PRIMATE6outputI5udp_tEEvT_
===============================================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 18014398509481984.0
 - entry: float = 1.0, scaled = 18014398509481984.0, int = 18014398509481984
block-frequency-info: _ZN7PRIMATE6outputI5udp_tEEvT_
 - entry: float = 1.0, int = 18014398509481984

; *** IR Dump After AlwaysInlinerPass on [module] ***
; ModuleID = 'tcp_parse.cpp'
source_filename = "tcp_parse.cpp"
target datalayout = "e-G1-m:e-p:32:32-i64:64-n32-S128"
target triple = "primate32-unknown-linux-gnu"

%struct.udp_t = type { i64 }
%struct.tcp_t = type { i96, i4, i60 }
%struct.ipv4_t = type { i72, i8, i80 }
%struct.ethernet_t = type { i48, i48, i16 }

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.done() #1

; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %agg.tmp3545 = alloca %struct.udp_t, align 8
  %out.addr.i44 = alloca i128, align 8
  %indirect-arg-temp43 = alloca i128, align 8
  %out.addr.i42 = alloca i8, align 1
  %out.addr.i = alloca i8, align 1
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !8)
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24), !noalias !8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, ptr noundef nonnull align 8 dereferenceable(24) %0, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.lifetime.start.p0(i64 24, ptr %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp39, ptr align 1 %agg.tmp, i64 24, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp39, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr %agg.tmp39)
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %1 = load i16, ptr %etherType, align 8, !tbaa !18
  %cmp = icmp eq i16 %1, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !20)
  %2 = call ptr @llvm.primate.input.p0.i32(i32 40), !noalias !20
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, ptr noundef nonnull align 8 dereferenceable(40) %2, i32 40, i1 false), !tbaa.struct !23
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !23
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !23
  call void @llvm.lifetime.start.p0(i64 40, ptr %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp240, ptr align 1 %agg.tmp2, i64 40, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp240, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr %agg.tmp240)
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %3 = load i8, ptr %protocol, align 8, !tbaa !30
  switch i8 %3, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !32)
  %4 = call ptr @llvm.primate.input.p0.i32(i32 32), !noalias !32
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, ptr noundef nonnull align 8 dereferenceable(32) %4, i32 32, i1 false), !tbaa.struct !35
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !35
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !35
  call void @llvm.lifetime.start.p0(i64 32, ptr %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp741, ptr align 1 %agg.tmp7, i64 32, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp741, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr %agg.tmp741)
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %5 = load i4, ptr %dataOffset, align 8, !tbaa !42
  %cmp9 = icmp sgt i4 %5, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %6 = load i4, ptr %dataOffset, align 8, !tbaa !42
  %conv12 = sext i4 %6 to i32
  %sub = shl nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %n.0 = phi i32 [ 0, %if.then10 ], [ %n.1, %cleanup ]
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38

while.body:                                       ; preds = %while.cond
  %7 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %8 = load i8, ptr %7, align 1, !tbaa !26
  switch i8 %8, label %if.end26 [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i42)
  store i8 %8, ptr %out.addr.i42, align 1, !tbaa !26
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i42, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i42)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %cleanup

while.body19:                                     ; preds = %while.cond17
  call void @llvm.experimental.noalias.scope.decl(metadata !44)
  %9 = call ptr @llvm.primate.input.p0.i32(i32 16), !noalias !44
  %10 = load i128, ptr %9, align 8, !tbaa !47, !noalias !44
  store i128 %10, ptr %tmp, align 8, !tbaa !47, !alias.scope !44
  %11 = load i128, ptr %tmp, align 8, !tbaa !47
  store i128 %11, ptr %indirect-arg-temp, align 8, !tbaa !47
  call void @llvm.lifetime.start.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.start.p0(i64 16, ptr %out.addr.i44)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %indirect-arg-temp43, ptr align 1 %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !47
  store i128 %out.i, ptr %out.addr.i44, align 8, !tbaa !47
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i44, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.end.p0(i64 16, ptr %out.addr.i44)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !49

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i)
  store i8 %8, ptr %out.addr.i, align 1, !tbaa !26
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i)
  br label %if.end26

if.end26:                                         ; preds = %while.body, %if.then23
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  %inc = add nsw i32 %n.0, 1
  br label %cleanup

cleanup:                                          ; preds = %while.cond17, %if.end26
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end26 ], [ 3, %while.cond17 ]
  %n.1 = phi i32 [ %inc, %if.end26 ], [ %n.0, %while.cond17 ]
  %hdr_byte_left.3 = phi i32 [ %hdr_byte_left.2, %if.end26 ], [ %hdr_byte_left.1, %while.cond17 ]
  %switch = icmp ult i32 %cleanup.dest.slot.0, 1
  br i1 %switch, label %while.cond, label %if.end38

if.then33:                                        ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !51)
  %12 = call ptr @llvm.primate.input.p0.i32(i32 8), !noalias !51
  %13 = load i64, ptr %12, align 8, !tbaa !54, !noalias !51
  store i64 %13, ptr %ref.tmp34, align 8, !tbaa !54, !alias.scope !51
  %14 = load i64, ptr %ref.tmp34, align 8, !tbaa !54
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
  store i64 %14, ptr %agg.tmp35, align 8, !tbaa !54
  call void @llvm.lifetime.start.p0(i64 8, ptr %agg.tmp3545)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp3545, ptr align 1 %agg.tmp35, i64 8, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp3545, i32 8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %agg.tmp3545)
  br label %if.end38

if.end38:                                         ; preds = %if.then, %while.cond, %cleanup, %if.then5, %if.then33, %entry
  call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i32(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i32, i1 immarg) #4

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: nounwind
declare !primate !7 ptr @llvm.primate.input.p0.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.p0.i32(ptr, i32) #1

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite)
declare void @llvm.experimental.noalias.scope.decl(metadata) #5

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #6

attributes #0 = { alwaysinline mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #1 = { nounwind }
attributes #2 = { mustprogress "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #3 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #5 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite) }
attributes #6 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5}
!llvm.ident = !{!6}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"ilp32"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{i32 8, !"SmallDataLimit", i32 8}
!6 = !{!"clang version 18.1.8 (git@github.com:FAST-Research-Group/primate-arch-gen.git e8582d4315ec2267abfc97212fa19f342d0812e8)"}
!7 = !{!"blue", !"IO", i64 1, i64 1}
!8 = !{!9}
!9 = distinct !{!9, !10, !"_ZN7PRIMATE5inputI10ethernet_tEET_v: %agg.result"}
!10 = distinct !{!10, !"_ZN7PRIMATE5inputI10ethernet_tEET_v"}
!11 = !{i64 0, i64 8, !12, i64 8, i64 8, !12, i64 16, i64 2, !16}
!12 = !{!13, !13, i64 0}
!13 = !{!"_BitInt(48)", !14, i64 0}
!14 = !{!"omnipotent char", !15, i64 0}
!15 = !{!"Simple C++ TBAA"}
!16 = !{!17, !17, i64 0}
!17 = !{!"_BitInt(16)", !14, i64 0}
!18 = !{!19, !17, i64 16}
!19 = !{!"_ZTS10ethernet_t", !13, i64 0, !13, i64 8, !17, i64 16}
!20 = !{!21}
!21 = distinct !{!21, !22, !"_ZN7PRIMATE5inputI6ipv4_tEET_v: %agg.result"}
!22 = distinct !{!22, !"_ZN7PRIMATE5inputI6ipv4_tEET_v"}
!23 = !{i64 0, i64 16, !24, i64 16, i64 1, !26, i64 24, i64 16, !28}
!24 = !{!25, !25, i64 0}
!25 = !{!"_BitInt(72)", !14, i64 0}
!26 = !{!27, !27, i64 0}
!27 = !{!"_BitInt(8)", !14, i64 0}
!28 = !{!29, !29, i64 0}
!29 = !{!"_BitInt(80)", !14, i64 0}
!30 = !{!31, !27, i64 16}
!31 = !{!"_ZTS6ipv4_t", !25, i64 0, !27, i64 16, !29, i64 24}
!32 = !{!33}
!33 = distinct !{!33, !34, !"_ZN7PRIMATE5inputI5tcp_tEET_v: %agg.result"}
!34 = distinct !{!34, !"_ZN7PRIMATE5inputI5tcp_tEET_v"}
!35 = !{i64 0, i64 16, !36, i64 16, i64 1, !38, i64 24, i64 8, !40}
!36 = !{!37, !37, i64 0}
!37 = !{!"_BitInt(96)", !14, i64 0}
!38 = !{!39, !39, i64 0}
!39 = !{!"_BitInt(4)", !14, i64 0}
!40 = !{!41, !41, i64 0}
!41 = !{!"_BitInt(60)", !14, i64 0}
!42 = !{!43, !39, i64 16}
!43 = !{!"_ZTS5tcp_t", !37, i64 0, !39, i64 16, !41, i64 24}
!44 = !{!45}
!45 = distinct !{!45, !46, !"_ZN7PRIMATE5inputIDU128_EET_v: %agg.result"}
!46 = distinct !{!46, !"_ZN7PRIMATE5inputIDU128_EET_v"}
!47 = !{!48, !48, i64 0}
!48 = !{!"_BitInt(128)", !14, i64 0}
!49 = distinct !{!49, !50}
!50 = !{!"llvm.loop.mustprogress"}
!51 = !{!52}
!52 = distinct !{!52, !53, !"_ZN7PRIMATE5inputI5udp_tEET_v: %agg.result"}
!53 = distinct !{!53, !"_ZN7PRIMATE5inputI5udp_tEET_v"}
!54 = !{!55, !55, i64 0}
!55 = !{!"_BitInt(64)", !14, i64 0}
Using default inliner heuristic.
; *** IR Dump After RequireAnalysisPass<llvm::GlobalsAA, llvm::Module, llvm::AnalysisManager<llvm::Module>> on [module] ***
; ModuleID = 'tcp_parse.cpp'
source_filename = "tcp_parse.cpp"
target datalayout = "e-G1-m:e-p:32:32-i64:64-n32-S128"
target triple = "primate32-unknown-linux-gnu"

%struct.udp_t = type { i64 }
%struct.tcp_t = type { i96, i4, i60 }
%struct.ipv4_t = type { i72, i8, i80 }
%struct.ethernet_t = type { i48, i48, i16 }

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.done() #1

; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %agg.tmp3545 = alloca %struct.udp_t, align 8
  %out.addr.i44 = alloca i128, align 8
  %indirect-arg-temp43 = alloca i128, align 8
  %out.addr.i42 = alloca i8, align 1
  %out.addr.i = alloca i8, align 1
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !8)
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24), !noalias !8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, ptr noundef nonnull align 8 dereferenceable(24) %0, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.lifetime.start.p0(i64 24, ptr %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp39, ptr align 1 %agg.tmp, i64 24, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp39, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr %agg.tmp39)
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %1 = load i16, ptr %etherType, align 8, !tbaa !18
  %cmp = icmp eq i16 %1, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !20)
  %2 = call ptr @llvm.primate.input.p0.i32(i32 40), !noalias !20
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, ptr noundef nonnull align 8 dereferenceable(40) %2, i32 40, i1 false), !tbaa.struct !23
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !23
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !23
  call void @llvm.lifetime.start.p0(i64 40, ptr %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp240, ptr align 1 %agg.tmp2, i64 40, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp240, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr %agg.tmp240)
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %3 = load i8, ptr %protocol, align 8, !tbaa !30
  switch i8 %3, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !32)
  %4 = call ptr @llvm.primate.input.p0.i32(i32 32), !noalias !32
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, ptr noundef nonnull align 8 dereferenceable(32) %4, i32 32, i1 false), !tbaa.struct !35
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !35
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !35
  call void @llvm.lifetime.start.p0(i64 32, ptr %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp741, ptr align 1 %agg.tmp7, i64 32, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp741, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr %agg.tmp741)
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %5 = load i4, ptr %dataOffset, align 8, !tbaa !42
  %cmp9 = icmp sgt i4 %5, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %6 = load i4, ptr %dataOffset, align 8, !tbaa !42
  %conv12 = sext i4 %6 to i32
  %sub = shl nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %n.0 = phi i32 [ 0, %if.then10 ], [ %n.1, %cleanup ]
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38

while.body:                                       ; preds = %while.cond
  %7 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %8 = load i8, ptr %7, align 1, !tbaa !26
  switch i8 %8, label %if.end26 [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i42)
  store i8 %8, ptr %out.addr.i42, align 1, !tbaa !26
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i42, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i42)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %cleanup

while.body19:                                     ; preds = %while.cond17
  call void @llvm.experimental.noalias.scope.decl(metadata !44)
  %9 = call ptr @llvm.primate.input.p0.i32(i32 16), !noalias !44
  %10 = load i128, ptr %9, align 8, !tbaa !47, !noalias !44
  store i128 %10, ptr %tmp, align 8, !tbaa !47, !alias.scope !44
  %11 = load i128, ptr %tmp, align 8, !tbaa !47
  store i128 %11, ptr %indirect-arg-temp, align 8, !tbaa !47
  call void @llvm.lifetime.start.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.start.p0(i64 16, ptr %out.addr.i44)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %indirect-arg-temp43, ptr align 1 %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !47
  store i128 %out.i, ptr %out.addr.i44, align 8, !tbaa !47
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i44, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.end.p0(i64 16, ptr %out.addr.i44)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !49

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i)
  store i8 %8, ptr %out.addr.i, align 1, !tbaa !26
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i)
  br label %if.end26

if.end26:                                         ; preds = %while.body, %if.then23
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  %inc = add nsw i32 %n.0, 1
  br label %cleanup

cleanup:                                          ; preds = %while.cond17, %if.end26
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end26 ], [ 3, %while.cond17 ]
  %n.1 = phi i32 [ %inc, %if.end26 ], [ %n.0, %while.cond17 ]
  %hdr_byte_left.3 = phi i32 [ %hdr_byte_left.2, %if.end26 ], [ %hdr_byte_left.1, %while.cond17 ]
  %switch = icmp ult i32 %cleanup.dest.slot.0, 1
  br i1 %switch, label %while.cond, label %if.end38

if.then33:                                        ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !51)
  %12 = call ptr @llvm.primate.input.p0.i32(i32 8), !noalias !51
  %13 = load i64, ptr %12, align 8, !tbaa !54, !noalias !51
  store i64 %13, ptr %ref.tmp34, align 8, !tbaa !54, !alias.scope !51
  %14 = load i64, ptr %ref.tmp34, align 8, !tbaa !54
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
  store i64 %14, ptr %agg.tmp35, align 8, !tbaa !54
  call void @llvm.lifetime.start.p0(i64 8, ptr %agg.tmp3545)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp3545, ptr align 1 %agg.tmp35, i64 8, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp3545, i32 8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %agg.tmp3545)
  br label %if.end38

if.end38:                                         ; preds = %if.then, %while.cond, %cleanup, %if.then5, %if.then33, %entry
  call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i32(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i32, i1 immarg) #4

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: nounwind
declare !primate !7 ptr @llvm.primate.input.p0.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.p0.i32(ptr, i32) #1

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite)
declare void @llvm.experimental.noalias.scope.decl(metadata) #5

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #6

attributes #0 = { alwaysinline mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #1 = { nounwind }
attributes #2 = { mustprogress "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #3 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #5 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite) }
attributes #6 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5}
!llvm.ident = !{!6}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"ilp32"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{i32 8, !"SmallDataLimit", i32 8}
!6 = !{!"clang version 18.1.8 (git@github.com:FAST-Research-Group/primate-arch-gen.git e8582d4315ec2267abfc97212fa19f342d0812e8)"}
!7 = !{!"blue", !"IO", i64 1, i64 1}
!8 = !{!9}
!9 = distinct !{!9, !10, !"_ZN7PRIMATE5inputI10ethernet_tEET_v: %agg.result"}
!10 = distinct !{!10, !"_ZN7PRIMATE5inputI10ethernet_tEET_v"}
!11 = !{i64 0, i64 8, !12, i64 8, i64 8, !12, i64 16, i64 2, !16}
!12 = !{!13, !13, i64 0}
!13 = !{!"_BitInt(48)", !14, i64 0}
!14 = !{!"omnipotent char", !15, i64 0}
!15 = !{!"Simple C++ TBAA"}
!16 = !{!17, !17, i64 0}
!17 = !{!"_BitInt(16)", !14, i64 0}
!18 = !{!19, !17, i64 16}
!19 = !{!"_ZTS10ethernet_t", !13, i64 0, !13, i64 8, !17, i64 16}
!20 = !{!21}
!21 = distinct !{!21, !22, !"_ZN7PRIMATE5inputI6ipv4_tEET_v: %agg.result"}
!22 = distinct !{!22, !"_ZN7PRIMATE5inputI6ipv4_tEET_v"}
!23 = !{i64 0, i64 16, !24, i64 16, i64 1, !26, i64 24, i64 16, !28}
!24 = !{!25, !25, i64 0}
!25 = !{!"_BitInt(72)", !14, i64 0}
!26 = !{!27, !27, i64 0}
!27 = !{!"_BitInt(8)", !14, i64 0}
!28 = !{!29, !29, i64 0}
!29 = !{!"_BitInt(80)", !14, i64 0}
!30 = !{!31, !27, i64 16}
!31 = !{!"_ZTS6ipv4_t", !25, i64 0, !27, i64 16, !29, i64 24}
!32 = !{!33}
!33 = distinct !{!33, !34, !"_ZN7PRIMATE5inputI5tcp_tEET_v: %agg.result"}
!34 = distinct !{!34, !"_ZN7PRIMATE5inputI5tcp_tEET_v"}
!35 = !{i64 0, i64 16, !36, i64 16, i64 1, !38, i64 24, i64 8, !40}
!36 = !{!37, !37, i64 0}
!37 = !{!"_BitInt(96)", !14, i64 0}
!38 = !{!39, !39, i64 0}
!39 = !{!"_BitInt(4)", !14, i64 0}
!40 = !{!41, !41, i64 0}
!41 = !{!"_BitInt(60)", !14, i64 0}
!42 = !{!43, !39, i64 16}
!43 = !{!"_ZTS5tcp_t", !37, i64 0, !39, i64 16, !41, i64 24}
!44 = !{!45}
!45 = distinct !{!45, !46, !"_ZN7PRIMATE5inputIDU128_EET_v: %agg.result"}
!46 = distinct !{!46, !"_ZN7PRIMATE5inputIDU128_EET_v"}
!47 = !{!48, !48, i64 0}
!48 = !{!"_BitInt(128)", !14, i64 0}
!49 = distinct !{!49, !50}
!50 = !{!"llvm.loop.mustprogress"}
!51 = !{!52}
!52 = distinct !{!52, !53, !"_ZN7PRIMATE5inputI5udp_tEET_v: %agg.result"}
!53 = distinct !{!53, !"_ZN7PRIMATE5inputI5udp_tEET_v"}
!54 = !{!55, !55, i64 0}
!55 = !{!"_BitInt(64)", !14, i64 0}
; *** IR Dump After InvalidateAnalysisPass<llvm::AAManager> on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After InvalidateAnalysisPass<llvm::AAManager> on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After InvalidateAnalysisPass<llvm::AAManager> on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %agg.tmp3545 = alloca %struct.udp_t, align 8
  %out.addr.i44 = alloca i128, align 8
  %indirect-arg-temp43 = alloca i128, align 8
  %out.addr.i42 = alloca i8, align 1
  %out.addr.i = alloca i8, align 1
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !8)
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24), !noalias !8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, ptr noundef nonnull align 8 dereferenceable(24) %0, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.lifetime.start.p0(i64 24, ptr %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp39, ptr align 1 %agg.tmp, i64 24, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp39, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr %agg.tmp39)
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %1 = load i16, ptr %etherType, align 8, !tbaa !18
  %cmp = icmp eq i16 %1, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !20)
  %2 = call ptr @llvm.primate.input.p0.i32(i32 40), !noalias !20
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, ptr noundef nonnull align 8 dereferenceable(40) %2, i32 40, i1 false), !tbaa.struct !23
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !23
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !23
  call void @llvm.lifetime.start.p0(i64 40, ptr %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp240, ptr align 1 %agg.tmp2, i64 40, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp240, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr %agg.tmp240)
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %3 = load i8, ptr %protocol, align 8, !tbaa !30
  switch i8 %3, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !32)
  %4 = call ptr @llvm.primate.input.p0.i32(i32 32), !noalias !32
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, ptr noundef nonnull align 8 dereferenceable(32) %4, i32 32, i1 false), !tbaa.struct !35
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !35
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !35
  call void @llvm.lifetime.start.p0(i64 32, ptr %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp741, ptr align 1 %agg.tmp7, i64 32, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp741, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr %agg.tmp741)
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %5 = load i4, ptr %dataOffset, align 8, !tbaa !42
  %cmp9 = icmp sgt i4 %5, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %6 = load i4, ptr %dataOffset, align 8, !tbaa !42
  %conv12 = sext i4 %6 to i32
  %sub = shl nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %n.0 = phi i32 [ 0, %if.then10 ], [ %n.1, %cleanup ]
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38

while.body:                                       ; preds = %while.cond
  %7 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %8 = load i8, ptr %7, align 1, !tbaa !26
  switch i8 %8, label %if.end26 [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i42)
  store i8 %8, ptr %out.addr.i42, align 1, !tbaa !26
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i42, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i42)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %cleanup

while.body19:                                     ; preds = %while.cond17
  call void @llvm.experimental.noalias.scope.decl(metadata !44)
  %9 = call ptr @llvm.primate.input.p0.i32(i32 16), !noalias !44
  %10 = load i128, ptr %9, align 8, !tbaa !47, !noalias !44
  store i128 %10, ptr %tmp, align 8, !tbaa !47, !alias.scope !44
  %11 = load i128, ptr %tmp, align 8, !tbaa !47
  store i128 %11, ptr %indirect-arg-temp, align 8, !tbaa !47
  call void @llvm.lifetime.start.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.start.p0(i64 16, ptr %out.addr.i44)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %indirect-arg-temp43, ptr align 1 %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !47
  store i128 %out.i, ptr %out.addr.i44, align 8, !tbaa !47
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i44, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.end.p0(i64 16, ptr %out.addr.i44)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !49

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i)
  store i8 %8, ptr %out.addr.i, align 1, !tbaa !26
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i)
  br label %if.end26

if.end26:                                         ; preds = %while.body, %if.then23
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  %inc = add nsw i32 %n.0, 1
  br label %cleanup

cleanup:                                          ; preds = %while.cond17, %if.end26
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end26 ], [ 3, %while.cond17 ]
  %n.1 = phi i32 [ %inc, %if.end26 ], [ %n.0, %while.cond17 ]
  %hdr_byte_left.3 = phi i32 [ %hdr_byte_left.2, %if.end26 ], [ %hdr_byte_left.1, %while.cond17 ]
  %switch = icmp ult i32 %cleanup.dest.slot.0, 1
  br i1 %switch, label %while.cond, label %if.end38

if.then33:                                        ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !51)
  %12 = call ptr @llvm.primate.input.p0.i32(i32 8), !noalias !51
  %13 = load i64, ptr %12, align 8, !tbaa !54, !noalias !51
  store i64 %13, ptr %ref.tmp34, align 8, !tbaa !54, !alias.scope !51
  %14 = load i64, ptr %ref.tmp34, align 8, !tbaa !54
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
  store i64 %14, ptr %agg.tmp35, align 8, !tbaa !54
  call void @llvm.lifetime.start.p0(i64 8, ptr %agg.tmp3545)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp3545, ptr align 1 %agg.tmp35, i64 8, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp3545, i32 8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %agg.tmp3545)
  br label %if.end38

if.end38:                                         ; preds = %if.then, %while.cond, %cleanup, %if.then5, %if.then33, %entry
  call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
; *** IR Dump After RequireAnalysisPass<llvm::ProfileSummaryAnalysis, llvm::Module, llvm::AnalysisManager<llvm::Module>> on [module] ***
; ModuleID = 'tcp_parse.cpp'
source_filename = "tcp_parse.cpp"
target datalayout = "e-G1-m:e-p:32:32-i64:64-n32-S128"
target triple = "primate32-unknown-linux-gnu"

%struct.udp_t = type { i64 }
%struct.tcp_t = type { i96, i4, i60 }
%struct.ipv4_t = type { i72, i8, i80 }
%struct.ethernet_t = type { i48, i48, i16 }

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.done() #1

; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %agg.tmp3545 = alloca %struct.udp_t, align 8
  %out.addr.i44 = alloca i128, align 8
  %indirect-arg-temp43 = alloca i128, align 8
  %out.addr.i42 = alloca i8, align 1
  %out.addr.i = alloca i8, align 1
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !8)
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24), !noalias !8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, ptr noundef nonnull align 8 dereferenceable(24) %0, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.lifetime.start.p0(i64 24, ptr %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp39, ptr align 1 %agg.tmp, i64 24, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp39, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr %agg.tmp39)
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %1 = load i16, ptr %etherType, align 8, !tbaa !18
  %cmp = icmp eq i16 %1, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !20)
  %2 = call ptr @llvm.primate.input.p0.i32(i32 40), !noalias !20
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, ptr noundef nonnull align 8 dereferenceable(40) %2, i32 40, i1 false), !tbaa.struct !23
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !23
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !23
  call void @llvm.lifetime.start.p0(i64 40, ptr %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp240, ptr align 1 %agg.tmp2, i64 40, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp240, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr %agg.tmp240)
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %3 = load i8, ptr %protocol, align 8, !tbaa !30
  switch i8 %3, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !32)
  %4 = call ptr @llvm.primate.input.p0.i32(i32 32), !noalias !32
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, ptr noundef nonnull align 8 dereferenceable(32) %4, i32 32, i1 false), !tbaa.struct !35
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !35
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !35
  call void @llvm.lifetime.start.p0(i64 32, ptr %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp741, ptr align 1 %agg.tmp7, i64 32, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp741, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr %agg.tmp741)
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %5 = load i4, ptr %dataOffset, align 8, !tbaa !42
  %cmp9 = icmp sgt i4 %5, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %6 = load i4, ptr %dataOffset, align 8, !tbaa !42
  %conv12 = sext i4 %6 to i32
  %sub = shl nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %n.0 = phi i32 [ 0, %if.then10 ], [ %n.1, %cleanup ]
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38

while.body:                                       ; preds = %while.cond
  %7 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %8 = load i8, ptr %7, align 1, !tbaa !26
  switch i8 %8, label %if.end26 [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i42)
  store i8 %8, ptr %out.addr.i42, align 1, !tbaa !26
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i42, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i42)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %cleanup

while.body19:                                     ; preds = %while.cond17
  call void @llvm.experimental.noalias.scope.decl(metadata !44)
  %9 = call ptr @llvm.primate.input.p0.i32(i32 16), !noalias !44
  %10 = load i128, ptr %9, align 8, !tbaa !47, !noalias !44
  store i128 %10, ptr %tmp, align 8, !tbaa !47, !alias.scope !44
  %11 = load i128, ptr %tmp, align 8, !tbaa !47
  store i128 %11, ptr %indirect-arg-temp, align 8, !tbaa !47
  call void @llvm.lifetime.start.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.start.p0(i64 16, ptr %out.addr.i44)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %indirect-arg-temp43, ptr align 1 %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !47
  store i128 %out.i, ptr %out.addr.i44, align 8, !tbaa !47
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i44, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.end.p0(i64 16, ptr %out.addr.i44)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !49

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i)
  store i8 %8, ptr %out.addr.i, align 1, !tbaa !26
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i)
  br label %if.end26

if.end26:                                         ; preds = %while.body, %if.then23
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  %inc = add nsw i32 %n.0, 1
  br label %cleanup

cleanup:                                          ; preds = %while.cond17, %if.end26
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end26 ], [ 3, %while.cond17 ]
  %n.1 = phi i32 [ %inc, %if.end26 ], [ %n.0, %while.cond17 ]
  %hdr_byte_left.3 = phi i32 [ %hdr_byte_left.2, %if.end26 ], [ %hdr_byte_left.1, %while.cond17 ]
  %switch = icmp ult i32 %cleanup.dest.slot.0, 1
  br i1 %switch, label %while.cond, label %if.end38

if.then33:                                        ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !51)
  %12 = call ptr @llvm.primate.input.p0.i32(i32 8), !noalias !51
  %13 = load i64, ptr %12, align 8, !tbaa !54, !noalias !51
  store i64 %13, ptr %ref.tmp34, align 8, !tbaa !54, !alias.scope !51
  %14 = load i64, ptr %ref.tmp34, align 8, !tbaa !54
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
  store i64 %14, ptr %agg.tmp35, align 8, !tbaa !54
  call void @llvm.lifetime.start.p0(i64 8, ptr %agg.tmp3545)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp3545, ptr align 1 %agg.tmp35, i64 8, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp3545, i32 8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %agg.tmp3545)
  br label %if.end38

if.end38:                                         ; preds = %if.then, %while.cond, %cleanup, %if.then5, %if.then33, %entry
  call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i32(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i32, i1 immarg) #4

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: nounwind
declare !primate !7 ptr @llvm.primate.input.p0.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.p0.i32(ptr, i32) #1

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite)
declare void @llvm.experimental.noalias.scope.decl(metadata) #5

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #6

attributes #0 = { alwaysinline mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #1 = { nounwind }
attributes #2 = { mustprogress "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #3 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #5 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite) }
attributes #6 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5}
!llvm.ident = !{!6}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"ilp32"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{i32 8, !"SmallDataLimit", i32 8}
!6 = !{!"clang version 18.1.8 (git@github.com:FAST-Research-Group/primate-arch-gen.git e8582d4315ec2267abfc97212fa19f342d0812e8)"}
!7 = !{!"blue", !"IO", i64 1, i64 1}
!8 = !{!9}
!9 = distinct !{!9, !10, !"_ZN7PRIMATE5inputI10ethernet_tEET_v: %agg.result"}
!10 = distinct !{!10, !"_ZN7PRIMATE5inputI10ethernet_tEET_v"}
!11 = !{i64 0, i64 8, !12, i64 8, i64 8, !12, i64 16, i64 2, !16}
!12 = !{!13, !13, i64 0}
!13 = !{!"_BitInt(48)", !14, i64 0}
!14 = !{!"omnipotent char", !15, i64 0}
!15 = !{!"Simple C++ TBAA"}
!16 = !{!17, !17, i64 0}
!17 = !{!"_BitInt(16)", !14, i64 0}
!18 = !{!19, !17, i64 16}
!19 = !{!"_ZTS10ethernet_t", !13, i64 0, !13, i64 8, !17, i64 16}
!20 = !{!21}
!21 = distinct !{!21, !22, !"_ZN7PRIMATE5inputI6ipv4_tEET_v: %agg.result"}
!22 = distinct !{!22, !"_ZN7PRIMATE5inputI6ipv4_tEET_v"}
!23 = !{i64 0, i64 16, !24, i64 16, i64 1, !26, i64 24, i64 16, !28}
!24 = !{!25, !25, i64 0}
!25 = !{!"_BitInt(72)", !14, i64 0}
!26 = !{!27, !27, i64 0}
!27 = !{!"_BitInt(8)", !14, i64 0}
!28 = !{!29, !29, i64 0}
!29 = !{!"_BitInt(80)", !14, i64 0}
!30 = !{!31, !27, i64 16}
!31 = !{!"_ZTS6ipv4_t", !25, i64 0, !27, i64 16, !29, i64 24}
!32 = !{!33}
!33 = distinct !{!33, !34, !"_ZN7PRIMATE5inputI5tcp_tEET_v: %agg.result"}
!34 = distinct !{!34, !"_ZN7PRIMATE5inputI5tcp_tEET_v"}
!35 = !{i64 0, i64 16, !36, i64 16, i64 1, !38, i64 24, i64 8, !40}
!36 = !{!37, !37, i64 0}
!37 = !{!"_BitInt(96)", !14, i64 0}
!38 = !{!39, !39, i64 0}
!39 = !{!"_BitInt(4)", !14, i64 0}
!40 = !{!41, !41, i64 0}
!41 = !{!"_BitInt(60)", !14, i64 0}
!42 = !{!43, !39, i64 16}
!43 = !{!"_ZTS5tcp_t", !37, i64 0, !39, i64 16, !41, i64 24}
!44 = !{!45}
!45 = distinct !{!45, !46, !"_ZN7PRIMATE5inputIDU128_EET_v: %agg.result"}
!46 = distinct !{!46, !"_ZN7PRIMATE5inputIDU128_EET_v"}
!47 = !{!48, !48, i64 0}
!48 = !{!"_BitInt(128)", !14, i64 0}
!49 = distinct !{!49, !50}
!50 = !{!"llvm.loop.mustprogress"}
!51 = !{!52}
!52 = distinct !{!52, !53, !"_ZN7PRIMATE5inputI5udp_tEET_v: %agg.result"}
!53 = distinct !{!53, !"_ZN7PRIMATE5inputI5udp_tEET_v"}
!54 = !{!55, !55, i64 0}
!55 = !{!"_BitInt(64)", !14, i64 0}
Building CG for module: tcp_parse.cpp
  Adding '_ZN7PRIMATE10input_doneEv' to entry set of the graph.
    Added callable function: _ZN7PRIMATE10input_doneEv
  Adding '_ZN7PRIMATE11output_doneEv' to entry set of the graph.
    Added callable function: _ZN7PRIMATE11output_doneEv
  Adding '_Z12primate_mainv' to entry set of the graph.
    Added callable function: _Z12primate_mainv
  Adding functions referenced by global initializers to the entry set.
  Adding functions called by '_ZN7PRIMATE10input_doneEv' to the graph.
  Adding functions called by '_ZN7PRIMATE11output_doneEv' to the graph.
  Adding functions called by '_Z12primate_mainv' to the graph.
Running an SCC pass across the RefSCC: [(_ZN7PRIMATE10input_doneEv)]
; *** IR Dump After InlinerPass on (_ZN7PRIMATE10input_doneEv) ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After PostOrderFunctionAttrsPass on (_ZN7PRIMATE10input_doneEv) ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After ArgumentPromotionPass on (_ZN7PRIMATE10input_doneEv) ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After OpenMPOptCGSCCPass on (_ZN7PRIMATE10input_doneEv) ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}
Running function passes across an SCC: (_ZN7PRIMATE10input_doneEv)
PrimateIntrinsicPromotion
Call returns a value already:   call void @llvm.primate.input.done()
Removing instructions
Promoting call arguments:   call void @llvm.primate.input.done()
; *** IR Dump After PrimateIntrinsicPromotion on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}
Found Primate MD: <0x10626de0> = !{!"blue", !"IO", i64 1, i64 1}
Found a BFU Func
; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

Checking the operands
getNumOperands(): 1
Found 0 unique BFU types
Compiling to primate CPU: 
looking for struct allocas in func: _ZN7PRIMATE10input_doneEv
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}

; *** IR Dump After PrimateStructToAggre on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}
Running function passes across an SCC: (_ZN7PRIMATE10input_doneEv)
Compiling to primate CPU: 
; *** IR Dump After EarlyCSEPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
; *** IR Dump After SpeculativeExecutionPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}
Jump threading on function '_ZN7PRIMATE10input_doneEv'
; *** IR Dump After JumpThreadingPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After CorrelatedValuePropagationPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE10input_doneEv
ADD:   ret void
ADD:   call void @llvm.primate.input.done()
IC: Visiting:   call void @llvm.primate.input.done()
IC: Visiting:   ret void
; *** IR Dump After InstCombinePass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After AggressiveInstCombinePass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LibCallsShrinkWrapPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.input.done()
  ret void
}
Marked as tail call candidate:   call void @llvm.primate.input.done()
; *** IR Dump After TailCallElimPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After ReassociatePass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After ConstraintEliminationPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LoopSimplifyPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LCSSAPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE10input_doneEv
ADD:   ret void
ADD:   tail call void @llvm.primate.input.done()
IC: Visiting:   tail call void @llvm.primate.input.done()
IC: Visiting:   ret void
; *** IR Dump After InstCombinePass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LoopSimplifyPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LCSSAPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After VectorCombinePass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
Instruction Merger
; *** IR Dump After MergedLoadStoreMotionPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
GVN iteration: 0
; *** IR Dump After GVNPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
SCCP on function '_ZN7PRIMATE10input_doneEv'
Marking Block Executable: entry

Popped off BBWL: 
entry:
  tail call void @llvm.primate.input.done()
  ret void

RESOLVING UNDEFs
; *** IR Dump After SCCPPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
DemandedBits: Root:   tail call void @llvm.primate.input.done()
DemandedBits: Root:   ret void
; *** IR Dump After BDCEPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE10input_doneEv
ADD:   ret void
ADD:   tail call void @llvm.primate.input.done()
IC: Visiting:   tail call void @llvm.primate.input.done()
IC: Visiting:   ret void
; *** IR Dump After InstCombinePass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
Jump threading on function '_ZN7PRIMATE10input_doneEv'
; *** IR Dump After JumpThreadingPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After CorrelatedValuePropagationPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   tail call void @llvm.primate.input.done()
mark block live: entry
mark live:   ret void
post-dom root child is a return: entry
work live:   ret void
work live:   tail call void @llvm.primate.input.done()
final dead terminator blocks: 
; *** IR Dump After ADCEPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After MemCpyOptPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
Trying to eliminate MemoryDefs that write the already existing value
Trying to eliminate MemoryDefs at the end of the function
; *** IR Dump After DSEPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After MoveAutoInitPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LoopSimplifyPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LCSSAPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After CoroElidePass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE10input_doneEv
ADD:   ret void
ADD:   tail call void @llvm.primate.input.done()
IC: Visiting:   tail call void @llvm.primate.input.done()
IC: Visiting:   ret void
; *** IR Dump After InstCombinePass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After PostOrderFunctionAttrsPass on (_ZN7PRIMATE10input_doneEv) ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
Running function passes across an SCC: (_ZN7PRIMATE10input_doneEv)
; *** IR Dump After RequireAnalysisPass<llvm::ShouldNotRunFunctionPassesAnalysis, llvm::Function, llvm::AnalysisManager<llvm::Function>> on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After CoroSplitPass on (_ZN7PRIMATE10input_doneEv) ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
Running an SCC pass across the RefSCC: [(_ZN7PRIMATE11output_doneEv)]
; *** IR Dump After InlinerPass on (_ZN7PRIMATE11output_doneEv) ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After PostOrderFunctionAttrsPass on (_ZN7PRIMATE11output_doneEv) ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After ArgumentPromotionPass on (_ZN7PRIMATE11output_doneEv) ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After OpenMPOptCGSCCPass on (_ZN7PRIMATE11output_doneEv) ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}
Running function passes across an SCC: (_ZN7PRIMATE11output_doneEv)
PrimateIntrinsicPromotion
Call returns a value already:   call void @llvm.primate.output.done()
Removing instructions
Promoting call arguments:   call void @llvm.primate.output.done()
; *** IR Dump After PrimateIntrinsicPromotion on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}
Found Primate MD: <0x10626de0> = !{!"blue", !"IO", i64 1, i64 1}
Found a BFU Func
; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.done() #1

Checking the operands
getNumOperands(): 1
Found 0 unique BFU types
Compiling to primate CPU: 
looking for struct allocas in func: _ZN7PRIMATE11output_doneEv
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}

; *** IR Dump After PrimateStructToAggre on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}
Running function passes across an SCC: (_ZN7PRIMATE11output_doneEv)
Compiling to primate CPU: 
; *** IR Dump After EarlyCSEPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
; *** IR Dump After SpeculativeExecutionPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}
Jump threading on function '_ZN7PRIMATE11output_doneEv'
; *** IR Dump After JumpThreadingPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After CorrelatedValuePropagationPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE11output_doneEv
ADD:   ret void
ADD:   call void @llvm.primate.output.done()
IC: Visiting:   call void @llvm.primate.output.done()
IC: Visiting:   ret void
; *** IR Dump After InstCombinePass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After AggressiveInstCombinePass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After LibCallsShrinkWrapPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  call void @llvm.primate.output.done()
  ret void
}
Marked as tail call candidate:   call void @llvm.primate.output.done()
; *** IR Dump After TailCallElimPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After ReassociatePass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After ConstraintEliminationPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After LoopSimplifyPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After LCSSAPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE11output_doneEv
ADD:   ret void
ADD:   tail call void @llvm.primate.output.done()
IC: Visiting:   tail call void @llvm.primate.output.done()
IC: Visiting:   ret void
; *** IR Dump After InstCombinePass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After LoopSimplifyPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After LCSSAPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After VectorCombinePass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
Instruction Merger
; *** IR Dump After MergedLoadStoreMotionPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
GVN iteration: 0
; *** IR Dump After GVNPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
SCCP on function '_ZN7PRIMATE11output_doneEv'
Marking Block Executable: entry

Popped off BBWL: 
entry:
  tail call void @llvm.primate.output.done()
  ret void

RESOLVING UNDEFs
; *** IR Dump After SCCPPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
DemandedBits: Root:   tail call void @llvm.primate.output.done()
DemandedBits: Root:   ret void
; *** IR Dump After BDCEPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE11output_doneEv
ADD:   ret void
ADD:   tail call void @llvm.primate.output.done()
IC: Visiting:   tail call void @llvm.primate.output.done()
IC: Visiting:   ret void
; *** IR Dump After InstCombinePass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
Jump threading on function '_ZN7PRIMATE11output_doneEv'
; *** IR Dump After JumpThreadingPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After CorrelatedValuePropagationPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
mark live:   tail call void @llvm.primate.output.done()
mark block live: entry
mark live:   ret void
post-dom root child is a return: entry
work live:   ret void
work live:   tail call void @llvm.primate.output.done()
final dead terminator blocks: 
; *** IR Dump After ADCEPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After MemCpyOptPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
Trying to eliminate MemoryDefs that write the already existing value
Trying to eliminate MemoryDefs at the end of the function
; *** IR Dump After DSEPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After MoveAutoInitPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After LoopSimplifyPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After LCSSAPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After CoroElidePass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE11output_doneEv
ADD:   ret void
ADD:   tail call void @llvm.primate.output.done()
IC: Visiting:   tail call void @llvm.primate.output.done()
IC: Visiting:   ret void
; *** IR Dump After InstCombinePass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After PostOrderFunctionAttrsPass on (_ZN7PRIMATE11output_doneEv) ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
Running function passes across an SCC: (_ZN7PRIMATE11output_doneEv)
; *** IR Dump After RequireAnalysisPass<llvm::ShouldNotRunFunctionPassesAnalysis, llvm::Function, llvm::AnalysisManager<llvm::Function>> on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After CoroSplitPass on (_ZN7PRIMATE11output_doneEv) ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
Running an SCC pass across the RefSCC: [(_Z12primate_mainv)]
; *** IR Dump After InlinerPass on (_Z12primate_mainv) ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %agg.tmp3545 = alloca %struct.udp_t, align 8
  %out.addr.i44 = alloca i128, align 8
  %indirect-arg-temp43 = alloca i128, align 8
  %out.addr.i42 = alloca i8, align 1
  %out.addr.i = alloca i8, align 1
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !7)
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24), !noalias !7
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, ptr noundef nonnull align 8 dereferenceable(24) %0, i32 24, i1 false), !tbaa.struct !10
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !10
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !10
  call void @llvm.lifetime.start.p0(i64 24, ptr %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp39, ptr align 1 %agg.tmp, i64 24, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp39, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr %agg.tmp39)
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %1 = load i16, ptr %etherType, align 8, !tbaa !17
  %cmp = icmp eq i16 %1, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !19)
  %2 = call ptr @llvm.primate.input.p0.i32(i32 40), !noalias !19
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, ptr noundef nonnull align 8 dereferenceable(40) %2, i32 40, i1 false), !tbaa.struct !22
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 40, ptr %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp240, ptr align 1 %agg.tmp2, i64 40, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp240, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr %agg.tmp240)
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %3 = load i8, ptr %protocol, align 8, !tbaa !29
  switch i8 %3, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !31)
  %4 = call ptr @llvm.primate.input.p0.i32(i32 32), !noalias !31
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, ptr noundef nonnull align 8 dereferenceable(32) %4, i32 32, i1 false), !tbaa.struct !34
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !34
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !34
  call void @llvm.lifetime.start.p0(i64 32, ptr %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp741, ptr align 1 %agg.tmp7, i64 32, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp741, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr %agg.tmp741)
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %5 = load i4, ptr %dataOffset, align 8, !tbaa !41
  %cmp9 = icmp sgt i4 %5, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %6 = load i4, ptr %dataOffset, align 8, !tbaa !41
  %conv12 = sext i4 %6 to i32
  %sub = shl nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %n.0 = phi i32 [ 0, %if.then10 ], [ %n.1, %cleanup ]
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38

while.body:                                       ; preds = %while.cond
  %7 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %8 = load i8, ptr %7, align 1, !tbaa !25
  switch i8 %8, label %if.end26 [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i42)
  store i8 %8, ptr %out.addr.i42, align 1, !tbaa !25
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i42, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i42)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %cleanup

while.body19:                                     ; preds = %while.cond17
  call void @llvm.experimental.noalias.scope.decl(metadata !43)
  %9 = call ptr @llvm.primate.input.p0.i32(i32 16), !noalias !43
  %10 = load i128, ptr %9, align 8, !tbaa !46, !noalias !43
  store i128 %10, ptr %tmp, align 8, !tbaa !46, !alias.scope !43
  %11 = load i128, ptr %tmp, align 8, !tbaa !46
  store i128 %11, ptr %indirect-arg-temp, align 8, !tbaa !46
  call void @llvm.lifetime.start.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.start.p0(i64 16, ptr %out.addr.i44)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %indirect-arg-temp43, ptr align 1 %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !46
  store i128 %out.i, ptr %out.addr.i44, align 8, !tbaa !46
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i44, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.end.p0(i64 16, ptr %out.addr.i44)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !48

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i)
  store i8 %8, ptr %out.addr.i, align 1, !tbaa !25
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i)
  br label %if.end26

if.end26:                                         ; preds = %while.body, %if.then23
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  %inc = add nsw i32 %n.0, 1
  br label %cleanup

cleanup:                                          ; preds = %while.cond17, %if.end26
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end26 ], [ 3, %while.cond17 ]
  %n.1 = phi i32 [ %inc, %if.end26 ], [ %n.0, %while.cond17 ]
  %hdr_byte_left.3 = phi i32 [ %hdr_byte_left.2, %if.end26 ], [ %hdr_byte_left.1, %while.cond17 ]
  %switch = icmp ult i32 %cleanup.dest.slot.0, 1
  br i1 %switch, label %while.cond, label %if.end38

if.then33:                                        ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !50)
  %12 = call ptr @llvm.primate.input.p0.i32(i32 8), !noalias !50
  %13 = load i64, ptr %12, align 8, !tbaa !53, !noalias !50
  store i64 %13, ptr %ref.tmp34, align 8, !tbaa !53, !alias.scope !50
  %14 = load i64, ptr %ref.tmp34, align 8, !tbaa !53
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
  store i64 %14, ptr %agg.tmp35, align 8, !tbaa !53
  call void @llvm.lifetime.start.p0(i64 8, ptr %agg.tmp3545)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp3545, ptr align 1 %agg.tmp35, i64 8, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp3545, i32 8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %agg.tmp3545)
  br label %if.end38

if.end38:                                         ; preds = %if.then, %while.cond, %cleanup, %if.then5, %if.then33, %entry
  call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
; *** IR Dump After PostOrderFunctionAttrsPass on (_Z12primate_mainv) ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %agg.tmp3545 = alloca %struct.udp_t, align 8
  %out.addr.i44 = alloca i128, align 8
  %indirect-arg-temp43 = alloca i128, align 8
  %out.addr.i42 = alloca i8, align 1
  %out.addr.i = alloca i8, align 1
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !7)
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24), !noalias !7
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, ptr noundef nonnull align 8 dereferenceable(24) %0, i32 24, i1 false), !tbaa.struct !10
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !10
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !10
  call void @llvm.lifetime.start.p0(i64 24, ptr %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp39, ptr align 1 %agg.tmp, i64 24, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp39, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr %agg.tmp39)
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %1 = load i16, ptr %etherType, align 8, !tbaa !17
  %cmp = icmp eq i16 %1, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !19)
  %2 = call ptr @llvm.primate.input.p0.i32(i32 40), !noalias !19
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, ptr noundef nonnull align 8 dereferenceable(40) %2, i32 40, i1 false), !tbaa.struct !22
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 40, ptr %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp240, ptr align 1 %agg.tmp2, i64 40, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp240, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr %agg.tmp240)
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %3 = load i8, ptr %protocol, align 8, !tbaa !29
  switch i8 %3, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !31)
  %4 = call ptr @llvm.primate.input.p0.i32(i32 32), !noalias !31
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, ptr noundef nonnull align 8 dereferenceable(32) %4, i32 32, i1 false), !tbaa.struct !34
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !34
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !34
  call void @llvm.lifetime.start.p0(i64 32, ptr %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp741, ptr align 1 %agg.tmp7, i64 32, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp741, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr %agg.tmp741)
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %5 = load i4, ptr %dataOffset, align 8, !tbaa !41
  %cmp9 = icmp sgt i4 %5, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %6 = load i4, ptr %dataOffset, align 8, !tbaa !41
  %conv12 = sext i4 %6 to i32
  %sub = shl nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %n.0 = phi i32 [ 0, %if.then10 ], [ %n.1, %cleanup ]
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38

while.body:                                       ; preds = %while.cond
  %7 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %8 = load i8, ptr %7, align 1, !tbaa !25
  switch i8 %8, label %if.end26 [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i42)
  store i8 %8, ptr %out.addr.i42, align 1, !tbaa !25
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i42, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i42)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %cleanup

while.body19:                                     ; preds = %while.cond17
  call void @llvm.experimental.noalias.scope.decl(metadata !43)
  %9 = call ptr @llvm.primate.input.p0.i32(i32 16), !noalias !43
  %10 = load i128, ptr %9, align 8, !tbaa !46, !noalias !43
  store i128 %10, ptr %tmp, align 8, !tbaa !46, !alias.scope !43
  %11 = load i128, ptr %tmp, align 8, !tbaa !46
  store i128 %11, ptr %indirect-arg-temp, align 8, !tbaa !46
  call void @llvm.lifetime.start.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.start.p0(i64 16, ptr %out.addr.i44)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %indirect-arg-temp43, ptr align 1 %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !46
  store i128 %out.i, ptr %out.addr.i44, align 8, !tbaa !46
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i44, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.end.p0(i64 16, ptr %out.addr.i44)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !48

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i)
  store i8 %8, ptr %out.addr.i, align 1, !tbaa !25
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i)
  br label %if.end26

if.end26:                                         ; preds = %while.body, %if.then23
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  %inc = add nsw i32 %n.0, 1
  br label %cleanup

cleanup:                                          ; preds = %while.cond17, %if.end26
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end26 ], [ 3, %while.cond17 ]
  %n.1 = phi i32 [ %inc, %if.end26 ], [ %n.0, %while.cond17 ]
  %hdr_byte_left.3 = phi i32 [ %hdr_byte_left.2, %if.end26 ], [ %hdr_byte_left.1, %while.cond17 ]
  %switch = icmp ult i32 %cleanup.dest.slot.0, 1
  br i1 %switch, label %while.cond, label %if.end38

if.then33:                                        ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !50)
  %12 = call ptr @llvm.primate.input.p0.i32(i32 8), !noalias !50
  %13 = load i64, ptr %12, align 8, !tbaa !53, !noalias !50
  store i64 %13, ptr %ref.tmp34, align 8, !tbaa !53, !alias.scope !50
  %14 = load i64, ptr %ref.tmp34, align 8, !tbaa !53
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
  store i64 %14, ptr %agg.tmp35, align 8, !tbaa !53
  call void @llvm.lifetime.start.p0(i64 8, ptr %agg.tmp3545)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp3545, ptr align 1 %agg.tmp35, i64 8, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp3545, i32 8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %agg.tmp3545)
  br label %if.end38

if.end38:                                         ; preds = %if.then, %while.cond, %cleanup, %if.then5, %if.then33, %entry
  call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
; *** IR Dump After ArgumentPromotionPass on (_Z12primate_mainv) ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %agg.tmp3545 = alloca %struct.udp_t, align 8
  %out.addr.i44 = alloca i128, align 8
  %indirect-arg-temp43 = alloca i128, align 8
  %out.addr.i42 = alloca i8, align 1
  %out.addr.i = alloca i8, align 1
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !7)
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24), !noalias !7
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, ptr noundef nonnull align 8 dereferenceable(24) %0, i32 24, i1 false), !tbaa.struct !10
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !10
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !10
  call void @llvm.lifetime.start.p0(i64 24, ptr %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp39, ptr align 1 %agg.tmp, i64 24, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp39, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr %agg.tmp39)
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %1 = load i16, ptr %etherType, align 8, !tbaa !17
  %cmp = icmp eq i16 %1, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !19)
  %2 = call ptr @llvm.primate.input.p0.i32(i32 40), !noalias !19
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, ptr noundef nonnull align 8 dereferenceable(40) %2, i32 40, i1 false), !tbaa.struct !22
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 40, ptr %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp240, ptr align 1 %agg.tmp2, i64 40, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp240, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr %agg.tmp240)
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %3 = load i8, ptr %protocol, align 8, !tbaa !29
  switch i8 %3, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !31)
  %4 = call ptr @llvm.primate.input.p0.i32(i32 32), !noalias !31
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, ptr noundef nonnull align 8 dereferenceable(32) %4, i32 32, i1 false), !tbaa.struct !34
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !34
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !34
  call void @llvm.lifetime.start.p0(i64 32, ptr %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp741, ptr align 1 %agg.tmp7, i64 32, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp741, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr %agg.tmp741)
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %5 = load i4, ptr %dataOffset, align 8, !tbaa !41
  %cmp9 = icmp sgt i4 %5, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %6 = load i4, ptr %dataOffset, align 8, !tbaa !41
  %conv12 = sext i4 %6 to i32
  %sub = shl nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %n.0 = phi i32 [ 0, %if.then10 ], [ %n.1, %cleanup ]
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38

while.body:                                       ; preds = %while.cond
  %7 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %8 = load i8, ptr %7, align 1, !tbaa !25
  switch i8 %8, label %if.end26 [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i42)
  store i8 %8, ptr %out.addr.i42, align 1, !tbaa !25
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i42, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i42)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %cleanup

while.body19:                                     ; preds = %while.cond17
  call void @llvm.experimental.noalias.scope.decl(metadata !43)
  %9 = call ptr @llvm.primate.input.p0.i32(i32 16), !noalias !43
  %10 = load i128, ptr %9, align 8, !tbaa !46, !noalias !43
  store i128 %10, ptr %tmp, align 8, !tbaa !46, !alias.scope !43
  %11 = load i128, ptr %tmp, align 8, !tbaa !46
  store i128 %11, ptr %indirect-arg-temp, align 8, !tbaa !46
  call void @llvm.lifetime.start.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.start.p0(i64 16, ptr %out.addr.i44)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %indirect-arg-temp43, ptr align 1 %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !46
  store i128 %out.i, ptr %out.addr.i44, align 8, !tbaa !46
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i44, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.end.p0(i64 16, ptr %out.addr.i44)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !48

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i)
  store i8 %8, ptr %out.addr.i, align 1, !tbaa !25
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i)
  br label %if.end26

if.end26:                                         ; preds = %while.body, %if.then23
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  %inc = add nsw i32 %n.0, 1
  br label %cleanup

cleanup:                                          ; preds = %while.cond17, %if.end26
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end26 ], [ 3, %while.cond17 ]
  %n.1 = phi i32 [ %inc, %if.end26 ], [ %n.0, %while.cond17 ]
  %hdr_byte_left.3 = phi i32 [ %hdr_byte_left.2, %if.end26 ], [ %hdr_byte_left.1, %while.cond17 ]
  %switch = icmp ult i32 %cleanup.dest.slot.0, 1
  br i1 %switch, label %while.cond, label %if.end38

if.then33:                                        ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !50)
  %12 = call ptr @llvm.primate.input.p0.i32(i32 8), !noalias !50
  %13 = load i64, ptr %12, align 8, !tbaa !53, !noalias !50
  store i64 %13, ptr %ref.tmp34, align 8, !tbaa !53, !alias.scope !50
  %14 = load i64, ptr %ref.tmp34, align 8, !tbaa !53
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
  store i64 %14, ptr %agg.tmp35, align 8, !tbaa !53
  call void @llvm.lifetime.start.p0(i64 8, ptr %agg.tmp3545)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp3545, ptr align 1 %agg.tmp35, i64 8, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp3545, i32 8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %agg.tmp3545)
  br label %if.end38

if.end38:                                         ; preds = %if.then, %while.cond, %cleanup, %if.then5, %if.then33, %entry
  call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
; *** IR Dump After OpenMPOptCGSCCPass on (_Z12primate_mainv) ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %agg.tmp3545 = alloca %struct.udp_t, align 8
  %out.addr.i44 = alloca i128, align 8
  %indirect-arg-temp43 = alloca i128, align 8
  %out.addr.i42 = alloca i8, align 1
  %out.addr.i = alloca i8, align 1
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !7)
  %0 = call ptr @llvm.primate.input.p0.i32(i32 24), !noalias !7
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, ptr noundef nonnull align 8 dereferenceable(24) %0, i32 24, i1 false), !tbaa.struct !10
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !10
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !10
  call void @llvm.lifetime.start.p0(i64 24, ptr %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp39, ptr align 1 %agg.tmp, i64 24, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp39, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr %agg.tmp39)
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %1 = load i16, ptr %etherType, align 8, !tbaa !17
  %cmp = icmp eq i16 %1, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !19)
  %2 = call ptr @llvm.primate.input.p0.i32(i32 40), !noalias !19
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, ptr noundef nonnull align 8 dereferenceable(40) %2, i32 40, i1 false), !tbaa.struct !22
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 40, ptr %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp240, ptr align 1 %agg.tmp2, i64 40, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp240, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr %agg.tmp240)
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %3 = load i8, ptr %protocol, align 8, !tbaa !29
  switch i8 %3, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !31)
  %4 = call ptr @llvm.primate.input.p0.i32(i32 32), !noalias !31
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, ptr noundef nonnull align 8 dereferenceable(32) %4, i32 32, i1 false), !tbaa.struct !34
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !34
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !34
  call void @llvm.lifetime.start.p0(i64 32, ptr %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp741, ptr align 1 %agg.tmp7, i64 32, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp741, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr %agg.tmp741)
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %5 = load i4, ptr %dataOffset, align 8, !tbaa !41
  %cmp9 = icmp sgt i4 %5, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %6 = load i4, ptr %dataOffset, align 8, !tbaa !41
  %conv12 = sext i4 %6 to i32
  %sub = shl nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %n.0 = phi i32 [ 0, %if.then10 ], [ %n.1, %cleanup ]
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38

while.body:                                       ; preds = %while.cond
  %7 = call ptr @llvm.primate.input.p0.i32(i32 1)
  %8 = load i8, ptr %7, align 1, !tbaa !25
  switch i8 %8, label %if.end26 [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i42)
  store i8 %8, ptr %out.addr.i42, align 1, !tbaa !25
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i42, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i42)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %cleanup

while.body19:                                     ; preds = %while.cond17
  call void @llvm.experimental.noalias.scope.decl(metadata !43)
  %9 = call ptr @llvm.primate.input.p0.i32(i32 16), !noalias !43
  %10 = load i128, ptr %9, align 8, !tbaa !46, !noalias !43
  store i128 %10, ptr %tmp, align 8, !tbaa !46, !alias.scope !43
  %11 = load i128, ptr %tmp, align 8, !tbaa !46
  store i128 %11, ptr %indirect-arg-temp, align 8, !tbaa !46
  call void @llvm.lifetime.start.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.start.p0(i64 16, ptr %out.addr.i44)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %indirect-arg-temp43, ptr align 1 %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !46
  store i128 %out.i, ptr %out.addr.i44, align 8, !tbaa !46
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i44, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.end.p0(i64 16, ptr %out.addr.i44)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !48

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i)
  store i8 %8, ptr %out.addr.i, align 1, !tbaa !25
  call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i)
  br label %if.end26

if.end26:                                         ; preds = %while.body, %if.then23
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  %inc = add nsw i32 %n.0, 1
  br label %cleanup

cleanup:                                          ; preds = %while.cond17, %if.end26
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end26 ], [ 3, %while.cond17 ]
  %n.1 = phi i32 [ %inc, %if.end26 ], [ %n.0, %while.cond17 ]
  %hdr_byte_left.3 = phi i32 [ %hdr_byte_left.2, %if.end26 ], [ %hdr_byte_left.1, %while.cond17 ]
  %switch = icmp ult i32 %cleanup.dest.slot.0, 1
  br i1 %switch, label %while.cond, label %if.end38

if.then33:                                        ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !50)
  %12 = call ptr @llvm.primate.input.p0.i32(i32 8), !noalias !50
  %13 = load i64, ptr %12, align 8, !tbaa !53, !noalias !50
  store i64 %13, ptr %ref.tmp34, align 8, !tbaa !53, !alias.scope !50
  %14 = load i64, ptr %ref.tmp34, align 8, !tbaa !53
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
  store i64 %14, ptr %agg.tmp35, align 8, !tbaa !53
  call void @llvm.lifetime.start.p0(i64 8, ptr %agg.tmp3545)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp3545, ptr align 1 %agg.tmp35, i64 8, i1 false)
  call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp3545, i32 8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %agg.tmp3545)
  br label %if.end38

if.end38:                                         ; preds = %if.then, %while.cond, %cleanup, %if.then5, %if.then33, %entry
  call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
Running function passes across an SCC: (_Z12primate_mainv)
PrimateIntrinsicPromotion
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
Call is not a primate BFU call:   call void @llvm.experimental.noalias.scope.decl(metadata !8)
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, ptr noundef nonnull align 8 dereferenceable(24) %0, i32 24, i1 false), !tbaa.struct !10
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !10
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !10
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 24, ptr %agg.tmp39)
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp39, ptr align 1 %agg.tmp, i64 24, i1 false)
Call returns a value already:   call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp39, i32 24)
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 24, ptr %agg.tmp39)
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
Call is not a primate BFU call:   call void @llvm.experimental.noalias.scope.decl(metadata !20)
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, ptr noundef nonnull align 8 dereferenceable(40) %2, i32 40, i1 false), !tbaa.struct !22
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !22
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !22
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 40, ptr %agg.tmp240)
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp240, ptr align 1 %agg.tmp2, i64 40, i1 false)
Call returns a value already:   call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp240, i32 40)
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 40, ptr %agg.tmp240)
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
Call is not a primate BFU call:   call void @llvm.experimental.noalias.scope.decl(metadata !32)
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, ptr noundef nonnull align 8 dereferenceable(32) %4, i32 32, i1 false), !tbaa.struct !34
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !34
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !34
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 32, ptr %agg.tmp741)
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp741, ptr align 1 %agg.tmp7, i64 32, i1 false)
Call returns a value already:   call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp741, i32 32)
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 32, ptr %agg.tmp741)
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i42)
Call returns a value already:   call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i42, i32 1)
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i42)
Call is not a primate BFU call:   call void @llvm.experimental.noalias.scope.decl(metadata !44)
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 16, ptr %indirect-arg-temp43)
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 16, ptr %out.addr.i44)
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i64(ptr align 1 %indirect-arg-temp43, ptr align 1 %indirect-arg-temp, i64 16, i1 false)
Call returns a value already:   call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i44, i32 16)
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 16, ptr %indirect-arg-temp43)
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 16, ptr %out.addr.i44)
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i)
Call returns a value already:   call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i, i32 1)
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i)
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
Call is not a primate BFU call:   call void @llvm.experimental.noalias.scope.decl(metadata !51)
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 8, ptr %agg.tmp3545)
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp3545, ptr align 1 %agg.tmp35, i64 8, i1 false)
Call returns a value already:   call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp3545, i32 8)
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 8, ptr %agg.tmp3545)
Call returns a value already:   call void @llvm.primate.input.done()
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
Promoting call result:   %0 = call ptr @llvm.primate.input.p0.i32(i32 24), !noalias !7
found a memcpy. Probably an alloca.
Promoting call result:   %3 = call ptr @llvm.primate.input.p0.i32(i32 40), !noalias !19
found a memcpy. Probably an alloca.
Promoting call result:   %6 = call ptr @llvm.primate.input.p0.i32(i32 32), !noalias !31
found a memcpy. Probably an alloca.
Promoting call result:   %10 = call ptr @llvm.primate.input.p0.i32(i32 1)
found a load.
Promoting call result:   %13 = call ptr @llvm.primate.input.p0.i32(i32 16), !noalias !43
found a load.
found a store.
found an alloca.
Promoting call result:   %17 = call ptr @llvm.primate.input.p0.i32(i32 8), !noalias !50
found a load.
found a store.
found an alloca.
Removing instructions
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, ptr noundef nonnull align 8 dereferenceable(24) %1, i32 24, i1 false), !tbaa.struct !10
  %1 = call ptr @llvm.primate.input.p0.i32(i32 24), !noalias !7
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, ptr noundef nonnull align 8 dereferenceable(40) %3, i32 40, i1 false), !tbaa.struct !22
  %3 = call ptr @llvm.primate.input.p0.i32(i32 40), !noalias !19
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, ptr noundef nonnull align 8 dereferenceable(32) %5, i32 32, i1 false), !tbaa.struct !34
  %5 = call ptr @llvm.primate.input.p0.i32(i32 32), !noalias !31
  %9 = load i8, ptr %8, align 1, !tbaa !25
  %8 = call ptr @llvm.primate.input.p0.i32(i32 1)
  store i128 %10, ptr %tmp, align 8, !tbaa !46, !alias.scope !43
  %10 = load i128, ptr %9, align 8, !tbaa !46, !noalias !43
  %9 = call ptr @llvm.primate.input.p0.i32(i32 16), !noalias !43
  store i64 %12, ptr %ref.tmp34, align 8, !tbaa !53, !alias.scope !50
  %12 = load i64, ptr %11, align 8, !tbaa !53, !noalias !50
  %11 = call ptr @llvm.primate.input.p0.i32(i32 8), !noalias !50
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
Call is not a primate BFU call:   call void @llvm.experimental.noalias.scope.decl(metadata !8)
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !10
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !10
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 24, ptr %agg.tmp39)
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp39, ptr align 1 %agg.tmp, i64 24, i1 false)
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 24, ptr %agg.tmp39)
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
Call is not a primate BFU call:   call void @llvm.experimental.noalias.scope.decl(metadata !20)
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !22
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !22
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 40, ptr %agg.tmp240)
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp240, ptr align 1 %agg.tmp2, i64 40, i1 false)
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 40, ptr %agg.tmp240)
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
Call is not a primate BFU call:   call void @llvm.experimental.noalias.scope.decl(metadata !32)
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !34
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !34
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 32, ptr %agg.tmp741)
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp741, ptr align 1 %agg.tmp7, i64 32, i1 false)
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 32, ptr %agg.tmp741)
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i42)
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i42)
Call is not a primate BFU call:   call void @llvm.experimental.noalias.scope.decl(metadata !44)
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 16, ptr %indirect-arg-temp43)
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 16, ptr %out.addr.i44)
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i64(ptr align 1 %indirect-arg-temp43, ptr align 1 %indirect-arg-temp, i64 16, i1 false)
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 16, ptr %indirect-arg-temp43)
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 16, ptr %out.addr.i44)
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i)
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i)
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
Call is not a primate BFU call:   call void @llvm.experimental.noalias.scope.decl(metadata !51)
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
Call is not a primate BFU call:   call void @llvm.lifetime.start.p0(i64 8, ptr %agg.tmp3545)
Call is not a primate BFU call:   call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp3545, ptr align 1 %agg.tmp35, i64 8, i1 false)
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 8, ptr %agg.tmp3545)
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
Call is not a primate BFU call:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
Promoting call arguments:   %0 = call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
Promoting call arguments:   call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp39, i32 24)
Promoting call arguments:   %3 = call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
Promoting call arguments:   call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp240, i32 40)
Promoting call arguments:   %6 = call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
Promoting call arguments:   call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp741, i32 32)
Promoting call arguments:   %10 = call i8 @llvm.primate.input.i8.i32(i32 1)
Promoting call arguments:   call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i42, i32 1)
Promoting call arguments:   %12 = call i128 @llvm.primate.input.i128.i32(i32 16)
Promoting call arguments:   call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i44, i32 16)
Promoting call arguments:   call void @llvm.primate.output.p0.i32(ptr nonnull %out.addr.i, i32 1)
Promoting call arguments:   %16 = call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
Promoting call arguments:   call void @llvm.primate.output.p0.i32(ptr nonnull %agg.tmp3545, i32 8)
Promoting call arguments:   call void @llvm.primate.input.done()
; *** IR Dump After PrimateIntrinsicPromotion on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %agg.tmp3545 = alloca %struct.udp_t, align 8
  %out.addr.i44 = alloca i128, align 8
  %indirect-arg-temp43 = alloca i128, align 8
  %out.addr.i42 = alloca i8, align 1
  %out.addr.i = alloca i8, align 1
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !8)
  %0 = call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.lifetime.start.p0(i64 24, ptr %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp39, ptr align 1 %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr %agg.tmp39)
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %2 = load i16, ptr %etherType, align 8, !tbaa !18
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !20)
  %3 = call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !23
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !23
  call void @llvm.lifetime.start.p0(i64 40, ptr %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp240, ptr align 1 %agg.tmp2, i64 40, i1 false)
  %4 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %4, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr %agg.tmp240)
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %5 = load i8, ptr %protocol, align 8, !tbaa !30
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !32)
  %6 = call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !35
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !35
  call void @llvm.lifetime.start.p0(i64 32, ptr %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp741, ptr align 1 %agg.tmp7, i64 32, i1 false)
  %7 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %7, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr %agg.tmp741)
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %8 = load i4, ptr %dataOffset, align 8, !tbaa !42
  %cmp9 = icmp sgt i4 %8, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %9 = load i4, ptr %dataOffset, align 8, !tbaa !42
  %conv12 = sext i4 %9 to i32
  %sub = shl nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %n.0 = phi i32 [ 0, %if.then10 ], [ %n.1, %cleanup ]
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38

while.body:                                       ; preds = %while.cond
  %10 = call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %10, label %if.end26 [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i42)
  store i8 %10, ptr %out.addr.i42, align 1, !tbaa !26
  %11 = load i8, ptr %out.addr.i42, align 1
  call void @llvm.primate.output.i8.i32(i8 %11, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i42)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %cleanup

while.body19:                                     ; preds = %while.cond17
  call void @llvm.experimental.noalias.scope.decl(metadata !44)
  %12 = call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %12, ptr %tmp, align 8
  %13 = load i128, ptr %tmp, align 8, !tbaa !47
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !47
  call void @llvm.lifetime.start.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.start.p0(i64 16, ptr %out.addr.i44)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %indirect-arg-temp43, ptr align 1 %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !47
  store i128 %out.i, ptr %out.addr.i44, align 8, !tbaa !47
  %14 = load i128, ptr %out.addr.i44, align 8
  call void @llvm.primate.output.i128.i32(i128 %14, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.end.p0(i64 16, ptr %out.addr.i44)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !49

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i)
  store i8 %10, ptr %out.addr.i, align 1, !tbaa !26
  %15 = load i8, ptr %out.addr.i, align 1
  call void @llvm.primate.output.i8.i32(i8 %15, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i)
  br label %if.end26

if.end26:                                         ; preds = %while.body, %if.then23
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  %inc = add nsw i32 %n.0, 1
  br label %cleanup

cleanup:                                          ; preds = %while.cond17, %if.end26
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end26 ], [ 3, %while.cond17 ]
  %n.1 = phi i32 [ %inc, %if.end26 ], [ %n.0, %while.cond17 ]
  %hdr_byte_left.3 = phi i32 [ %hdr_byte_left.2, %if.end26 ], [ %hdr_byte_left.1, %while.cond17 ]
  %switch = icmp ult i32 %cleanup.dest.slot.0, 1
  br i1 %switch, label %while.cond, label %if.end38

if.then33:                                        ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !51)
  %16 = call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  store %struct.udp_t %16, ptr %ref.tmp34, align 8
  %17 = load i64, ptr %ref.tmp34, align 8, !tbaa !54
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
  store i64 %17, ptr %agg.tmp35, align 8, !tbaa !54
  call void @llvm.lifetime.start.p0(i64 8, ptr %agg.tmp3545)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp3545, ptr align 1 %agg.tmp35, i64 8, i1 false)
  %18 = load %struct.udp_t, ptr %agg.tmp3545, align 8
  call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %18, i32 8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %agg.tmp3545)
  br label %if.end38

if.end38:                                         ; preds = %if.then, %while.cond, %cleanup, %if.then5, %if.then33, %entry
  call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
Found Primate MD: <0x10626de0> = !{!"blue", !"IO", i64 1, i64 1}
Found a BFU Func
; Function Attrs: nounwind
declare !primate !7 %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 %0) #1

Found Primate Type: %struct.ethernet_t = type { i48, i48, i16 }
Checking the operands
getNumOperands(): 2
Found Primate MD: <0x10626de0> = !{!"blue", !"IO", i64 1, i64 1}
Found a BFU Func
; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 %1) #1

Checking the operands
getNumOperands(): 3
Found Primate MD: <0x10626de0> = !{!"blue", !"IO", i64 1, i64 1}
Found a BFU Func
; Function Attrs: nounwind
declare !primate !7 %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 %0) #1

Found Primate Type: %struct.ipv4_t = type { i72, i8, i80 }
Checking the operands
getNumOperands(): 2
Found Primate MD: <0x10626de0> = !{!"blue", !"IO", i64 1, i64 1}
Found a BFU Func
; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %0, i32 %1) #1

Checking the operands
getNumOperands(): 3
Found Primate MD: <0x10626de0> = !{!"blue", !"IO", i64 1, i64 1}
Found a BFU Func
; Function Attrs: nounwind
declare !primate !7 %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 %0) #1

Found Primate Type: %struct.tcp_t = type { i96, i4, i60 }
Checking the operands
getNumOperands(): 2
Found Primate MD: <0x10626de0> = !{!"blue", !"IO", i64 1, i64 1}
Found a BFU Func
; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %0, i32 %1) #1

Checking the operands
getNumOperands(): 3
Found Primate MD: <0x10626de0> = !{!"blue", !"IO", i64 1, i64 1}
Found a BFU Func
; Function Attrs: nounwind
declare !primate !7 i8 @llvm.primate.input.i8.i32(i32 %0) #1

Checking the operands
getNumOperands(): 2
Found Primate MD: <0x10626de0> = !{!"blue", !"IO", i64 1, i64 1}
Found a BFU Func
; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i8.i32(i8 %0, i32 %1) #1

Checking the operands
getNumOperands(): 3
Found Primate MD: <0x10626de0> = !{!"blue", !"IO", i64 1, i64 1}
Found a BFU Func
; Function Attrs: nounwind
declare !primate !7 i128 @llvm.primate.input.i128.i32(i32 %0) #1

Checking the operands
getNumOperands(): 2
Found Primate MD: <0x10626de0> = !{!"blue", !"IO", i64 1, i64 1}
Found a BFU Func
; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i128.i32(i128 %0, i32 %1) #1

Checking the operands
getNumOperands(): 3
Found Primate MD: <0x10626de0> = !{!"blue", !"IO", i64 1, i64 1}
Found a BFU Func
; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i8.i32(i8 %0, i32 %1) #1

Checking the operands
getNumOperands(): 3
Found Primate MD: <0x10626de0> = !{!"blue", !"IO", i64 1, i64 1}
Found a BFU Func
; Function Attrs: nounwind
declare !primate !7 %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 %0) #1

Found Primate Type: %struct.udp_t = type { i64 }
Checking the operands
getNumOperands(): 2
Found Primate MD: <0x10626de0> = !{!"blue", !"IO", i64 1, i64 1}
Found a BFU Func
; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %0, i32 %1) #1

Checking the operands
getNumOperands(): 3
Found Primate MD: <0x10626de0> = !{!"blue", !"IO", i64 1, i64 1}
Found a BFU Func
; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

Checking the operands
getNumOperands(): 1
Found 4 unique BFU types
%struct.ethernet_t = type { i48, i48, i16 }
%struct.ipv4_t = type { i72, i8, i80 }
%struct.tcp_t = type { i96, i4, i60 }
%struct.udp_t = type { i64 }
Compiling to primate CPU: 
looking for struct allocas in func: _Z12primate_mainv
  %agg.tmp3545 = alloca %struct.udp_t, align 8
users:   %18 = load %struct.udp_t, ptr %agg.tmp3545, align 8
other{
}
  call void @llvm.lifetime.end.p0(i64 8, ptr %agg.tmp3545)
  call void @llvm.lifetime.start.p0(i64 8, ptr %agg.tmp3545)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp3545, ptr align 1 %agg.tmp35, i64 8, i1 false)
---
  %out.addr.i44 = alloca i128, align 8
users:   %14 = load i128, ptr %out.addr.i44, align 8
other{
}
  call void @llvm.lifetime.end.p0(i64 16, ptr %out.addr.i44)
  call void @llvm.lifetime.start.p0(i64 16, ptr %out.addr.i44)
  store i128 %out.i, ptr %out.addr.i44, align 8, !tbaa !46
other{
}
---
  %indirect-arg-temp43 = alloca i128, align 8
users:   call void @llvm.lifetime.end.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.start.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %indirect-arg-temp43, ptr align 1 %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !46
other{
}
---
  %out.addr.i42 = alloca i8, align 1
users:   %11 = load i8, ptr %out.addr.i42, align 1
other{
}
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i42)
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i42)
  store i8 %10, ptr %out.addr.i42, align 1, !tbaa !25
other{
}
---
  %out.addr.i = alloca i8, align 1
users:   %15 = load i8, ptr %out.addr.i, align 1
other{
}
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i)
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i)
  store i8 %10, ptr %out.addr.i, align 1, !tbaa !25
other{
}
---
  %agg.tmp741 = alloca %struct.tcp_t, align 8
users:   %7 = load %struct.tcp_t, ptr %agg.tmp741, align 8
other{
}
  call void @llvm.lifetime.end.p0(i64 32, ptr %agg.tmp741)
  call void @llvm.lifetime.start.p0(i64 32, ptr %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp741, ptr align 1 %agg.tmp7, i64 32, i1 false)
---
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
users:   %4 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
other{
}
  call void @llvm.lifetime.end.p0(i64 40, ptr %agg.tmp240)
  call void @llvm.lifetime.start.p0(i64 40, ptr %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp240, ptr align 1 %agg.tmp2, i64 40, i1 false)
---
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
users:   %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
other{
}
  call void @llvm.lifetime.end.p0(i64 24, ptr %agg.tmp39)
  call void @llvm.lifetime.start.p0(i64 24, ptr %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp39, ptr align 1 %agg.tmp, i64 24, i1 false)
---
  %eth = alloca %struct.ethernet_t, align 8
users:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  %etherType = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
GEP{
replaced:   %4 = load i16, ptr %etherType, align 8, !tbaa !17
 with:   %3 = extractvalue %struct.ethernet_t %2, 2
Created Ops:   %2 = load %struct.ethernet_t, ptr %eth, align 8
  %3 = extractvalue %struct.ethernet_t %2, 2
}
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !10
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !10
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
---
  %ipv4 = alloca %struct.ipv4_t, align 8
users:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  %protocol = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
GEP{
replaced:   %9 = load i8, ptr %protocol, align 8, !tbaa !29
 with:   %8 = extractvalue %struct.ipv4_t %7, 1
Created Ops:   %7 = load %struct.ipv4_t, ptr %ipv4, align 8
  %8 = extractvalue %struct.ipv4_t %7, 1
}
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !22
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
---
  %tcp = alloca %struct.tcp_t, align 8
users:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  %dataOffset = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
GEP{
replaced:   %15 = load i4, ptr %dataOffset, align 8, !tbaa !41
 with:   %14 = extractvalue %struct.tcp_t %13, 1
Created Ops:   %13 = load %struct.tcp_t, ptr %tcp, align 8
  %14 = extractvalue %struct.tcp_t %13, 1
replaced:   %14 = load i4, ptr %dataOffset, align 8, !tbaa !41
 with:   %13 = extractvalue %struct.tcp_t %12, 1
Created Ops:   %12 = load %struct.tcp_t, ptr %tcp, align 8
  %13 = extractvalue %struct.tcp_t %12, 1
}
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !34
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !34
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
---
  %ref.tmp = alloca %struct.ethernet_t, align 8
users:   store %struct.ethernet_t %0, ptr %ref.tmp, align 8
other{
}
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !10
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
---
  %agg.tmp = alloca %struct.ethernet_t, align 8
users:   call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp39, ptr align 1 %agg.tmp, i64 24, i1 false)
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !10
---
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
users:   store %struct.ipv4_t %5, ptr %ref.tmp1, align 8
other{
}
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
---
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
users:   call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp240, ptr align 1 %agg.tmp2, i64 40, i1 false)
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !22
---
  %ref.tmp6 = alloca %struct.tcp_t, align 8
users:   store %struct.tcp_t %10, ptr %ref.tmp6, align 8
other{
}
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !34
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
---
  %agg.tmp7 = alloca %struct.tcp_t, align 8
users:   call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp741, ptr align 1 %agg.tmp7, i64 32, i1 false)
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !34
---
  %tmp = alloca i128, align 8
users:   store i128 %20, ptr %tmp, align 8
other{
}
  %21 = load i128, ptr %tmp, align 8, !tbaa !46
other{
}
---
  %indirect-arg-temp = alloca i128, align 8
users:   call void @llvm.memcpy.p0.p0.i64(ptr align 1 %indirect-arg-temp43, ptr align 1 %indirect-arg-temp, i64 16, i1 false)
  store i128 %21, ptr %indirect-arg-temp, align 8, !tbaa !46
other{
}
---
  %ref.tmp34 = alloca %struct.udp_t, align 8
users:   store %struct.udp_t %24, ptr %ref.tmp34, align 8
other{
}
  %25 = load i64, ptr %ref.tmp34, align 8, !tbaa !53
other{
}
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
---
  %agg.tmp35 = alloca %struct.udp_t, align 8
users:   call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp3545, ptr align 1 %agg.tmp35, i64 8, i1 false)
  store i64 %25, ptr %agg.tmp35, align 8, !tbaa !53
other{
}
---
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %agg.tmp3545 = alloca %struct.udp_t, align 8
  %out.addr.i44 = alloca i128, align 8
  %indirect-arg-temp43 = alloca i128, align 8
  %out.addr.i42 = alloca i8, align 1
  %out.addr.i = alloca i8, align 1
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !8)
  %0 = call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.lifetime.start.p0(i64 24, ptr %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp39, ptr align 1 %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr %agg.tmp39)
  %2 = load %struct.ethernet_t, ptr %eth, align 8
  %3 = extractvalue %struct.ethernet_t %2, 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !18)
  %4 = call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !21
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !21
  call void @llvm.lifetime.start.p0(i64 40, ptr %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp240, ptr align 1 %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr %agg.tmp240)
  %6 = load %struct.ipv4_t, ptr %ipv4, align 8
  %7 = extractvalue %struct.ipv4_t %6, 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !28)
  %8 = call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !31
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !31
  call void @llvm.lifetime.start.p0(i64 32, ptr %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp741, ptr align 1 %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr %agg.tmp741)
  %10 = load %struct.tcp_t, ptr %tcp, align 8
  %11 = extractvalue %struct.tcp_t %10, 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %12 = load %struct.tcp_t, ptr %tcp, align 8
  %13 = extractvalue %struct.tcp_t %12, 1
  %conv12 = sext i4 %13 to i32
  %sub = shl nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %n.0 = phi i32 [ 0, %if.then10 ], [ %n.1, %cleanup ]
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38

while.body:                                       ; preds = %while.cond
  %14 = call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %14, label %if.end26 [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i42)
  store i8 %14, ptr %out.addr.i42, align 1, !tbaa !24
  %15 = load i8, ptr %out.addr.i42, align 1
  call void @llvm.primate.output.i8.i32(i8 %15, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i42)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %cleanup

while.body19:                                     ; preds = %while.cond17
  call void @llvm.experimental.noalias.scope.decl(metadata !38)
  %16 = call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %16, ptr %tmp, align 8
  %17 = load i128, ptr %tmp, align 8, !tbaa !41
  store i128 %17, ptr %indirect-arg-temp, align 8, !tbaa !41
  call void @llvm.lifetime.start.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.start.p0(i64 16, ptr %out.addr.i44)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %indirect-arg-temp43, ptr align 1 %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !41
  store i128 %out.i, ptr %out.addr.i44, align 8, !tbaa !41
  %18 = load i128, ptr %out.addr.i44, align 8
  call void @llvm.primate.output.i128.i32(i128 %18, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.end.p0(i64 16, ptr %out.addr.i44)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !43

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i)
  store i8 %14, ptr %out.addr.i, align 1, !tbaa !24
  %19 = load i8, ptr %out.addr.i, align 1
  call void @llvm.primate.output.i8.i32(i8 %19, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i)
  br label %if.end26

if.end26:                                         ; preds = %while.body, %if.then23
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  %inc = add nsw i32 %n.0, 1
  br label %cleanup

cleanup:                                          ; preds = %while.cond17, %if.end26
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end26 ], [ 3, %while.cond17 ]
  %n.1 = phi i32 [ %inc, %if.end26 ], [ %n.0, %while.cond17 ]
  %hdr_byte_left.3 = phi i32 [ %hdr_byte_left.2, %if.end26 ], [ %hdr_byte_left.1, %while.cond17 ]
  %switch = icmp ult i32 %cleanup.dest.slot.0, 1
  br i1 %switch, label %while.cond, label %if.end38

if.then33:                                        ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !45)
  %20 = call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  store %struct.udp_t %20, ptr %ref.tmp34, align 8
  %21 = load i64, ptr %ref.tmp34, align 8, !tbaa !48
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
  store i64 %21, ptr %agg.tmp35, align 8, !tbaa !48
  call void @llvm.lifetime.start.p0(i64 8, ptr %agg.tmp3545)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp3545, ptr align 1 %agg.tmp35, i64 8, i1 false)
  %22 = load %struct.udp_t, ptr %agg.tmp3545, align 8
  call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %22, i32 8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %agg.tmp3545)
  br label %if.end38

if.end38:                                         ; preds = %if.then, %while.cond, %cleanup, %if.then5, %if.then33, %entry
  call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}

; *** IR Dump After PrimateStructToAggre on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %agg.tmp3545 = alloca %struct.udp_t, align 8
  %out.addr.i44 = alloca i128, align 8
  %indirect-arg-temp43 = alloca i128, align 8
  %out.addr.i42 = alloca i8, align 1
  %out.addr.i = alloca i8, align 1
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !8)
  %0 = call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.lifetime.start.p0(i64 24, ptr %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp39, ptr align 1 %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr %agg.tmp39)
  %2 = load %struct.ethernet_t, ptr %eth, align 8
  %3 = extractvalue %struct.ethernet_t %2, 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !18)
  %4 = call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !21
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !21
  call void @llvm.lifetime.start.p0(i64 40, ptr %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp240, ptr align 1 %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr %agg.tmp240)
  %6 = load %struct.ipv4_t, ptr %ipv4, align 8
  %7 = extractvalue %struct.ipv4_t %6, 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !28)
  %8 = call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !31
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !31
  call void @llvm.lifetime.start.p0(i64 32, ptr %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp741, ptr align 1 %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr %agg.tmp741)
  %10 = load %struct.tcp_t, ptr %tcp, align 8
  %11 = extractvalue %struct.tcp_t %10, 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %12 = load %struct.tcp_t, ptr %tcp, align 8
  %13 = extractvalue %struct.tcp_t %12, 1
  %conv12 = sext i4 %13 to i32
  %sub = shl nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %n.0 = phi i32 [ 0, %if.then10 ], [ %n.1, %cleanup ]
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38

while.body:                                       ; preds = %while.cond
  %14 = call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %14, label %if.end26 [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i42)
  store i8 %14, ptr %out.addr.i42, align 1, !tbaa !24
  %15 = load i8, ptr %out.addr.i42, align 1
  call void @llvm.primate.output.i8.i32(i8 %15, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i42)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %cleanup

while.body19:                                     ; preds = %while.cond17
  call void @llvm.experimental.noalias.scope.decl(metadata !38)
  %16 = call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %16, ptr %tmp, align 8
  %17 = load i128, ptr %tmp, align 8, !tbaa !41
  store i128 %17, ptr %indirect-arg-temp, align 8, !tbaa !41
  call void @llvm.lifetime.start.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.start.p0(i64 16, ptr %out.addr.i44)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %indirect-arg-temp43, ptr align 1 %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !41
  store i128 %out.i, ptr %out.addr.i44, align 8, !tbaa !41
  %18 = load i128, ptr %out.addr.i44, align 8
  call void @llvm.primate.output.i128.i32(i128 %18, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.end.p0(i64 16, ptr %out.addr.i44)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !43

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i)
  store i8 %14, ptr %out.addr.i, align 1, !tbaa !24
  %19 = load i8, ptr %out.addr.i, align 1
  call void @llvm.primate.output.i8.i32(i8 %19, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i)
  br label %if.end26

if.end26:                                         ; preds = %while.body, %if.then23
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  %inc = add nsw i32 %n.0, 1
  br label %cleanup

cleanup:                                          ; preds = %while.cond17, %if.end26
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end26 ], [ 3, %while.cond17 ]
  %n.1 = phi i32 [ %inc, %if.end26 ], [ %n.0, %while.cond17 ]
  %hdr_byte_left.3 = phi i32 [ %hdr_byte_left.2, %if.end26 ], [ %hdr_byte_left.1, %while.cond17 ]
  %switch = icmp ult i32 %cleanup.dest.slot.0, 1
  br i1 %switch, label %while.cond, label %if.end38

if.then33:                                        ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !45)
  %20 = call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  store %struct.udp_t %20, ptr %ref.tmp34, align 8
  %21 = load i64, ptr %ref.tmp34, align 8, !tbaa !48
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
  store i64 %21, ptr %agg.tmp35, align 8, !tbaa !48
  call void @llvm.lifetime.start.p0(i64 8, ptr %agg.tmp3545)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp3545, ptr align 1 %agg.tmp35, i64 8, i1 false)
  %22 = load %struct.udp_t, ptr %agg.tmp3545, align 8
  call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %22, i32 8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %agg.tmp3545)
  br label %if.end38

if.end38:                                         ; preds = %if.then, %while.cond, %cleanup, %if.then5, %if.then33, %entry
  call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
Running function passes across an SCC: (_Z12primate_mainv)
Compiling to primate CPU: 
EarlyCSE skipping noalias intrinsic:   call void @llvm.experimental.noalias.scope.decl(metadata !8)
EarlyCSE CVP: Add conditional value for 'cmp' as i1 true in if.then
EarlyCSE skipping noalias intrinsic:   call void @llvm.experimental.noalias.scope.decl(metadata !18)
EarlyCSE skipping noalias intrinsic:   call void @llvm.experimental.noalias.scope.decl(metadata !28)
EarlyCSE CVP: Add conditional value for 'cmp9' as i1 true in if.then10
EarlyCSE CSE LOAD:   %12 = load %struct.tcp_t, ptr %tcp, align 8  to:   %10 = load %struct.tcp_t, ptr %tcp, align 8
EarlyCSE CSE:   %12 = extractvalue %struct.tcp_t %10, 1  to:   %11 = extractvalue %struct.tcp_t %10, 1
EarlyCSE CVP: Add conditional value for 'cmp13' as i1 true in while.body
EarlyCSE CSE LOAD:   %13 = load i8, ptr %out.addr.i42, align 1  to:   store i8 %12, ptr %out.addr.i42, align 1, !tbaa !23
EarlyCSE CVP: Add conditional value for 'cmp18' as i1 true in while.body19
EarlyCSE skipping noalias intrinsic:   call void @llvm.experimental.noalias.scope.decl(metadata !38)
EarlyCSE CSE LOAD:   %14 = load i128, ptr %tmp, align 8, !tbaa !40  to:   store i128 %13, ptr %tmp, align 8
EarlyCSE CSE LOAD:   %14 = load i128, ptr %out.addr.i44, align 8  to:   store i128 %out.i, ptr %out.addr.i44, align 8, !tbaa !40
EarlyCSE CSE LOAD:   %14 = load i8, ptr %out.addr.i, align 1  to:   store i8 %12, ptr %out.addr.i, align 1, !tbaa !23
EarlyCSE skipping noalias intrinsic:   call void @llvm.experimental.noalias.scope.decl(metadata !45)
; *** IR Dump After EarlyCSEPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %agg.tmp3545 = alloca %struct.udp_t, align 8
  %out.addr.i44 = alloca i128, align 8
  %indirect-arg-temp43 = alloca i128, align 8
  %out.addr.i42 = alloca i8, align 1
  %out.addr.i = alloca i8, align 1
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !8)
  %0 = call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.lifetime.start.p0(i64 24, ptr %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp39, ptr align 1 %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr %agg.tmp39)
  %2 = load %struct.ethernet_t, ptr %eth, align 8
  %3 = extractvalue %struct.ethernet_t %2, 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !18)
  %4 = call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !21
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !21
  call void @llvm.lifetime.start.p0(i64 40, ptr %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp240, ptr align 1 %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr %agg.tmp240)
  %6 = load %struct.ipv4_t, ptr %ipv4, align 8
  %7 = extractvalue %struct.ipv4_t %6, 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !28)
  %8 = call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !31
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !31
  call void @llvm.lifetime.start.p0(i64 32, ptr %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp741, ptr align 1 %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr %agg.tmp741)
  %10 = load %struct.tcp_t, ptr %tcp, align 8
  %11 = extractvalue %struct.tcp_t %10, 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %conv12 = sext i4 %11 to i32
  %sub = shl nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %n.0 = phi i32 [ 0, %if.then10 ], [ %n.1, %cleanup ]
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38

while.body:                                       ; preds = %while.cond
  %12 = call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %if.end26 [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i42)
  store i8 %12, ptr %out.addr.i42, align 1, !tbaa !24
  call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i42)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %cleanup

while.body19:                                     ; preds = %while.cond17
  call void @llvm.experimental.noalias.scope.decl(metadata !38)
  %13 = call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %tmp, align 8
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !41
  call void @llvm.lifetime.start.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.start.p0(i64 16, ptr %out.addr.i44)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %indirect-arg-temp43, ptr align 1 %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !41
  store i128 %out.i, ptr %out.addr.i44, align 8, !tbaa !41
  call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.end.p0(i64 16, ptr %out.addr.i44)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !43

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i)
  store i8 %12, ptr %out.addr.i, align 1, !tbaa !24
  call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i)
  br label %if.end26

if.end26:                                         ; preds = %while.body, %if.then23
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  %inc = add nsw i32 %n.0, 1
  br label %cleanup

cleanup:                                          ; preds = %while.cond17, %if.end26
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end26 ], [ 3, %while.cond17 ]
  %n.1 = phi i32 [ %inc, %if.end26 ], [ %n.0, %while.cond17 ]
  %hdr_byte_left.3 = phi i32 [ %hdr_byte_left.2, %if.end26 ], [ %hdr_byte_left.1, %while.cond17 ]
  %switch = icmp ult i32 %cleanup.dest.slot.0, 1
  br i1 %switch, label %while.cond, label %if.end38

if.then33:                                        ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !45)
  %14 = call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  store %struct.udp_t %14, ptr %ref.tmp34, align 8
  %15 = load i64, ptr %ref.tmp34, align 8, !tbaa !48
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
  store i64 %15, ptr %agg.tmp35, align 8, !tbaa !48
  call void @llvm.lifetime.start.p0(i64 8, ptr %agg.tmp3545)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp3545, ptr align 1 %agg.tmp35, i64 8, i1 false)
  %16 = load %struct.udp_t, ptr %agg.tmp3545, align 8
  call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %16, i32 8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %agg.tmp3545)
  br label %if.end38

if.end38:                                         ; preds = %if.then, %while.cond, %cleanup, %if.then5, %if.then33, %entry
  call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
Not running SpeculativeExecution because TTI->hasBranchDivergence() is false.
; *** IR Dump After SpeculativeExecutionPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %agg.tmp3545 = alloca %struct.udp_t, align 8
  %out.addr.i44 = alloca i128, align 8
  %indirect-arg-temp43 = alloca i128, align 8
  %out.addr.i42 = alloca i8, align 1
  %out.addr.i = alloca i8, align 1
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !8)
  %0 = call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.lifetime.start.p0(i64 24, ptr %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp39, ptr align 1 %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr %agg.tmp39)
  %2 = load %struct.ethernet_t, ptr %eth, align 8
  %3 = extractvalue %struct.ethernet_t %2, 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !18)
  %4 = call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !21
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !21
  call void @llvm.lifetime.start.p0(i64 40, ptr %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp240, ptr align 1 %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr %agg.tmp240)
  %6 = load %struct.ipv4_t, ptr %ipv4, align 8
  %7 = extractvalue %struct.ipv4_t %6, 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !28)
  %8 = call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !31
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !31
  call void @llvm.lifetime.start.p0(i64 32, ptr %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp741, ptr align 1 %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr %agg.tmp741)
  %10 = load %struct.tcp_t, ptr %tcp, align 8
  %11 = extractvalue %struct.tcp_t %10, 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %conv12 = sext i4 %11 to i32
  %sub = shl nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %n.0 = phi i32 [ 0, %if.then10 ], [ %n.1, %cleanup ]
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38

while.body:                                       ; preds = %while.cond
  %12 = call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %if.end26 [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i42)
  store i8 %12, ptr %out.addr.i42, align 1, !tbaa !24
  call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i42)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %cleanup

while.body19:                                     ; preds = %while.cond17
  call void @llvm.experimental.noalias.scope.decl(metadata !38)
  %13 = call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %tmp, align 8
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !41
  call void @llvm.lifetime.start.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.start.p0(i64 16, ptr %out.addr.i44)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %indirect-arg-temp43, ptr align 1 %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !41
  store i128 %out.i, ptr %out.addr.i44, align 8, !tbaa !41
  call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.end.p0(i64 16, ptr %out.addr.i44)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !43

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i)
  store i8 %12, ptr %out.addr.i, align 1, !tbaa !24
  call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i)
  br label %if.end26

if.end26:                                         ; preds = %while.body, %if.then23
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  %inc = add nsw i32 %n.0, 1
  br label %cleanup

cleanup:                                          ; preds = %while.cond17, %if.end26
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end26 ], [ 3, %while.cond17 ]
  %n.1 = phi i32 [ %inc, %if.end26 ], [ %n.0, %while.cond17 ]
  %hdr_byte_left.3 = phi i32 [ %hdr_byte_left.2, %if.end26 ], [ %hdr_byte_left.1, %while.cond17 ]
  %switch = icmp ult i32 %cleanup.dest.slot.0, 1
  br i1 %switch, label %while.cond, label %if.end38

if.then33:                                        ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !45)
  %14 = call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  store %struct.udp_t %14, ptr %ref.tmp34, align 8
  %15 = load i64, ptr %ref.tmp34, align 8, !tbaa !48
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
  store i64 %15, ptr %agg.tmp35, align 8, !tbaa !48
  call void @llvm.lifetime.start.p0(i64 8, ptr %agg.tmp3545)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp3545, ptr align 1 %agg.tmp35, i64 8, i1 false)
  %16 = load %struct.udp_t, ptr %agg.tmp3545, align 8
  call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %16, i32 8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %agg.tmp3545)
  br label %if.end38

if.end38:                                         ; preds = %if.then, %while.cond, %cleanup, %if.then5, %if.then33, %entry
  call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
Jump threading on function '_Z12primate_mainv'
LVI Getting value   %3 = extractvalue %struct.ethernet_t %2, 2 at ''
  Result = overdefined
LVI Getting block end value   %3 = extractvalue %struct.ethernet_t %2, 2 at 'entry'
PUSH:   %3 = extractvalue %struct.ethernet_t %2, 2 in entry
 compute BB 'entry' - overdefined (unknown extractvalue).
POP   %3 = extractvalue %struct.ethernet_t %2, 2 in entry = overdefined
  Result = overdefined
LVI Getting block end value   %7 = extractvalue %struct.ipv4_t %6, 1 at 'if.then'
PUSH:   %7 = extractvalue %struct.ipv4_t %6, 1 in if.then
 compute BB 'if.then' - overdefined (unknown extractvalue).
POP   %7 = extractvalue %struct.ipv4_t %6, 1 in if.then = overdefined
  Result = overdefined
LVI Getting value   %11 = extractvalue %struct.tcp_t %10, 1 at ''
  Result = overdefined
LVI Getting block end value   %11 = extractvalue %struct.tcp_t %10, 1 at 'if.then5'
PUSH:   %11 = extractvalue %struct.tcp_t %10, 1 in if.then5
 compute BB 'if.then5' - overdefined (unknown extractvalue).
POP   %11 = extractvalue %struct.tcp_t %10, 1 in if.then5 = overdefined
  Result = overdefined
LVI Getting value   %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ] at ''
  Result = overdefined
LVI Getting edge value   %mul = add nsw i32 %sub, -20 from 'if.then10' to 'while.cond'
PUSH:   %mul = add nsw i32 %sub, -20 in if.then10
PUSH:   %sub = shl nsw i32 %conv12, 2 in if.then10
PUSH:   %conv12 = sext i4 %11 to i32 in if.then10
PUSH:   %11 = extractvalue %struct.tcp_t %10, 1 in if.then10
POP   %11 = extractvalue %struct.tcp_t %10, 1 in if.then10 = constantrange<1, -8>
POP   %conv12 = sext i4 %11 to i32 in if.then10 = constantrange<1, 8>
POP   %sub = shl nsw i32 %conv12, 2 in if.then10 = constantrange<4, 29>
POP   %mul = add nsw i32 %sub, -20 in if.then10 = constantrange<-16, 9>
  Result = constantrange<-16, 9>
LVI Getting block end value   %12 = call i8 @llvm.primate.input.i8.i32(i32 1) at 'while.body'
PUSH:   %12 = call i8 @llvm.primate.input.i8.i32(i32 1) in while.body
 compute BB 'while.body' - unknown intrinsic.
POP   %12 = call i8 @llvm.primate.input.i8.i32(i32 1) in while.body = overdefined
  Result = overdefined
LVI Getting value   %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ] at ''
  Result = overdefined
LVI Getting edge value   %dec = add nsw i32 %hdr_byte_left.0, -1 from 'if.then16' to 'while.cond17'
PUSH:   %dec = add nsw i32 %hdr_byte_left.0, -1 in if.then16
PUSH:   %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ] in if.then16
PUSH:   %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ] in while.body
PUSH:   %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ] in while.cond
PUSH:   %hdr_byte_left.3 = phi i32 [ %hdr_byte_left.2, %if.end26 ], [ %hdr_byte_left.1, %while.cond17 ] in cleanup
PUSH:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ] in if.end26
PUSH:   %dec25 = add nsw i32 %hdr_byte_left.0, -1 in if.then23
PUSH:   %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ] in if.then23
 compute BB 'if.then23' - overdefined because of pred 'while.body' (non local).
POP   %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ] in if.then23 = overdefined
POP   %dec25 = add nsw i32 %hdr_byte_left.0, -1 in if.then23 = constantrange<-2147483648, 2147483647>
 compute BB 'if.end26' - overdefined because of pred (local).
POP   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ] in if.end26 = overdefined
 compute BB 'cleanup' - overdefined because of pred (local).
POP   %hdr_byte_left.3 = phi i32 [ %hdr_byte_left.2, %if.end26 ], [ %hdr_byte_left.1, %while.cond17 ] in cleanup = overdefined
 compute BB 'while.cond' - overdefined because of pred (local).
POP   %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ] in while.cond = overdefined
POP   %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ] in while.body = constantrange<1, -2147483648>
POP   %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.3, %cleanup ] in if.then16 = constantrange<1, -2147483648>
POP   %dec = add nsw i32 %hdr_byte_left.0, -1 in if.then16 = constantrange<0, 2147483647>
  Result = constantrange<0, 2147483647>
LVI Getting value   %cleanup.dest.slot.0 = phi i32 [ 0, %if.end26 ], [ 3, %while.cond17 ] at ''
  Result = overdefined
LVI Getting edge value i32 0 from 'if.end26' to 'cleanup'
  Result = constantrange<0, 1>
LVI Getting edge value i32 3 from 'while.cond17' to 'cleanup'
  Result = constantrange<3, 4>
IN BB: 
cleanup:                                          ; preds = %while.cond17, %if.end26
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end26 ], [ 3, %while.cond17 ]
  %n.1 = phi i32 [ %inc, %if.end26 ], [ %n.0, %while.cond17 ]
  %hdr_byte_left.3 = phi i32 [ %hdr_byte_left.2, %if.end26 ], [ %hdr_byte_left.1, %while.cond17 ]
  %switch = icmp ult i32 %cleanup.dest.slot.0, 1
  br i1 %switch, label %while.cond, label %if.end38
  BB 'cleanup': FOUND condition = i1 true for pred 'if.end26'.
  BB 'cleanup': FOUND condition = i1 false for pred 'while.cond17'.
  Threading edge from 'while.cond17' to 'if.end38, across block:
    
cleanup:                                          ; preds = %while.cond17, %if.end26
  %cleanup.dest.slot.0 = phi i32 [ 0, %if.end26 ], [ 3, %while.cond17 ]
  %n.1 = phi i32 [ %inc, %if.end26 ], [ %n.0, %while.cond17 ]
  %hdr_byte_left.3 = phi i32 [ %hdr_byte_left.2, %if.end26 ], [ %hdr_byte_left.1, %while.cond17 ]
  %switch = icmp ult i32 %cleanup.dest.slot.0, 1
  br i1 %switch, label %while.cond, label %if.end38

  In block 'cleanup' folding terminator:   br i1 true, label %while.cond, label %if.end38
LVI Getting value   %3 = extractvalue %struct.ethernet_t %2, 2 at ''
  Result = overdefined
LVI Getting block end value   %3 = extractvalue %struct.ethernet_t %2, 2 at 'entry'
  Result = overdefined
LVI Getting block end value   %7 = extractvalue %struct.ipv4_t %6, 1 at 'if.then'
  Result = overdefined
LVI Getting value   %11 = extractvalue %struct.tcp_t %10, 1 at ''
  Result = overdefined
LVI Getting block end value   %11 = extractvalue %struct.tcp_t %10, 1 at 'if.then5'
  Result = overdefined
LVI Getting value   %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ] at ''
  Result = overdefined
LVI Getting edge value   %mul = add nsw i32 %sub, -20 from 'if.then10' to 'while.cond'
  Result = constantrange<-16, 9>
LVI Getting block end value   %12 = call i8 @llvm.primate.input.i8.i32(i32 1) at 'while.body'
  Result = overdefined
LVI Getting value   %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ] at ''
  Result = overdefined
LVI Getting edge value   %dec = add nsw i32 %hdr_byte_left.0, -1 from 'if.then16' to 'while.cond17'
  Result = constantrange<0, 2147483647>
Looking to fold cleanup.thread into if.end38
Killing Trivial BB: 

cleanup.thread:                                   ; preds = %while.cond17
  br label %if.end38
LVI Getting value   %3 = extractvalue %struct.ethernet_t %2, 2 at ''
  Result = overdefined
LVI Getting block end value   %3 = extractvalue %struct.ethernet_t %2, 2 at 'entry'
  Result = overdefined
LVI Getting block end value   %7 = extractvalue %struct.ipv4_t %6, 1 at 'if.then'
  Result = overdefined
LVI Getting value   %11 = extractvalue %struct.tcp_t %10, 1 at ''
  Result = overdefined
LVI Getting block end value   %11 = extractvalue %struct.tcp_t %10, 1 at 'if.then5'
  Result = overdefined
LVI Getting value   %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ] at ''
  Result = overdefined
LVI Getting edge value   %mul = add nsw i32 %sub, -20 from 'if.then10' to 'while.cond'
  Result = constantrange<-16, 9>
LVI Getting block end value   %12 = call i8 @llvm.primate.input.i8.i32(i32 1) at 'while.body'
  Result = overdefined
LVI Getting value   %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ] at ''
  Result = overdefined
LVI Getting edge value   %dec = add nsw i32 %hdr_byte_left.0, -1 from 'if.then16' to 'while.cond17'
  Result = constantrange<0, 2147483647>
Deleting edge %while.cond17 -> %cleanup
	NCD %while.body, ToIDom %while.body
Deleting reachable %while.cond17 -> %cleanup
	Rebuilding subtree
	Top of subtree: %while.body
	Running Semi-NCA
Inserting edge %while.body -> %cleanup
	Reachable %while.body -> %cleanup
		NCA == %while.body
Mark %cleanupas affected, CurrentLevel 7
	Successor %while.cond, level = 4
	Successor %if.end38, level = 1
Updating NCD = %while.body
	IDom(%cleanup) = %while.body
Inserting edge %if.then23 -> %cleanup
	Reachable %if.then23 -> %cleanup
		NCA == %while.body
Deleting edge %while.body -> %if.end26
	NCD %while.body, ToIDom %while.body
IsReachableFromIDom %if.end26
	Pred %if.then23
	Support %while.body
	%if.end26 is reachable from support %while.body
Deleting reachable %while.body -> %if.end26
	Rebuilding subtree
	Top of subtree: %while.body
	Running Semi-NCA
Deleting edge %if.then23 -> %if.end26
	NCD %if.then23, ToIDom %if.then23
IsReachableFromIDom %if.end26
Deleting unreachable subtree %if.end26
Processing affected node %cleanup with NCD = %while.body, MinNode =%if.end26
Erasing node %if.end26
DeleteUnreachable: running DFS with MinNode = %while.body
Previous IDom(MinNode) = %while.cond
Running Semi-NCA
Deleting edge %if.end26 -> %cleanup
Deleting edge %cleanup -> %if.end38
	NCD %entry, ToIDom %entry
Deleting reachable %cleanup -> %if.end38
	Rebuilding subtree
The entire tree needs to be rebuilt
DomTree recalculated, skipping future batch updates
; *** IR Dump After JumpThreadingPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %agg.tmp3545 = alloca %struct.udp_t, align 8
  %out.addr.i44 = alloca i128, align 8
  %indirect-arg-temp43 = alloca i128, align 8
  %out.addr.i42 = alloca i8, align 1
  %out.addr.i = alloca i8, align 1
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !8)
  %0 = call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.lifetime.start.p0(i64 24, ptr %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp39, ptr align 1 %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr %agg.tmp39)
  %2 = load %struct.ethernet_t, ptr %eth, align 8
  %3 = extractvalue %struct.ethernet_t %2, 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !18)
  %4 = call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !21
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !21
  call void @llvm.lifetime.start.p0(i64 40, ptr %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp240, ptr align 1 %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr %agg.tmp240)
  %6 = load %struct.ipv4_t, ptr %ipv4, align 8
  %7 = extractvalue %struct.ipv4_t %6, 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !28)
  %8 = call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !31
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !31
  call void @llvm.lifetime.start.p0(i64 32, ptr %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp741, ptr align 1 %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr %agg.tmp741)
  %10 = load %struct.tcp_t, ptr %tcp, align 8
  %11 = extractvalue %struct.tcp_t %10, 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %conv12 = sext i4 %11 to i32
  %sub = shl nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %n.0 = phi i32 [ 0, %if.then10 ], [ %inc, %cleanup ]
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38

while.body:                                       ; preds = %while.cond
  %12 = call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i42)
  store i8 %12, ptr %out.addr.i42, align 1, !tbaa !24
  call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i42)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %if.end38

while.body19:                                     ; preds = %while.cond17
  call void @llvm.experimental.noalias.scope.decl(metadata !38)
  %13 = call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %tmp, align 8
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !41
  call void @llvm.lifetime.start.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.start.p0(i64 16, ptr %out.addr.i44)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %indirect-arg-temp43, ptr align 1 %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !41
  store i128 %out.i, ptr %out.addr.i44, align 8, !tbaa !41
  call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr %indirect-arg-temp43)
  call void @llvm.lifetime.end.p0(i64 16, ptr %out.addr.i44)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !43

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr %out.addr.i)
  store i8 %12, ptr %out.addr.i, align 1, !tbaa !24
  call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr %out.addr.i)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  %inc = add nsw i32 %n.0, 1
  br label %while.cond

if.then33:                                        ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !45)
  %14 = call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  store %struct.udp_t %14, ptr %ref.tmp34, align 8
  %15 = load i64, ptr %ref.tmp34, align 8, !tbaa !48
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
  store i64 %15, ptr %agg.tmp35, align 8, !tbaa !48
  call void @llvm.lifetime.start.p0(i64 8, ptr %agg.tmp3545)
  call void @llvm.memcpy.p0.p0.i64(ptr align 1 %agg.tmp3545, ptr align 1 %agg.tmp35, i64 8, i1 false)
  %16 = load %struct.udp_t, ptr %agg.tmp3545, align 8
  call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %16, i32 8)
  call void @llvm.lifetime.end.p0(i64 8, ptr %agg.tmp3545)
  br label %if.end38

if.end38:                                         ; preds = %while.cond17, %if.then, %while.cond, %if.then5, %if.then33, %entry
  call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
LVI Getting block end value   %3 = extractvalue %struct.ethernet_t %2, 2 at 'entry'
  Result = overdefined
LVI Getting block end value   %7 = extractvalue %struct.ipv4_t %6, 1 at 'if.then'
  Result = overdefined
LVI Getting block end value   %7 = extractvalue %struct.ipv4_t %6, 1 at 'if.then'
  Result = overdefined
LVI Getting block end value   %11 = extractvalue %struct.tcp_t %10, 1 at 'if.then5'
  Result = overdefined
LVI Getting block end value   %11 = extractvalue %struct.tcp_t %10, 1 at 'if.then5'
  Result = overdefined
LVI Getting block end value i4 0 at 'if.then5'
  Result = constantrange<0, 1>
LVI Getting block end value   %11 = extractvalue %struct.tcp_t %10, 1 at 'if.then10'
  Result = constantrange<1, -8>
LVI Getting block end value   %conv12 = zext nneg i4 %11 to i32 at 'if.then10'
PUSH:   %conv12 = zext nneg i4 %11 to i32 in if.then10
POP   %conv12 = zext nneg i4 %11 to i32 in if.then10 = constantrange<1, 8>
  Result = constantrange<1, 8>
LVI Getting block end value i32 2 at 'if.then10'
  Result = constantrange<2, 3>
LVI Getting block end value   %sub = shl nuw nsw i32 %conv12, 2 at 'if.then10'
  Result = constantrange<4, 29>
LVI Getting block end value i32 -20 at 'if.then10'
  Result = constantrange<-20, -19>
LVI Getting edge value   %inc = add nsw i32 %n.0, 1 from 'cleanup' to 'while.cond'
PUSH:   %inc = add nsw i32 %n.0, 1 in cleanup
PUSH:   %n.0 = phi i32 [ 0, %if.then10 ], [ %inc, %cleanup ] in cleanup
PUSH:   %n.0 = phi i32 [ 0, %if.then10 ], [ %inc, %cleanup ] in if.then23
PUSH:   %n.0 = phi i32 [ 0, %if.then10 ], [ %inc, %cleanup ] in while.body
PUSH:   %n.0 = phi i32 [ 0, %if.then10 ], [ %inc, %cleanup ] in while.cond
 compute BB 'while.cond' - overdefined because of pred (local).
POP   %n.0 = phi i32 [ 0, %if.then10 ], [ %inc, %cleanup ] in while.cond = overdefined
 compute BB 'while.body' - overdefined because of pred 'while.cond' (non local).
POP   %n.0 = phi i32 [ 0, %if.then10 ], [ %inc, %cleanup ] in while.body = overdefined
 compute BB 'if.then23' - overdefined because of pred 'while.body' (non local).
POP   %n.0 = phi i32 [ 0, %if.then10 ], [ %inc, %cleanup ] in if.then23 = overdefined
 compute BB 'cleanup' - overdefined because of pred 'if.then23' (non local).
POP   %n.0 = phi i32 [ 0, %if.then10 ], [ %inc, %cleanup ] in cleanup = overdefined
POP   %inc = add nsw i32 %n.0, 1 in cleanup = constantrange<-2147483647, -2147483648>
  Result = constantrange<-2147483647, -2147483648>
LVI Getting edge value   %mul = add nsw i32 %sub, -20 from 'if.then10' to 'while.cond'
  Result = constantrange<-16, 9>
LVI Getting edge value   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ] from 'cleanup' to 'while.cond'
PUSH:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ] in cleanup
 compute BB 'cleanup' - overdefined because of pred (local).
POP   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ] in cleanup = overdefined
  Result = overdefined
LVI Getting block end value   %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ] at 'while.cond'
  Result = overdefined
LVI Getting edge value   %mul = add nsw i32 %sub, -20 from 'if.then10' to 'while.cond'
  Result = constantrange<-16, 9>
LVI Getting block end value   %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ] at 'while.cond'
  Result = overdefined
LVI Getting block end value i32 0 at 'while.cond'
  Result = constantrange<0, 1>
LVI Getting block end value   %12 = call i8 @llvm.primate.input.i8.i32(i32 1) at 'while.body'
  Result = overdefined
LVI Getting block end value   %12 = call i8 @llvm.primate.input.i8.i32(i32 1) at 'while.body'
  Result = overdefined
LVI Getting edge value   %dec25 = add nsw i32 %hdr_byte_left.0, -1 from 'if.then23' to 'cleanup'
  Result = constantrange<-2147483648, 2147483647>
LVI Getting edge value   %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ] from 'while.body' to 'cleanup'
  Result = constantrange<1, -2147483648>
LVI Getting block end value   %n.0 = phi i32 [ 0, %if.then10 ], [ %inc, %cleanup ] at 'cleanup'
  Result = overdefined
LVI Getting block end value i32 1 at 'cleanup'
  Result = constantrange<1, 2>
LVI Getting block end value   %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ] at 'if.then16'
  Result = constantrange<1, -2147483648>
LVI Getting block end value i32 -1 at 'if.then16'
  Result = constantrange<-1, 0>
LVI Getting edge value   %dec = add nsw i32 %hdr_byte_left.0, -1 from 'if.then16' to 'while.cond17'
  Result = constantrange<0, 2147483647>
LVI Getting edge value   %sub20 = add nsw i32 %hdr_byte_left.1, -16 from 'while.body19' to 'while.cond17'
PUSH:   %sub20 = add nsw i32 %hdr_byte_left.1, -16 in while.body19
PUSH:   %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ] in while.body19
PUSH:   %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ] in while.cond17
 compute BB 'while.cond17' - overdefined because of pred (local).
POP   %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ] in while.cond17 = overdefined
POP   %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ] in while.body19 = constantrange<1, -2147483648>
POP   %sub20 = add nsw i32 %hdr_byte_left.1, -16 in while.body19 = constantrange<-15, 2147483632>
  Result = constantrange<-15, 2147483632>
LVI Getting block end value   %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ] at 'while.cond17'
  Result = overdefined
LVI Getting edge value   %dec = add nsw i32 %hdr_byte_left.0, -1 from 'if.then16' to 'while.cond17'
  Result = constantrange<0, 2147483647>
LVI Getting block end value   %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ] at 'while.cond17'
  Result = overdefined
LVI Getting block end value i32 0 at 'while.cond17'
  Result = constantrange<0, 1>
LVI Getting block end value   %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ] at 'while.body19'
  Result = constantrange<1, -2147483648>
LVI Getting block end value i32 -16 at 'while.body19'
  Result = constantrange<-16, -15>
LVI Getting block end value   %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ] at 'if.then23'
  Result = overdefined
LVI Getting block end value i32 -1 at 'if.then23'
  Result = constantrange<-1, 0>
; *** IR Dump After CorrelatedValuePropagationPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %agg.tmp3545 = alloca %struct.udp_t, align 8
  %out.addr.i44 = alloca i128, align 8
  %indirect-arg-temp43 = alloca i128, align 8
  %out.addr.i42 = alloca i8, align 1
  %out.addr.i = alloca i8, align 1
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !8)
  %0 = call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %agg.tmp39, ptr nonnull align 1 %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = load %struct.ethernet_t, ptr %eth, align 8
  %3 = extractvalue %struct.ethernet_t %2, 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !18)
  %4 = call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !21
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !21
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %agg.tmp240, ptr nonnull align 1 %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = load %struct.ipv4_t, ptr %ipv4, align 8
  %7 = extractvalue %struct.ipv4_t %6, 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !28)
  %8 = call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !31
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !31
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %agg.tmp741, ptr nonnull align 1 %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = load %struct.tcp_t, ptr %tcp, align 8
  %11 = extractvalue %struct.tcp_t %10, 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %n.0 = phi i32 [ 0, %if.then10 ], [ %inc, %cleanup ]
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38

while.body:                                       ; preds = %while.cond
  %12 = call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %out.addr.i42)
  store i8 %12, ptr %out.addr.i42, align 1, !tbaa !24
  call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %out.addr.i42)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %if.end38

while.body19:                                     ; preds = %while.cond17
  call void @llvm.experimental.noalias.scope.decl(metadata !38)
  %13 = call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %tmp, align 8
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !41
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %out.addr.i44)
  call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %indirect-arg-temp43, ptr nonnull align 1 %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !41
  store i128 %out.i, ptr %out.addr.i44, align 8, !tbaa !41
  call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %out.addr.i44)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !43

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %out.addr.i)
  store i8 %12, ptr %out.addr.i, align 1, !tbaa !24
  call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %out.addr.i)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  %inc = add nsw i32 %n.0, 1
  br label %while.cond

if.then33:                                        ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !45)
  %14 = call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  store %struct.udp_t %14, ptr %ref.tmp34, align 8
  %15 = load i64, ptr %ref.tmp34, align 8, !tbaa !48
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
  store i64 %15, ptr %agg.tmp35, align 8, !tbaa !48
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %agg.tmp3545)
  call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %agg.tmp3545, ptr nonnull align 1 %agg.tmp35, i64 8, i1 false)
  %16 = load %struct.udp_t, ptr %agg.tmp3545, align 8
  call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %16, i32 8)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %agg.tmp3545)
  br label %if.end38

if.end38:                                         ; preds = %while.cond17, %if.then, %while.cond, %if.then5, %if.then33, %entry
  call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
; *** IR Dump After SimplifyCFGPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %agg.tmp3545 = alloca %struct.udp_t, align 8
  %out.addr.i44 = alloca i128, align 8
  %indirect-arg-temp43 = alloca i128, align 8
  %out.addr.i42 = alloca i8, align 1
  %out.addr.i = alloca i8, align 1
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %tmp = alloca i128, align 8
  %indirect-arg-temp = alloca i128, align 8
  %ref.tmp34 = alloca %struct.udp_t, align 8
  %agg.tmp35 = alloca %struct.udp_t, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !8)
  %0 = call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !11
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %agg.tmp39, ptr nonnull align 1 %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = load %struct.ethernet_t, ptr %eth, align 8
  %3 = extractvalue %struct.ethernet_t %2, 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !18)
  %4 = call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !21
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !21
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %agg.tmp240, ptr nonnull align 1 %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = load %struct.ipv4_t, ptr %ipv4, align 8
  %7 = extractvalue %struct.ipv4_t %6, 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !28)
  %8 = call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !31
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !31
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %agg.tmp741, ptr nonnull align 1 %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = load %struct.tcp_t, ptr %tcp, align 8
  %11 = extractvalue %struct.tcp_t %10, 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %n.0 = phi i32 [ 0, %if.then10 ], [ %inc, %cleanup ]
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38

while.body:                                       ; preds = %while.cond
  %12 = call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %out.addr.i42)
  store i8 %12, ptr %out.addr.i42, align 1, !tbaa !24
  call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %out.addr.i42)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %if.end38

while.body19:                                     ; preds = %while.cond17
  call void @llvm.experimental.noalias.scope.decl(metadata !38)
  %13 = call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %tmp, align 8
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !41
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %out.addr.i44)
  call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %indirect-arg-temp43, ptr nonnull align 1 %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !41
  store i128 %out.i, ptr %out.addr.i44, align 8, !tbaa !41
  call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %out.addr.i44)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !43

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %out.addr.i)
  store i8 %12, ptr %out.addr.i, align 1, !tbaa !24
  call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %out.addr.i)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  %inc = add nsw i32 %n.0, 1
  br label %while.cond

if.then33:                                        ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
  call void @llvm.experimental.noalias.scope.decl(metadata !45)
  %14 = call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  store %struct.udp_t %14, ptr %ref.tmp34, align 8
  %15 = load i64, ptr %ref.tmp34, align 8, !tbaa !48
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
  store i64 %15, ptr %agg.tmp35, align 8, !tbaa !48
  call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %agg.tmp3545)
  call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %agg.tmp3545, ptr nonnull align 1 %agg.tmp35, i64 8, i1 false)
  %16 = load %struct.udp_t, ptr %agg.tmp3545, align 8
  call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %16, i32 8)
  call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %agg.tmp3545)
  br label %if.end38

if.end38:                                         ; preds = %while.cond17, %if.then, %while.cond, %if.then5, %if.then33, %entry
  call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}


INSTCOMBINE ITERATION #1 on _Z12primate_mainv
ADD:   ret void
ADD:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
ADD:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
ADD:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
ADD:   call void @llvm.primate.input.done()
ADD:   br label %while.cond
ADD:   %inc = add nsw i32 %n.0, 1
ADD:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
ADD:   br label %while.cond17, !llvm.loop !42
ADD:   %sub20 = add nsw i32 %hdr_byte_left.1, -16
ADD:   call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %out.addr.i44)
ADD:   call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
ADD:   call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
ADD:   store i128 %out.i, ptr %out.addr.i44, align 8, !tbaa !40
ADD:   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !40
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %indirect-arg-temp43, ptr nonnull align 1 %indirect-arg-temp, i64 16, i1 false)
ADD:   call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %out.addr.i44)
ADD:   call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
ADD:   store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !40
ADD:   store i128 %13, ptr %tmp, align 8
ADD:   %13 = call i128 @llvm.primate.input.i128.i32(i32 16)
IC: DCE:   call void @llvm.experimental.noalias.scope.decl(metadata !38)
ADD:   br i1 %cmp18, label %while.body19, label %if.end38
ADD:   %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
ADD:   %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
ADD:   br label %while.cond17
ADD:   call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %out.addr.i42)
ADD:   call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
ADD:   store i8 %12, ptr %out.addr.i42, align 1, !tbaa !23
ADD:   call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %out.addr.i42)
ADD:   %dec = add nsw i32 %hdr_byte_left.0, -1
ADD:   br label %cleanup
ADD:   call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %out.addr.i)
ADD:   call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
ADD:   store i8 %12, ptr %out.addr.i, align 1, !tbaa !23
ADD:   call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %out.addr.i)
ADD:   %dec25 = add nsw i32 %hdr_byte_left.0, -1
ADD:   switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]
ADD:   %12 = call i8 @llvm.primate.input.i8.i32(i32 1)
ADD:   br i1 %cmp13, label %while.body, label %if.end38
ADD:   %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
ADD:   %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ]
ADD:   %n.0 = phi i32 [ 0, %if.then10 ], [ %inc, %cleanup ]
ADD:   br label %while.cond
ADD:   %mul = add nsw i32 %sub, -20
ADD:   %sub = shl nuw nsw i32 %conv12, 2
ADD:   %conv12 = zext nneg i4 %11 to i32
ADD:   br i1 %cmp9, label %if.then10, label %if.end38
ADD:   %cmp9 = icmp sgt i4 %11, 0
ADD:   %11 = extractvalue %struct.tcp_t %10, 1
ADD:   %10 = load %struct.tcp_t, ptr %tcp, align 8
ADD:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
ADD:   call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
ADD:   %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %agg.tmp741, ptr nonnull align 1 %agg.tmp7, i64 32, i1 false)
ADD:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !30
ADD:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !30
ADD:   store %struct.tcp_t %8, ptr %ref.tmp6, align 8
ADD:   %8 = call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
IC: DCE:   call void @llvm.experimental.noalias.scope.decl(metadata !28)
ADD:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
ADD:   br label %if.end38
ADD:   call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %agg.tmp3545)
ADD:   call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %16, i32 8)
ADD:   %16 = load %struct.udp_t, ptr %agg.tmp3545, align 8
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %agg.tmp3545, ptr nonnull align 1 %agg.tmp35, i64 8, i1 false)
ADD:   call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %agg.tmp3545)
ADD:   store i64 %15, ptr %agg.tmp35, align 8, !tbaa !41
ADD:   call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
ADD:   %15 = load i64, ptr %ref.tmp34, align 8, !tbaa !41
ADD:   store %struct.udp_t %14, ptr %ref.tmp34, align 8
ADD:   %14 = call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
IC: DCE:   call void @llvm.experimental.noalias.scope.decl(metadata !39)
ADD:   call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
ADD:   switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]
ADD:   %7 = extractvalue %struct.ipv4_t %6, 1
ADD:   %6 = load %struct.ipv4_t, ptr %ipv4, align 8
ADD:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
ADD:   call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
ADD:   %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %agg.tmp240, ptr nonnull align 1 %agg.tmp2, i64 40, i1 false)
ADD:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !20
ADD:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !20
ADD:   store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
ADD:   %4 = call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
IC: DCE:   call void @llvm.experimental.noalias.scope.decl(metadata !18)
ADD:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
ADD:   br i1 %cmp, label %if.then, label %if.end38
ADD:   %cmp = icmp eq i16 %3, 2048
ADD:   %3 = extractvalue %struct.ethernet_t %2, 2
ADD:   %2 = load %struct.ethernet_t, ptr %eth, align 8
ADD:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
ADD:   call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
ADD:   %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %agg.tmp39, ptr nonnull align 1 %agg.tmp, i64 24, i1 false)
ADD:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !10
ADD:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !10
ADD:   store %struct.ethernet_t %0, ptr %ref.tmp, align 8
ADD:   %0 = call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
IC: DCE:   call void @llvm.experimental.noalias.scope.decl(metadata !8)
ADD:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
ADD:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
ADD:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
ADD:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
ADD:   %agg.tmp35 = alloca %struct.udp_t, align 8
ADD:   %ref.tmp34 = alloca %struct.udp_t, align 8
ADD:   %indirect-arg-temp = alloca i128, align 8
ADD:   %tmp = alloca i128, align 8
ADD:   %agg.tmp7 = alloca %struct.tcp_t, align 8
ADD:   %ref.tmp6 = alloca %struct.tcp_t, align 8
ADD:   %agg.tmp2 = alloca %struct.ipv4_t, align 8
ADD:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
ADD:   %agg.tmp = alloca %struct.ethernet_t, align 8
ADD:   %ref.tmp = alloca %struct.ethernet_t, align 8
ADD:   %tcp = alloca %struct.tcp_t, align 8
ADD:   %ipv4 = alloca %struct.ipv4_t, align 8
ADD:   %eth = alloca %struct.ethernet_t, align 8
ADD:   %agg.tmp39 = alloca %struct.ethernet_t, align 8
ADD:   %agg.tmp240 = alloca %struct.ipv4_t, align 8
ADD:   %agg.tmp741 = alloca %struct.tcp_t, align 8
ADD:   %out.addr.i = alloca i8, align 1
ADD:   %out.addr.i42 = alloca i8, align 1
ADD:   %indirect-arg-temp43 = alloca i128, align 8
ADD:   %out.addr.i44 = alloca i128, align 8
ADD:   %agg.tmp3545 = alloca %struct.udp_t, align 8
IC: Visiting:   %agg.tmp3545 = alloca %struct.udp_t, align 8
IC: Visiting:   %out.addr.i44 = alloca i128, align 8
IC: ERASE   call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %out.addr.i44)
ADD DEFERRED:   %out.addr.i44 = alloca i128, align 8
IC: ERASE   call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %out.addr.i44)
ADD DEFERRED:   store i128 %out.i, ptr %out.addr.i44, align 8, !tbaa !28
IC: ERASE   store i128 %out.i, ptr %out.addr.i44, align 8, !tbaa !28
ADD DEFERRED:   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28
ADD DEFERRED:   call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
IC: ERASE   %out.addr.i44 = alloca i128, align 8
IC: Visiting:   %indirect-arg-temp43 = alloca i128, align 8
IC: Visiting:   %out.addr.i42 = alloca i8, align 1
IC: ERASE   call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %out.addr.i42)
ADD DEFERRED:   %out.addr.i42 = alloca i8, align 1
IC: ERASE   call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %out.addr.i42)
ADD DEFERRED:   store i8 %12, ptr %out.addr.i42, align 1, !tbaa !17
IC: ERASE   store i8 %12, ptr %out.addr.i42, align 1, !tbaa !17
ADD DEFERRED:   %12 = call i8 @llvm.primate.input.i8.i32(i32 1)
IC: ERASE   %out.addr.i42 = alloca i8, align 1
IC: Visiting:   %out.addr.i = alloca i8, align 1
IC: ERASE   call void @llvm.lifetime.end.p0(i64 1, ptr nonnull %out.addr.i)
ADD DEFERRED:   %out.addr.i = alloca i8, align 1
IC: ERASE   call void @llvm.lifetime.start.p0(i64 1, ptr nonnull %out.addr.i)
ADD DEFERRED:   store i8 %12, ptr %out.addr.i, align 1, !tbaa !17
IC: ERASE   store i8 %12, ptr %out.addr.i, align 1, !tbaa !17
ADD DEFERRED:   %12 = call i8 @llvm.primate.input.i8.i32(i32 1)
IC: ERASE   %out.addr.i = alloca i8, align 1
IC: Visiting:   %agg.tmp741 = alloca %struct.tcp_t, align 8
IC: Visiting:   %agg.tmp240 = alloca %struct.ipv4_t, align 8
IC: Visiting:   %agg.tmp39 = alloca %struct.ethernet_t, align 8
IC: Visiting:   %eth = alloca %struct.ethernet_t, align 8
IC: Visiting:   %ipv4 = alloca %struct.ipv4_t, align 8
IC: Visiting:   %tcp = alloca %struct.tcp_t, align 8
IC: Visiting:   %ref.tmp = alloca %struct.ethernet_t, align 8
IC: Visiting:   %agg.tmp = alloca %struct.ethernet_t, align 8
IC: Visiting:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
IC: Visiting:   %agg.tmp2 = alloca %struct.ipv4_t, align 8
IC: Visiting:   %ref.tmp6 = alloca %struct.tcp_t, align 8
IC: Visiting:   %agg.tmp7 = alloca %struct.tcp_t, align 8
IC: Visiting:   %tmp = alloca i128, align 8
IC: ERASE   store i128 %13, ptr %tmp, align 8
ADD DEFERRED:   %13 = call i128 @llvm.primate.input.i128.i32(i32 16)
ADD DEFERRED:   store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !28
ADD DEFERRED:   %tmp = alloca i128, align 8
IC: ERASE   %tmp = alloca i128, align 8
IC: Visiting:   %indirect-arg-temp = alloca i128, align 8
IC: Visiting:   %ref.tmp34 = alloca %struct.udp_t, align 8
IC: Visiting:   %agg.tmp35 = alloca %struct.udp_t, align 8
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
IC: Visiting:   %0 = call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
IC: Visiting:   store %struct.ethernet_t %0, ptr %ref.tmp, align 8
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !7
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !7
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %agg.tmp39, ptr nonnull align 1 %agg.tmp, i64 24, i1 false)
IC: Mod =   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %agg.tmp39, ptr nonnull align 1 %agg.tmp, i64 24, i1 false)
    New =   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp39, ptr nonnull align 1 %agg.tmp, i64 24, i1 false)
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp39, ptr nonnull align 1 %agg.tmp, i64 24, i1 false)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp39, ptr nonnull align 1 %agg.tmp, i64 24, i1 false)
IC: Mod =   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp39, ptr nonnull align 1 %agg.tmp, i64 24, i1 false)
    New =   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp39, ptr nonnull align 8 %agg.tmp, i64 24, i1 false)
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp39, ptr nonnull align 8 %agg.tmp, i64 24, i1 false)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp39, ptr nonnull align 8 %agg.tmp, i64 24, i1 false)
IC: Visiting:   %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
IC: Visiting:   call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
IC: Visiting:   %2 = load %struct.ethernet_t, ptr %eth, align 8
IC: Visiting:   %3 = extractvalue %struct.ethernet_t %2, 2
ADD DEFERRED:   %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
ADD DEFERRED:   %3 = load i16, ptr %2, align 2
IC: Replacing   %5 = extractvalue %struct.ethernet_t %4, 2
    with   %3 = load i16, ptr %2, align 2
IC: Mod =   %3 = extractvalue %struct.ethernet_t %2, 2
    New =   %5 = extractvalue %struct.ethernet_t %4, 2
IC: ERASE   %5 = extractvalue %struct.ethernet_t %4, 2
ADD DEFERRED:   %4 = load %struct.ethernet_t, ptr %eth, align 8
IC: ERASE   %4 = load %struct.ethernet_t, ptr %eth, align 8
ADD DEFERRED:   %eth = alloca %struct.ethernet_t, align 8
ADD:   %eth = alloca %struct.ethernet_t, align 8
ADD:   %3 = load i16, ptr %2, align 2
ADD:   %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
IC: Visiting:   %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
IC: Visiting:   %3 = load i16, ptr %2, align 2
IC: Visiting:   %eth = alloca %struct.ethernet_t, align 8
IC: Visiting:   %cmp = icmp eq i16 %3, 2048
IC: Visiting:   br i1 %cmp, label %if.then, label %if.end38
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
IC: Visiting:   %4 = call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
IC: Visiting:   store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !14
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !14
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %agg.tmp240, ptr nonnull align 1 %agg.tmp2, i64 40, i1 false)
IC: Mod =   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %agg.tmp240, ptr nonnull align 1 %agg.tmp2, i64 40, i1 false)
    New =   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp240, ptr nonnull align 1 %agg.tmp2, i64 40, i1 false)
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp240, ptr nonnull align 1 %agg.tmp2, i64 40, i1 false)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp240, ptr nonnull align 1 %agg.tmp2, i64 40, i1 false)
IC: Mod =   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp240, ptr nonnull align 1 %agg.tmp2, i64 40, i1 false)
    New =   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp240, ptr nonnull align 8 %agg.tmp2, i64 40, i1 false)
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp240, ptr nonnull align 8 %agg.tmp2, i64 40, i1 false)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp240, ptr nonnull align 8 %agg.tmp2, i64 40, i1 false)
IC: Visiting:   %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
IC: Visiting:   call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
IC: Visiting:   %6 = load %struct.ipv4_t, ptr %ipv4, align 8
IC: Visiting:   %7 = extractvalue %struct.ipv4_t %6, 1
ADD DEFERRED:   %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
ADD DEFERRED:   %7 = load i8, ptr %6, align 1
IC: Replacing   %9 = extractvalue %struct.ipv4_t %8, 1
    with   %7 = load i8, ptr %6, align 1
IC: Mod =   %7 = extractvalue %struct.ipv4_t %6, 1
    New =   %9 = extractvalue %struct.ipv4_t %8, 1
IC: ERASE   %9 = extractvalue %struct.ipv4_t %8, 1
ADD DEFERRED:   %8 = load %struct.ipv4_t, ptr %ipv4, align 8
IC: ERASE   %8 = load %struct.ipv4_t, ptr %ipv4, align 8
ADD DEFERRED:   %ipv4 = alloca %struct.ipv4_t, align 8
ADD:   %ipv4 = alloca %struct.ipv4_t, align 8
ADD:   %7 = load i8, ptr %6, align 1
ADD:   %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
IC: Visiting:   %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
IC: Visiting:   %7 = load i8, ptr %6, align 1
IC: Visiting:   %ipv4 = alloca %struct.ipv4_t, align 8
IC: Visiting:   switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
IC: Visiting:   %14 = call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
IC: Visiting:   store %struct.udp_t %14, ptr %ref.tmp34, align 8
ADD DEFERRED:   %15 = extractvalue %struct.udp_t %14, 0
ADD DEFERRED:   store i64 %15, ptr %ref.tmp34, align 8
IC: ERASE   store %struct.udp_t %14, ptr %ref.tmp34, align 8
ADD DEFERRED:   %14 = call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
ADD DEFERRED:   %ref.tmp34 = alloca %struct.udp_t, align 8
ADD:   %ref.tmp34 = alloca %struct.udp_t, align 8
ADD:   %14 = call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
ADD:   store i64 %15, ptr %ref.tmp34, align 8
ADD:   %15 = extractvalue %struct.udp_t %14, 0
IC: Visiting:   %15 = extractvalue %struct.udp_t %14, 0
IC: Visiting:   store i64 %15, ptr %ref.tmp34, align 8
IC: Visiting:   %14 = call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
IC: Visiting:   %ref.tmp34 = alloca %struct.udp_t, align 8
IC: Visiting:   %16 = load i64, ptr %ref.tmp34, align 8, !tbaa !32
IC: Replacing   %16 = load i64, ptr %ref.tmp34, align 8, !tbaa !32
    with   %15 = extractvalue %struct.udp_t %14, 0
IC: Mod =   %16 = load i64, ptr %ref.tmp34, align 8, !tbaa !32
    New =   %16 = load i64, ptr %ref.tmp34, align 8, !tbaa !32
IC: ERASE   %16 = load i64, ptr %ref.tmp34, align 8, !tbaa !32
ADD DEFERRED:   %ref.tmp34 = alloca %struct.udp_t, align 8
ADD:   %ref.tmp34 = alloca %struct.udp_t, align 8
IC: Visiting:   %ref.tmp34 = alloca %struct.udp_t, align 8
IC: ERASE   store i64 %15, ptr %ref.tmp34, align 8
ADD DEFERRED:   %15 = extractvalue %struct.udp_t %14, 0
ADD DEFERRED:   store i64 %15, ptr %agg.tmp35, align 8, !tbaa !32
ADD DEFERRED:   %ref.tmp34 = alloca %struct.udp_t, align 8
IC: ERASE   call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %ref.tmp34) #1
ADD DEFERRED:   call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
IC: ERASE   call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %ref.tmp34) #1
IC: ERASE   %ref.tmp34 = alloca %struct.udp_t, align 8
ADD:   %15 = extractvalue %struct.udp_t %14, 0
IC: Visiting:   %15 = extractvalue %struct.udp_t %14, 0
IC: Visiting:   store i64 %15, ptr %agg.tmp35, align 8, !tbaa !32
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %agg.tmp3545)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %agg.tmp3545, ptr nonnull align 1 %agg.tmp35, i64 8, i1 false)
IC: Mod =   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %agg.tmp3545, ptr nonnull align 1 %agg.tmp35, i64 8, i1 false)
    New =   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp3545, ptr nonnull align 1 %agg.tmp35, i64 8, i1 false)
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp3545, ptr nonnull align 1 %agg.tmp35, i64 8, i1 false)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp3545, ptr nonnull align 1 %agg.tmp35, i64 8, i1 false)
IC: Mod =   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp3545, ptr nonnull align 1 %agg.tmp35, i64 8, i1 false)
    New =   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp3545, ptr nonnull align 8 %agg.tmp35, i64 8, i1 false)
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp3545, ptr nonnull align 8 %agg.tmp35, i64 8, i1 false)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp3545, ptr nonnull align 8 %agg.tmp35, i64 8, i1 false)
ADD DEFERRED:   %16 = load i64, ptr %agg.tmp35, align 8
ADD DEFERRED:   store i64 %16, ptr %agg.tmp3545, align 8
IC: Mod =   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp3545, ptr nonnull align 8 %agg.tmp35, i64 8, i1 false)
    New =   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp3545, ptr nonnull align 8 %agg.tmp35, i64 0, i1 false)
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp3545, ptr nonnull align 8 %agg.tmp35, i64 0, i1 false)
ADD:   store i64 %16, ptr %agg.tmp3545, align 8
ADD:   %16 = load i64, ptr %agg.tmp35, align 8
IC: Visiting:   %16 = load i64, ptr %agg.tmp35, align 8
Captured?:   %agg.tmp35 = alloca %struct.udp_t, align 8 = not captured
IC: Replacing   %16 = load i64, ptr %agg.tmp35, align 8
    with   %15 = extractvalue %struct.udp_t %14, 0
IC: Mod =   %16 = load i64, ptr %agg.tmp35, align 8
    New =   %16 = load i64, ptr %agg.tmp35, align 8
IC: ERASE   %16 = load i64, ptr %agg.tmp35, align 8
ADD DEFERRED:   %agg.tmp35 = alloca %struct.udp_t, align 8
ADD:   %agg.tmp35 = alloca %struct.udp_t, align 8
IC: Visiting:   %agg.tmp35 = alloca %struct.udp_t, align 8
IC: Visiting:   store i64 %15, ptr %agg.tmp3545, align 8
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp3545, ptr nonnull align 8 %agg.tmp35, i64 0, i1 false)
IC: ERASE   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp3545, ptr nonnull align 8 %agg.tmp35, i64 0, i1 false)
ADD DEFERRED:   %agg.tmp3545 = alloca %struct.udp_t, align 8
ADD DEFERRED:   %agg.tmp35 = alloca %struct.udp_t, align 8
ADD DEFERRED:   store i64 %15, ptr %agg.tmp35, align 8, !tbaa !32
ADD:   store i64 %15, ptr %agg.tmp35, align 8, !tbaa !32
ADD:   %agg.tmp35 = alloca %struct.udp_t, align 8
ADD:   %agg.tmp3545 = alloca %struct.udp_t, align 8
IC: Visiting:   %agg.tmp3545 = alloca %struct.udp_t, align 8
IC: Visiting:   %agg.tmp35 = alloca %struct.udp_t, align 8
IC: ERASE   store i64 %15, ptr %agg.tmp35, align 8, !tbaa !32
ADD DEFERRED:   %15 = extractvalue %struct.udp_t %14, 0
ADD DEFERRED:   store i64 %15, ptr %agg.tmp3545, align 8
ADD DEFERRED:   %agg.tmp35 = alloca %struct.udp_t, align 8
IC: ERASE   %agg.tmp35 = alloca %struct.udp_t, align 8
ADD:   store i64 %15, ptr %agg.tmp3545, align 8
ADD:   %15 = extractvalue %struct.udp_t %14, 0
IC: Visiting:   %15 = extractvalue %struct.udp_t %14, 0
IC: Visiting:   store i64 %15, ptr %agg.tmp3545, align 8
IC: Visiting:   %16 = load %struct.udp_t, ptr %agg.tmp3545, align 8
ADD DEFERRED:   %.unpack = load i64, ptr %agg.tmp3545, align 8
ADD DEFERRED:   %16 = insertvalue %struct.udp_t poison, i64 %.unpack, 0
IC: Replacing   %17 = load %struct.udp_t, ptr %agg.tmp3545, align 8
    with   %16 = insertvalue %struct.udp_t poison, i64 %.unpack, 0
IC: Mod =   %16 = load %struct.udp_t, ptr %agg.tmp3545, align 8
    New =   %17 = load %struct.udp_t, ptr %agg.tmp3545, align 8
IC: ERASE   %17 = load %struct.udp_t, ptr %agg.tmp3545, align 8
ADD DEFERRED:   %agg.tmp3545 = alloca %struct.udp_t, align 8
ADD:   %agg.tmp3545 = alloca %struct.udp_t, align 8
ADD:   %16 = insertvalue %struct.udp_t poison, i64 %.unpack, 0
ADD:   %.unpack = load i64, ptr %agg.tmp3545, align 8
IC: Visiting:   %.unpack = load i64, ptr %agg.tmp3545, align 8
IC: Replacing   %.unpack = load i64, ptr %agg.tmp3545, align 8
    with   %15 = extractvalue %struct.udp_t %14, 0
IC: Mod =   %.unpack = load i64, ptr %agg.tmp3545, align 8
    New =   %.unpack = load i64, ptr %agg.tmp3545, align 8
IC: ERASE   %.unpack = load i64, ptr %agg.tmp3545, align 8
ADD DEFERRED:   %agg.tmp3545 = alloca %struct.udp_t, align 8
IC: Visiting:   %16 = insertvalue %struct.udp_t poison, i64 %15, 0
IC: Replacing   %16 = insertvalue %struct.udp_t poison, i64 %15, 0
    with   %14 = call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
IC: Mod =   %16 = insertvalue %struct.udp_t poison, i64 %15, 0
    New =   %16 = insertvalue %struct.udp_t poison, i64 %15, 0
IC: ERASE   %16 = insertvalue %struct.udp_t poison, i64 %15, 0
ADD DEFERRED:   %15 = extractvalue %struct.udp_t %14, 0
ADD DEFERRED:   store i64 %15, ptr %agg.tmp3545, align 8
ADD:   store i64 %15, ptr %agg.tmp3545, align 8
ADD:   %15 = extractvalue %struct.udp_t %14, 0
IC: Visiting:   %15 = extractvalue %struct.udp_t %14, 0
IC: Visiting:   store i64 %15, ptr %agg.tmp3545, align 8
IC: Visiting:   %agg.tmp3545 = alloca %struct.udp_t, align 8
IC: ERASE   store i64 %15, ptr %agg.tmp3545, align 8
ADD DEFERRED:   %15 = extractvalue %struct.udp_t %14, 0
ADD DEFERRED:   %agg.tmp3545 = alloca %struct.udp_t, align 8
IC: ERASE   call void @llvm.lifetime.end.p0(i64 8, ptr nonnull %agg.tmp3545)
ADD DEFERRED:   call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %agg.tmp3545)
IC: ERASE   call void @llvm.lifetime.start.p0(i64 8, ptr nonnull %agg.tmp3545)
IC: ERASE   %agg.tmp3545 = alloca %struct.udp_t, align 8
IC: ERASE   %15 = extractvalue %struct.udp_t %14, 0
ADD DEFERRED:   %14 = call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
ADD DEFERRED:   call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
ADD:   %14 = call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
IC: Visiting:   %14 = call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
IC: Visiting:   call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
IC: Visiting:   br label %if.end38
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
IC: Visiting:   %8 = call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
IC: Visiting:   store %struct.tcp_t %8, ptr %ref.tmp6, align 8
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !21
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !21
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %agg.tmp741, ptr nonnull align 1 %agg.tmp7, i64 32, i1 false)
IC: Mod =   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %agg.tmp741, ptr nonnull align 1 %agg.tmp7, i64 32, i1 false)
    New =   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp741, ptr nonnull align 1 %agg.tmp7, i64 32, i1 false)
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp741, ptr nonnull align 1 %agg.tmp7, i64 32, i1 false)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp741, ptr nonnull align 1 %agg.tmp7, i64 32, i1 false)
IC: Mod =   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp741, ptr nonnull align 1 %agg.tmp7, i64 32, i1 false)
    New =   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp741, ptr nonnull align 8 %agg.tmp7, i64 32, i1 false)
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp741, ptr nonnull align 8 %agg.tmp7, i64 32, i1 false)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %agg.tmp741, ptr nonnull align 8 %agg.tmp7, i64 32, i1 false)
IC: Visiting:   %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
IC: Visiting:   call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
IC: Visiting:   %10 = load %struct.tcp_t, ptr %tcp, align 8
IC: Visiting:   %11 = extractvalue %struct.tcp_t %10, 1
ADD DEFERRED:   %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
ADD DEFERRED:   %11 = load i4, ptr %10, align 1
IC: Replacing   %13 = extractvalue %struct.tcp_t %12, 1
    with   %11 = load i4, ptr %10, align 1
IC: Mod =   %11 = extractvalue %struct.tcp_t %10, 1
    New =   %13 = extractvalue %struct.tcp_t %12, 1
IC: ERASE   %13 = extractvalue %struct.tcp_t %12, 1
ADD DEFERRED:   %12 = load %struct.tcp_t, ptr %tcp, align 8
IC: ERASE   %12 = load %struct.tcp_t, ptr %tcp, align 8
ADD DEFERRED:   %tcp = alloca %struct.tcp_t, align 8
ADD:   %tcp = alloca %struct.tcp_t, align 8
ADD:   %11 = load i4, ptr %10, align 1
ADD:   %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
IC: Visiting:   %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
IC: Visiting:   %11 = load i4, ptr %10, align 1
IC: Visiting:   %tcp = alloca %struct.tcp_t, align 8
IC: Visiting:   %cmp9 = icmp sgt i4 %11, 0
IC: Visiting:   br i1 %cmp9, label %if.then10, label %if.end38
IC: Visiting:   %conv12 = zext nneg i4 %11 to i32
IC: Visiting:   %sub = shl nuw nsw i32 %conv12, 2
IC: Visiting:   %mul = add nsw i32 %sub, -20
IC: Visiting:   br label %while.cond
IC: Visiting:   %n.0 = phi i32 [ 0, %if.then10 ], [ %inc, %cleanup ]
IC: Replacing   %n.0 = phi i32 [ 0, %if.then10 ], [ %inc, %cleanup ]
    with i32 poison
IC: Mod =   %n.0 = phi i32 [ 0, %if.then10 ], [ %inc, %cleanup ]
    New =   %n.0 = phi i32 [ 0, %if.then10 ], [ %inc, %cleanup ]
IC: ERASE   %n.0 = phi i32 [ 0, %if.then10 ], [ %inc, %cleanup ]
ADD DEFERRED:   %inc = add nsw i32 poison, 1
IC: ERASE   %inc = add nsw i32 poison, 1
IC: Visiting:   %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ]
IC: Visiting:   %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
IC: Visiting:   br i1 %cmp13, label %while.body, label %if.end38
IC: Visiting:   %12 = call i8 @llvm.primate.input.i8.i32(i32 1)
IC: Visiting:   switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]
IC: Visiting:   %dec25 = add nsw i32 %hdr_byte_left.0, -1
IC: Visiting:   call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
IC: Visiting:   br label %cleanup
IC: Visiting:   %dec = add nsw i32 %hdr_byte_left.0, -1
IC: Visiting:   call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
IC: Visiting:   br label %while.cond17
IC: Visiting:   %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
IC: Visiting:   %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
IC: Visiting:   br i1 %cmp18, label %while.body19, label %if.end38
IC: Visiting:   %13 = call i128 @llvm.primate.input.i128.i32(i32 16)
IC: Visiting:   store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !28
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %indirect-arg-temp43, ptr nonnull align 1 %indirect-arg-temp, i64 16, i1 false)
IC: Mod =   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 1 %indirect-arg-temp43, ptr nonnull align 1 %indirect-arg-temp, i64 16, i1 false)
    New =   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %indirect-arg-temp43, ptr nonnull align 1 %indirect-arg-temp, i64 16, i1 false)
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %indirect-arg-temp43, ptr nonnull align 1 %indirect-arg-temp, i64 16, i1 false)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %indirect-arg-temp43, ptr nonnull align 1 %indirect-arg-temp, i64 16, i1 false)
IC: Mod =   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %indirect-arg-temp43, ptr nonnull align 1 %indirect-arg-temp, i64 16, i1 false)
    New =   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %indirect-arg-temp43, ptr nonnull align 8 %indirect-arg-temp, i64 16, i1 false)
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %indirect-arg-temp43, ptr nonnull align 8 %indirect-arg-temp, i64 16, i1 false)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr nonnull align 8 %indirect-arg-temp43, ptr nonnull align 8 %indirect-arg-temp, i64 16, i1 false)
IC: Visiting:   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28
IC: Visiting:   call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
IC: Visiting:   %sub20 = add nsw i32 %hdr_byte_left.1, -16
IC: Visiting:   br label %while.cond17, !llvm.loop !30
IC: Visiting:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
IC: Visiting:   br label %while.cond
IC: Visiting:   call void @llvm.primate.input.done()
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
IC: Visiting:   ret void


[IC] Iteration limit #1 on _Z12primate_mainv reached; stopping without verifying fixpoint
; *** IR Dump After InstCombinePass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  %0 = call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  %4 = call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  %8 = call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38

while.body:                                       ; preds = %while.cond
  %12 = call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %if.end38

while.body19:                                     ; preds = %while.cond17
  %13 = call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !29
  call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !31

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  br label %while.cond

if.then33:                                        ; preds = %if.then
  %14 = call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %while.cond17, %if.then, %while.cond, %if.then5, %if.then33, %entry
  call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
; *** IR Dump After AggressiveInstCombinePass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  %0 = call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  %4 = call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  %8 = call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38

while.body:                                       ; preds = %while.cond
  %12 = call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %if.end38

while.body19:                                     ; preds = %while.cond17
  %13 = call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !29
  call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !31

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  br label %while.cond

if.then33:                                        ; preds = %if.then
  %14 = call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %while.cond17, %if.then, %while.cond, %if.then5, %if.then33, %entry
  call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
; *** IR Dump After LibCallsShrinkWrapPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  %0 = call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  %4 = call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  %8 = call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38

while.body:                                       ; preds = %while.cond
  %12 = call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %if.end38

while.body19:                                     ; preds = %while.cond17
  %13 = call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !29
  call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !31

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  br label %while.cond

if.then33:                                        ; preds = %if.then
  %14 = call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %while.cond17, %if.then, %while.cond, %if.then5, %if.then33, %entry
  call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
Marked as tail call candidate:   %0 = call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
Marked as tail call candidate:   call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
Marked as tail call candidate:   call void @llvm.primate.input.done()
Marked as tail call candidate:   %4 = call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
Marked as tail call candidate:   call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
Marked as tail call candidate:   %14 = call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
Marked as tail call candidate:   call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
Marked as tail call candidate:   %8 = call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
Marked as tail call candidate:   call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
Marked as tail call candidate:   %12 = call i8 @llvm.primate.input.i8.i32(i32 1)
Marked as tail call candidate:   call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
Marked as tail call candidate:   call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
Marked as tail call candidate:   %13 = call i128 @llvm.primate.input.i128.i32(i32 16)
Marked as tail call candidate:   call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
; *** IR Dump After TailCallElimPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38

while.body:                                       ; preds = %while.cond
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %if.end38

while.body19:                                     ; preds = %while.cond17
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !29
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !31

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  br label %while.cond

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %while.cond17, %if.then, %while.cond, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
; *** IR Dump After SimplifyCFGPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38

while.body:                                       ; preds = %while.cond
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %if.end38

while.body19:                                     ; preds = %while.cond17
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !29
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !31

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  br label %while.cond

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %while.cond17, %if.then, %while.cond, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
Combine negations for:   %sub = mul nuw nsw i32 %conv12, 4
LINEARIZE:   %sub = mul nuw nsw i32 %conv12, 4
OPERAND:   %conv12 = zext nneg i4 %11 to i32 (1)
ADD LEAF:   %conv12 = zext nneg i4 %11 to i32 (1)
OPERAND: i32 4 (1)
ADD LEAF: i32 4 (1)
Calculated Rank[conv12] = 393229
RAIn:	mul i32	[ %conv12, #393229] [ 4, #0] 
RAOut:	mul i32	[ %conv12, #393229] [ 4, #0] 
RAOut after CSE reorder:	mul i32	[ %conv12, #393229] [ 4, #0] 
Combine negations for:   %mul = add nsw i32 %sub, -20
LINEARIZE:   %mul = add nsw i32 %sub, -20
OPERAND:   %sub = mul nuw nsw i32 %conv12, 4 (1)
ADD LEAF:   %sub = mul nuw nsw i32 %conv12, 4 (1)
OPERAND: i32 -20 (1)
ADD LEAF: i32 -20 (1)
Calculated Rank[sub] = 393230
RAIn:	add i32	[ %sub, #393230] [ -20, #0] 
RAOut:	add i32	[ %sub, #393230] [ -20, #0] 
RAOut after CSE reorder:	add i32	[ %sub, #393230] [ -20, #0] 
Combine negations for:   %dec25 = add nsw i32 %hdr_byte_left.0, -1
LINEARIZE:   %dec25 = add nsw i32 %hdr_byte_left.0, -1
OPERAND:   %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ] (1)
ADD USES LEAF:   %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ] (1)
OPERAND: i32 -1 (1)
ADD USES LEAF: i32 -1 (1)
RAIn:	add i32	[ %hdr_byte_left.0, #524289] [ -1, #0] 
RAOut:	add i32	[ %hdr_byte_left.0, #524289] [ -1, #0] 
RAOut after CSE reorder:	add i32	[ %hdr_byte_left.0, #524289] [ -1, #0] 
Combine negations for:   %dec = add nsw i32 %hdr_byte_left.0, -1
LINEARIZE:   %dec = add nsw i32 %hdr_byte_left.0, -1
OPERAND:   %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ] (1)
ADD USES LEAF:   %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ] (1)
OPERAND: i32 -1 (1)
ADD USES LEAF: i32 -1 (1)
RAIn:	add i32	[ %hdr_byte_left.0, #524289] [ -1, #0] 
RAOut:	add i32	[ %hdr_byte_left.0, #524289] [ -1, #0] 
RAOut after CSE reorder:	add i32	[ %hdr_byte_left.0, #524289] [ -1, #0] 
Combine negations for:   %sub20 = add nsw i32 %hdr_byte_left.1, -16
LINEARIZE:   %sub20 = add nsw i32 %hdr_byte_left.1, -16
OPERAND:   %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ] (1)
ADD USES LEAF:   %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ] (1)
OPERAND: i32 -16 (1)
ADD LEAF: i32 -16 (1)
RAIn:	add i32	[ %hdr_byte_left.1, #786433] [ -16, #0] 
RAOut:	add i32	[ %hdr_byte_left.1, #786433] [ -16, #0] 
RAOut after CSE reorder:	add i32	[ %hdr_byte_left.1, #786433] [ -16, #0] 
; *** IR Dump After ReassociatePass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = mul nuw nsw i32 %conv12, 4
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38

while.body:                                       ; preds = %while.cond
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %if.end38

while.body19:                                     ; preds = %while.cond17
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !29
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !31

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  br label %while.cond

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %while.cond17, %if.then, %while.cond, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
Processing condition to simplify:   %cmp = icmp eq i16 %3, 2048
Checking   %cmp = icmp eq i16 %3, 2048
   failed to decompose condition
Processing fact to add to the system: icmp eq i16 %3, 2048
Adding 'icmp eq i16 %3, 2048'
  constraint: %3 <= 2048

Top of stack : 1 22
CB: 2 19
Processing fact to add to the system: icmp eq i8 %7, 6
Adding 'icmp eq i8 %7, 6'
  constraint: %7 <= 6

Top of stack : 2 19
CB: 2 19
Processing condition to simplify:   %cmp9 = icmp sgt i4 %11, 0
Checking   %cmp9 = icmp sgt i4 %11, 0
   failed to decompose condition
Top of stack : 2 19
CB: 3 18
Processing fact to add to the system: icmp sgt i4 %11, 0
Adding 'icmp sgt i4 %11, 0'
  constraint: -1 * %11 <= -1

Adding 'icmp uge i4 %11, 0'
  constraint: -1 * %11 <= 0

Adding 'icmp ugt i4 %11, 0'
  constraint: -1 * %11 <= -1

Top of stack : 3 18
CB: 4 17
Processing condition to simplify:   %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
Checking   %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
   failed to decompose condition
Top of stack : 3 18
CB: 5 16
Processing fact to add to the system: icmp sgt i32 %hdr_byte_left.0, 0
Adding 'icmp sgt i32 %hdr_byte_left.0, 0'
  constraint: -1 * %hdr_byte_left.0 <= -1

Adding 'icmp uge i32 %hdr_byte_left.0, 0'
  constraint: -1 * %hdr_byte_left.0 <= 0

Adding 'icmp ugt i32 %hdr_byte_left.0, 0'
  constraint: -1 * %hdr_byte_left.0 <= -1

Top of stack : 5 16
CB: 8 13
Processing fact to add to the system: icmp eq i8 %12, 0
Adding 'icmp eq i8 %12, 0'
  constraint: %12 <= 0

Top of stack : 8 13
CB: 9 12
Processing condition to simplify:   %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
Checking   %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
   failed to decompose condition
Top of stack : 8 13
CB: 10 11
Processing fact to add to the system: icmp sgt i32 %hdr_byte_left.1, 0
Adding 'icmp sgt i32 %hdr_byte_left.1, 0'
  constraint: -1 * %hdr_byte_left.1 <= -1

Adding 'icmp uge i32 %hdr_byte_left.1, 0'
  constraint: -1 * %hdr_byte_left.1 <= 0

Adding 'icmp ugt i32 %hdr_byte_left.1, 0'
  constraint: -1 * %hdr_byte_left.1 <= -1

Top of stack : 10 11
CB: 14 15
Removing -1 * %hdr_byte_left.1 <= -1

Top of stack : 10 11
CB: 14 15
Removing -1 * %hdr_byte_left.1 <= 0

Top of stack : 10 11
CB: 14 15
Removing -1 * %hdr_byte_left.1 <= 0

Top of stack : 10 11
CB: 14 15
Removing -1 * %hdr_byte_left.1 <= -1

Top of stack : 8 13
CB: 14 15
Removing -1 * %12 <= 0

Top of stack : 8 13
CB: 14 15
Removing %12 <= 0

Top of stack : 5 16
CB: 14 15
Processing fact to add to the system: icmp eq i8 %12, 1
Adding 'icmp eq i8 %12, 1'
  constraint: %12 <= 1

Top of stack : 14 15
CB: 20 21
Removing -1 * %12 <= -1

Top of stack : 14 15
CB: 20 21
Removing -1 * %12 <= 0

Top of stack : 14 15
CB: 20 21
Removing %12 <= 1

Top of stack : 5 16
CB: 20 21
Removing -1 * %hdr_byte_left.0 <= -1

Top of stack : 5 16
CB: 20 21
Removing -1 * %hdr_byte_left.0 <= 0

Top of stack : 5 16
CB: 20 21
Removing -1 * %hdr_byte_left.0 <= 0

Top of stack : 5 16
CB: 20 21
Removing -1 * %hdr_byte_left.0 <= -1

Top of stack : 3 18
CB: 20 21
Removing -1 * %11 <= -1

Top of stack : 3 18
CB: 20 21
Removing -1 * %11 <= 0

Top of stack : 3 18
CB: 20 21
Removing -1 * %11 <= 0

Top of stack : 3 18
CB: 20 21
Removing -1 * %11 <= -1

Top of stack : 2 19
CB: 20 21
Removing -1 * %7 <= -6

Top of stack : 2 19
CB: 20 21
Removing -1 * %7 <= 0

Top of stack : 2 19
CB: 20 21
Removing %7 <= 6

Top of stack : 1 22
CB: 20 21
Processing fact to add to the system: icmp eq i8 %7, 17
Adding 'icmp eq i8 %7, 17'
  constraint: %7 <= 17

; *** IR Dump After ConstraintEliminationPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = mul nuw nsw i32 %conv12, 4
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38

while.body:                                       ; preds = %while.cond
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %if.end38

while.body19:                                     ; preds = %while.cond17
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !29
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !31

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  br label %while.cond

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %while.cond17, %if.then, %while.cond, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
LoopSimplify: Creating dedicated exit block if.end38.loopexit
LoopSimplify: Creating dedicated exit block if.end38.loopexit50
; *** IR Dump After LoopSimplifyPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = mul nuw nsw i32 %conv12, 4
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit50

while.body:                                       ; preds = %while.cond
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.0, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit

while.body19:                                     ; preds = %while.cond17
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !29
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !31

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  br label %while.cond

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.cond17
  br label %if.end38

if.end38.loopexit50:                              ; preds = %while.cond
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit50, %if.end38.loopexit, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
; *** IR Dump After LCSSAPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = mul nuw nsw i32 %conv12, 4
  %mul = add nsw i32 %sub, -20
  br label %while.cond

while.cond:                                       ; preds = %cleanup, %if.then10
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit50

while.body:                                       ; preds = %while.cond
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %.lcssa = phi i8 [ %12, %while.body ]
  %hdr_byte_left.0.lcssa51 = phi i32 [ %hdr_byte_left.0, %while.body ]
  %dec = add nsw i32 %hdr_byte_left.0.lcssa51, -1
  tail call void @llvm.primate.output.i8.i32(i8 %.lcssa, i32 1)
  br label %while.cond17

while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit

while.body19:                                     ; preds = %while.cond17
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !29
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !31

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  br label %while.cond

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.cond17
  br label %if.end38

if.end38.loopexit50:                              ; preds = %while.cond
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit50, %if.end38.loopexit, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
; *** IR Dump After LoopInstSimplifyPass on while.cond ***

; Preheader:
if.then10:                                        ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = mul nuw nsw i32 %conv12, 4
  %mul = add nsw i32 %sub, -20
  br label %while.cond

; Loop:
while.cond:                                       ; preds = %cleanup, %if.then10
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit50

while.body:                                       ; preds = %while.cond
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  br label %while.cond

; Exit blocks
if.end38.loopexit50:                              ; preds = %while.cond
  br label %if.end38

if.then16:                                        ; preds = %while.body
  %.lcssa = phi i8 [ %12, %while.body ]
  %hdr_byte_left.0.lcssa51 = phi i32 [ %hdr_byte_left.0, %while.body ]
  %dec = add nsw i32 %hdr_byte_left.0.lcssa51, -1
  tail call void @llvm.primate.output.i8.i32(i8 %.lcssa, i32 1)
  br label %while.cond17
In function _Z12primate_mainv: No constant terminator folding candidates found in loop while.cond
; *** IR Dump After LoopSimplifyCFGPass on while.cond ***

; Preheader:
if.then10:                                        ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = mul nuw nsw i32 %conv12, 4
  %mul = add nsw i32 %sub, -20
  br label %while.cond

; Loop:
while.cond:                                       ; preds = %cleanup, %if.then10
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit50

while.body:                                       ; preds = %while.cond
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  br label %while.cond

; Exit blocks
if.end38.loopexit50:                              ; preds = %while.cond
  br label %if.end38

if.then16:                                        ; preds = %while.body
  %.lcssa = phi i8 [ %12, %while.body ]
  %hdr_byte_left.0.lcssa51 = phi i32 [ %hdr_byte_left.0, %while.body ]
  %dec = add nsw i32 %hdr_byte_left.0.lcssa51, -1
  tail call void @llvm.primate.output.i8.i32(i8 %.lcssa, i32 1)
  br label %while.cond17
; *** IR Dump After LICMPass on while.cond ***

; Preheader:
if.then10:                                        ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = mul nuw nsw i32 %conv12, 4
  %mul = add nsw i32 %sub, -20
  br label %while.cond

; Loop:
while.cond:                                       ; preds = %cleanup, %if.then10
  %hdr_byte_left.0 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.2, %cleanup ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.0, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit50

while.body:                                       ; preds = %while.cond
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.0, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.0, %while.body ]
  br label %while.cond

; Exit blocks
if.end38.loopexit50:                              ; preds = %while.cond
  br label %if.end38

if.then16:                                        ; preds = %while.body
  %.lcssa = phi i8 [ %12, %while.body ]
  %hdr_byte_left.0.lcssa51 = phi i32 [ %hdr_byte_left.0, %while.body ]
  %dec = add nsw i32 %hdr_byte_left.0.lcssa51, -1
  tail call void @llvm.primate.output.i8.i32(i8 %.lcssa, i32 1)
  br label %while.cond17
LoopRotation: rotating Loop at depth 1 containing: %while.cond<header><exiting>,%while.body<exiting>,%if.then23,%cleanup<latch>
  Inserted PHI:   %hdr_byte_left.053 = phi i32 [ %mul, %if.then10 ], [ %hdr_byte_left.0, %while.cond ]
Inserting edge %if.then10 -> %if.end38.loopexit50
	Reachable %if.then10 -> %if.end38.loopexit50
		NCA == %if.then10
Mark %if.end38.loopexit50as affected, CurrentLevel 5
	Successor %if.end38, level = 1
Updating NCD = %if.then10
	IDom(%if.end38.loopexit50) = %if.then10
Inserting edge %if.then10 -> %while.body
	Reachable %if.then10 -> %while.body
		NCA == %if.then10
Mark %while.bodyas affected, CurrentLevel 5
	Successor %if.then23, level = 6
		Marking visited not affected %if.then23
	Successor %if.then16, level = 6
		Marking visited not affected %if.then16
	Successor %cleanup, level = 6
		Marking visited not affected %cleanup
 Next: %cleanup
	Successor %while.cond, level = 4
 Next: %if.then16
	Successor %while.cond17, level = 7
		Marking visited not affected %while.cond17
 Next: %while.cond17
	Successor %if.end38.loopexit, level = 8
		Marking visited not affected %if.end38.loopexit
	Successor %while.body19, level = 8
		Marking visited not affected %while.body19
 Next: %while.body19
	Successor %while.cond17, level = 7
 Next: %if.end38.loopexit
	Successor %if.end38, level = 1
 Next: %if.then23
	Successor %cleanup, level = 6
Updating NCD = %if.then10
	IDom(%while.body) = %if.then10
Deleting edge %if.then10 -> %while.cond
	NCD %if.then10, ToIDom %if.then10
IsReachableFromIDom %while.cond
	Pred %cleanup
	Support %if.then10
	%while.cond is reachable from support %if.then10
Deleting reachable %if.then10 -> %while.cond
	Rebuilding subtree
	Top of subtree: %if.then10
	Running Semi-NCA
Inserting edge %if.then10 -> %if.then10.while.body_crit_edge
Inserting %if.then10 -> (unreachable) %if.then10.while.body_crit_edge
After adding unreachable nodes
Inserted %if.then10 -> (prev unreachable) %if.then10.while.body_crit_edge
Inserting edge %if.then10.while.body_crit_edge -> %while.body
	Reachable %if.then10.while.body_crit_edge -> %while.body
		NCA == %if.then10
Deleting edge %if.then10 -> %while.body
	NCD %if.then10, ToIDom %if.then10
IsReachableFromIDom %while.body
	Pred %if.then10.while.body_crit_edge
	Support %if.then10
	%while.body is reachable from support %if.then10
Deleting reachable %if.then10 -> %while.body
	Rebuilding subtree
	Top of subtree: %if.then10
	Running Semi-NCA
Inserting edge %while.cond -> %while.cond.if.end38.loopexit50_crit_edge
Inserting %while.cond -> (unreachable) %while.cond.if.end38.loopexit50_crit_edge
After adding unreachable nodes
Inserted %while.cond -> (prev unreachable) %while.cond.if.end38.loopexit50_crit_edge
Inserting edge %while.cond.if.end38.loopexit50_crit_edge -> %if.end38.loopexit50
	Reachable %while.cond.if.end38.loopexit50_crit_edge -> %if.end38.loopexit50
		NCA == %if.then10
Deleting edge %while.cond -> %if.end38.loopexit50
	NCD %if.then10, ToIDom %if.then10
Deleting reachable %while.cond -> %if.end38.loopexit50
	Rebuilding subtree
	Top of subtree: %if.then10
	Running Semi-NCA
Merging: while.cond into cleanup
Inserting edge %cleanup -> %while.body
	Reachable %cleanup -> %while.body
		NCA == %while.body
Inserting edge %cleanup -> %while.cond.if.end38.loopexit50_crit_edge
	Reachable %cleanup -> %while.cond.if.end38.loopexit50_crit_edge
		NCA == %cleanup
Mark %while.cond.if.end38.loopexit50_crit_edgeas affected, CurrentLevel 8
	Successor %if.end38.loopexit50, level = 4
Updating NCD = %cleanup
	IDom(%while.cond.if.end38.loopexit50_crit_edge) = %cleanup
Deleting edge %while.cond -> %while.body
Deleting edge %while.cond -> %while.cond.if.end38.loopexit50_crit_edge
	NCD %cleanup, ToIDom %cleanup
Deleting reachable %while.cond -> %while.cond.if.end38.loopexit50_crit_edge
	Rebuilding subtree
	Top of subtree: %cleanup
	Running Semi-NCA
Deleting edge %cleanup -> %while.cond
	NCD %cleanup, ToIDom %cleanup
IsReachableFromIDom %while.cond
Deleting unreachable subtree %while.cond
Erasing node %while.cond
LoopRotation: into Loop at depth 1 containing: %while.body<header><exiting>,%if.then23,%cleanup<latch><exiting>
; *** IR Dump After LoopRotatePass on while.cond ***

; Preheader:
while.body.lr.ph:                                 ; preds = %if.then10
  br label %while.body

; Loop:
while.body:                                       ; preds = %while.body.lr.ph, %cleanup
  %hdr_byte_left.053 = phi i32 [ %mul, %while.body.lr.ph ], [ %hdr_byte_left.2, %cleanup ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %while.cond.if.end38.loopexit50_crit_edge

; Exit blocks
if.then16:                                        ; preds = %while.body
  %.lcssa = phi i8 [ %12, %while.body ]
  %hdr_byte_left.0.lcssa51 = phi i32 [ %hdr_byte_left.053, %while.body ]
  %dec = add nsw i32 %hdr_byte_left.0.lcssa51, -1
  tail call void @llvm.primate.output.i8.i32(i8 %.lcssa, i32 1)
  br label %while.cond17

while.cond.if.end38.loopexit50_crit_edge:         ; preds = %cleanup
  br label %if.end38.loopexit50
; *** IR Dump After LICMPass on while.body ***

; Preheader:
while.body.lr.ph:                                 ; preds = %if.then10
  br label %while.body

; Loop:
while.body:                                       ; preds = %while.body.lr.ph, %cleanup
  %hdr_byte_left.053 = phi i32 [ %mul, %while.body.lr.ph ], [ %hdr_byte_left.2, %cleanup ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %while.cond.if.end38.loopexit50_crit_edge

; Exit blocks
if.then16:                                        ; preds = %while.body
  %.lcssa = phi i8 [ %12, %while.body ]
  %hdr_byte_left.0.lcssa51 = phi i32 [ %hdr_byte_left.053, %while.body ]
  %dec = add nsw i32 %hdr_byte_left.0.lcssa51, -1
  tail call void @llvm.primate.output.i8.i32(i8 %.lcssa, i32 1)
  br label %while.cond17

while.cond.if.end38.loopexit50_crit_edge:         ; preds = %cleanup
  br label %if.end38.loopexit50
Unswitching loop in _Z12primate_mainv: Loop at depth 1 containing: %while.body<header><exiting>,%if.then23,%cleanup<latch><exiting>

; *** IR Dump After SimpleLoopUnswitchPass on while.body ***

; Preheader:
while.body.lr.ph:                                 ; preds = %if.then10
  br label %while.body

; Loop:
while.body:                                       ; preds = %while.body.lr.ph, %cleanup
  %hdr_byte_left.053 = phi i32 [ %mul, %while.body.lr.ph ], [ %hdr_byte_left.2, %cleanup ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %while.cond.if.end38.loopexit50_crit_edge

; Exit blocks
if.then16:                                        ; preds = %while.body
  %.lcssa = phi i8 [ %12, %while.body ]
  %hdr_byte_left.0.lcssa51 = phi i32 [ %hdr_byte_left.053, %while.body ]
  %dec = add nsw i32 %hdr_byte_left.0.lcssa51, -1
  tail call void @llvm.primate.output.i8.i32(i8 %.lcssa, i32 1)
  br label %while.cond17

while.cond.if.end38.loopexit50_crit_edge:         ; preds = %cleanup
  br label %if.end38.loopexit50
; *** IR Dump After LoopInstSimplifyPass on while.cond17 ***

; Preheader:
if.then16:                                        ; preds = %while.body
  %.lcssa = phi i8 [ %12, %while.body ]
  %hdr_byte_left.0.lcssa51 = phi i32 [ %hdr_byte_left.053, %while.body ]
  %dec = add nsw i32 %hdr_byte_left.0.lcssa51, -1
  tail call void @llvm.primate.output.i8.i32(i8 %.lcssa, i32 1)
  br label %while.cond17

; Loop:
while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit

while.body19:                                     ; preds = %while.cond17
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !28
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !30

; Exit blocks
if.end38.loopexit:                                ; preds = %while.cond17
  br label %if.end38
In function _Z12primate_mainv: No constant terminator folding candidates found in loop while.cond17
; *** IR Dump After LoopSimplifyCFGPass on while.cond17 ***

; Preheader:
if.then16:                                        ; preds = %while.body
  %.lcssa = phi i8 [ %12, %while.body ]
  %hdr_byte_left.0.lcssa51 = phi i32 [ %hdr_byte_left.053, %while.body ]
  %dec = add nsw i32 %hdr_byte_left.0.lcssa51, -1
  tail call void @llvm.primate.output.i8.i32(i8 %.lcssa, i32 1)
  br label %while.cond17

; Loop:
while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit

while.body19:                                     ; preds = %while.cond17
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !28
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !30

; Exit blocks
if.end38.loopexit:                                ; preds = %while.cond17
  br label %if.end38
Captured?:   %indirect-arg-temp43 = alloca i128, align 8 = not captured
Starting Memory SSA clobber for   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28 is MemoryUse(39)
Optimized Memory SSA clobber for   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28 is 39 = MemoryDef(38)
Result Memory SSA clobber [SkipSelf = 1] for   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28 is 39 = MemoryDef(38)
Captured?:   %indirect-arg-temp = alloca i128, align 8 = not captured
; *** IR Dump After LICMPass on while.cond17 ***

; Preheader:
if.then16:                                        ; preds = %while.body
  %.lcssa = phi i8 [ %12, %while.body ]
  %hdr_byte_left.0.lcssa51 = phi i32 [ %hdr_byte_left.053, %while.body ]
  %dec = add nsw i32 %hdr_byte_left.0.lcssa51, -1
  tail call void @llvm.primate.output.i8.i32(i8 %.lcssa, i32 1)
  br label %while.cond17

; Loop:
while.cond17:                                     ; preds = %while.body19, %if.then16
  %hdr_byte_left.1 = phi i32 [ %dec, %if.then16 ], [ %sub20, %while.body19 ]
  %cmp18 = icmp sgt i32 %hdr_byte_left.1, 0
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit

while.body19:                                     ; preds = %while.cond17
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !28
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.1, -16
  br label %while.cond17, !llvm.loop !30

; Exit blocks
if.end38.loopexit:                                ; preds = %while.cond17
  br label %if.end38
LoopRotation: rotating Loop at depth 1 containing: %while.cond17<header><exiting>,%while.body19<latch>
  Inserted PHI:   %hdr_byte_left.155 = phi i32 [ %dec, %if.then16 ], [ %hdr_byte_left.1, %while.cond17 ]
Inserting edge %if.then16 -> %if.end38.loopexit
	Reachable %if.then16 -> %if.end38.loopexit
		NCA == %if.then16
Mark %if.end38.loopexitas affected, CurrentLevel 8
	Successor %if.end38, level = 1
Updating NCD = %if.then16
	IDom(%if.end38.loopexit) = %if.then16
Inserting edge %if.then16 -> %while.body19
	Reachable %if.then16 -> %while.body19
		NCA == %if.then16
Mark %while.body19as affected, CurrentLevel 8
	Successor %while.cond17, level = 7
Updating NCD = %if.then16
	IDom(%while.body19) = %if.then16
Deleting edge %if.then16 -> %while.cond17
	NCD %if.then16, ToIDom %if.then16
IsReachableFromIDom %while.cond17
	Pred %while.body19
	Support %if.then16
	%while.cond17 is reachable from support %if.then16
Deleting reachable %if.then16 -> %while.cond17
	Rebuilding subtree
	Top of subtree: %if.then16
	Running Semi-NCA
Inserting edge %if.then16 -> %if.then16.while.body19_crit_edge
Inserting %if.then16 -> (unreachable) %if.then16.while.body19_crit_edge
After adding unreachable nodes
Inserted %if.then16 -> (prev unreachable) %if.then16.while.body19_crit_edge
Inserting edge %if.then16.while.body19_crit_edge -> %while.body19
	Reachable %if.then16.while.body19_crit_edge -> %while.body19
		NCA == %if.then16
Deleting edge %if.then16 -> %while.body19
	NCD %if.then16, ToIDom %if.then16
IsReachableFromIDom %while.body19
	Pred %if.then16.while.body19_crit_edge
	Support %if.then16
	%while.body19 is reachable from support %if.then16
Deleting reachable %if.then16 -> %while.body19
	Rebuilding subtree
	Top of subtree: %if.then16
	Running Semi-NCA
Inserting edge %while.cond17 -> %while.cond17.if.end38.loopexit_crit_edge
Inserting %while.cond17 -> (unreachable) %while.cond17.if.end38.loopexit_crit_edge
After adding unreachable nodes
Inserted %while.cond17 -> (prev unreachable) %while.cond17.if.end38.loopexit_crit_edge
Inserting edge %while.cond17.if.end38.loopexit_crit_edge -> %if.end38.loopexit
	Reachable %while.cond17.if.end38.loopexit_crit_edge -> %if.end38.loopexit
		NCA == %if.then16
Deleting edge %while.cond17 -> %if.end38.loopexit
	NCD %if.then16, ToIDom %if.then16
Deleting reachable %while.cond17 -> %if.end38.loopexit
	Rebuilding subtree
	Top of subtree: %if.then16
	Running Semi-NCA
Merging: while.cond17 into while.body19
Inserting edge %while.body19 -> %while.body19
	Reachable %while.body19 -> %while.body19
		NCA == %while.body19
Inserting edge %while.body19 -> %while.cond17.if.end38.loopexit_crit_edge
	Reachable %while.body19 -> %while.cond17.if.end38.loopexit_crit_edge
		NCA == %while.body19
Mark %while.cond17.if.end38.loopexit_crit_edgeas affected, CurrentLevel 10
	Successor %if.end38.loopexit, level = 7
Updating NCD = %while.body19
	IDom(%while.cond17.if.end38.loopexit_crit_edge) = %while.body19
Deleting edge %while.cond17 -> %while.body19
Deleting edge %while.cond17 -> %while.cond17.if.end38.loopexit_crit_edge
	NCD %while.body19, ToIDom %while.body19
Deleting reachable %while.cond17 -> %while.cond17.if.end38.loopexit_crit_edge
	Rebuilding subtree
	Top of subtree: %while.body19
	Running Semi-NCA
Deleting edge %while.body19 -> %while.cond17
	NCD %while.body19, ToIDom %while.body19
IsReachableFromIDom %while.cond17
Deleting unreachable subtree %while.cond17
Erasing node %while.cond17
LoopRotation: into Loop at depth 1 containing: %while.body19<header><latch><exiting>
; *** IR Dump After LoopRotatePass on while.cond17 ***

; Preheader:
while.body19.lr.ph:                               ; preds = %if.then16
  br label %while.body19

; Loop:
while.body19:                                     ; preds = %while.body19.lr.ph, %while.body19
  %hdr_byte_left.155 = phi i32 [ %dec, %while.body19.lr.ph ], [ %sub20, %while.body19 ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !28
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp sgt i32 %sub20, 0
  br i1 %cmp18, label %while.body19, label %while.cond17.if.end38.loopexit_crit_edge, !llvm.loop !30

; Exit blocks
while.cond17.if.end38.loopexit_crit_edge:         ; preds = %while.body19
  br label %if.end38.loopexit
Captured?:   %indirect-arg-temp = alloca i128, align 8 = not captured
; *** IR Dump After LICMPass on while.body19 ***

; Preheader:
while.body19.lr.ph:                               ; preds = %if.then16
  br label %while.body19

; Loop:
while.body19:                                     ; preds = %while.body19.lr.ph, %while.body19
  %hdr_byte_left.155 = phi i32 [ %dec, %while.body19.lr.ph ], [ %sub20, %while.body19 ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !28
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp sgt i32 %sub20, 0
  br i1 %cmp18, label %while.body19, label %while.cond17.if.end38.loopexit_crit_edge, !llvm.loop !30

; Exit blocks
while.cond17.if.end38.loopexit_crit_edge:         ; preds = %while.body19
  br label %if.end38.loopexit
Unswitching loop in _Z12primate_mainv: Loop at depth 1 containing: %while.body19<header><latch><exiting>

; *** IR Dump After SimpleLoopUnswitchPass on while.body19 ***

; Preheader:
while.body19.lr.ph:                               ; preds = %if.then16
  br label %while.body19

; Loop:
while.body19:                                     ; preds = %while.body19.lr.ph, %while.body19
  %hdr_byte_left.155 = phi i32 [ %dec, %while.body19.lr.ph ], [ %sub20, %while.body19 ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !28
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp sgt i32 %sub20, 0
  br i1 %cmp18, label %while.body19, label %while.cond17.if.end38.loopexit_crit_edge, !llvm.loop !30

; Exit blocks
while.cond17.if.end38.loopexit_crit_edge:         ; preds = %while.body19
  br label %if.end38.loopexit
Looking to fold while.body.lr.ph into while.body
Killing Trivial BB: 

while.body.lr.ph:                                 ; preds = %if.then10
  br label %while.body
Looking to fold while.body19.lr.ph into while.body19
Killing Trivial BB: 

while.body19.lr.ph:                               ; preds = %if.then16
  br label %while.body19
Looking to fold while.cond17.if.end38.loopexit_crit_edge into if.end38.loopexit
Killing Trivial BB: 

while.cond17.if.end38.loopexit_crit_edge:         ; preds = %while.body19
  br label %if.end38.loopexit
Looking to fold if.end38.loopexit into if.end38
Killing Trivial BB: 

if.end38.loopexit:                                ; preds = %while.body19, %if.then16
  br label %if.end38
Looking to fold while.cond.if.end38.loopexit50_crit_edge into if.end38.loopexit50
Killing Trivial BB: 

while.cond.if.end38.loopexit50_crit_edge:         ; preds = %cleanup
  br label %if.end38.loopexit50
Looking to fold if.end38.loopexit50 into if.end38
Killing Trivial BB: 

if.end38.loopexit50:                              ; preds = %cleanup, %if.then10
  br label %if.end38
; *** IR Dump After SimplifyCFGPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = mul nuw nsw i32 %conv12, 4
  %mul = add nsw i32 %sub, -20
  %cmp1352 = icmp sgt i32 %mul, 0
  br i1 %cmp1352, label %while.body, label %if.end38

while.body:                                       ; preds = %if.then10, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %if.then10 ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %.lcssa = phi i8 [ %12, %while.body ]
  %hdr_byte_left.0.lcssa51 = phi i32 [ %hdr_byte_left.053, %while.body ]
  %dec = add nsw i32 %hdr_byte_left.0.lcssa51, -1
  tail call void @llvm.primate.output.i8.i32(i8 %.lcssa, i32 1)
  %cmp1854 = icmp sgt i32 %dec, 0
  br i1 %cmp1854, label %while.body19, label %if.end38

while.body19:                                     ; preds = %if.then16, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %if.then16 ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !29
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp sgt i32 %sub20, 0
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !31

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %if.then10, %cleanup, %if.then16, %while.body19, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}


INSTCOMBINE ITERATION #1 on _Z12primate_mainv
ADD:   ret void
ADD:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
ADD:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
ADD:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
ADD:   tail call void @llvm.primate.input.done()
ADD:   br i1 %cmp13, label %while.body, label %if.end38
ADD:   %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
ADD:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
ADD:   br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !30
ADD:   %cmp18 = icmp sgt i32 %sub20, 0
ADD:   %sub20 = add nsw i32 %hdr_byte_left.155, -16
ADD:   call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
ADD:   tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
ADD:   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
ADD:   call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
ADD:   store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !28
ADD:   %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
ADD:   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %if.then16 ]
ADD:   br i1 %cmp1854, label %while.body19, label %if.end38
ADD:   %cmp1854 = icmp sgt i32 %dec, 0
ADD:   tail call void @llvm.primate.output.i8.i32(i8 %.lcssa, i32 1)
ADD:   %dec = add nsw i32 %hdr_byte_left.0.lcssa51, -1
ADD:   %hdr_byte_left.0.lcssa51 = phi i32 [ %hdr_byte_left.053, %while.body ]
ADD:   %.lcssa = phi i8 [ %12, %while.body ]
ADD:   br label %cleanup
ADD:   tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
ADD:   %dec25 = add nsw i32 %hdr_byte_left.053, -1
ADD:   switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]
ADD:   %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
ADD:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %if.then10 ]
ADD:   br i1 %cmp1352, label %while.body, label %if.end38
ADD:   %cmp1352 = icmp sgt i32 %mul, 0
ADD:   %mul = add nsw i32 %sub, -20
ADD:   %sub = mul nuw nsw i32 %conv12, 4
ADD:   %conv12 = zext nneg i4 %11 to i32
ADD:   br i1 %cmp9, label %if.then10, label %if.end38
ADD:   %cmp9 = icmp sgt i4 %11, 0
ADD:   %11 = load i4, ptr %10, align 1
ADD:   %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
ADD:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
ADD:   tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
ADD:   %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
ADD:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !21
ADD:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !21
ADD:   store %struct.tcp_t %8, ptr %ref.tmp6, align 8
ADD:   %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
ADD:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
ADD:   br label %if.end38
ADD:   tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
ADD:   %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
ADD:   switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]
ADD:   %7 = load i8, ptr %6, align 1
ADD:   %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
ADD:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
ADD:   tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
ADD:   %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
ADD:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !14
ADD:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !14
ADD:   store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
ADD:   %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
ADD:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
ADD:   br i1 %cmp, label %if.then, label %if.end38
ADD:   %cmp = icmp eq i16 %3, 2048
ADD:   %3 = load i16, ptr %2, align 2
ADD:   %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
ADD:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
ADD:   tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
ADD:   %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
ADD:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !7
ADD:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !7
ADD:   store %struct.ethernet_t %0, ptr %ref.tmp, align 8
ADD:   %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
ADD:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
ADD:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
ADD:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
ADD:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
ADD:   %indirect-arg-temp = alloca i128, align 8
ADD:   %agg.tmp7 = alloca %struct.tcp_t, align 8
ADD:   %ref.tmp6 = alloca %struct.tcp_t, align 8
ADD:   %agg.tmp2 = alloca %struct.ipv4_t, align 8
ADD:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
ADD:   %agg.tmp = alloca %struct.ethernet_t, align 8
ADD:   %ref.tmp = alloca %struct.ethernet_t, align 8
ADD:   %tcp = alloca %struct.tcp_t, align 8
ADD:   %ipv4 = alloca %struct.ipv4_t, align 8
ADD:   %eth = alloca %struct.ethernet_t, align 8
ADD:   %agg.tmp39 = alloca %struct.ethernet_t, align 8
ADD:   %agg.tmp240 = alloca %struct.ipv4_t, align 8
ADD:   %agg.tmp741 = alloca %struct.tcp_t, align 8
ADD:   %indirect-arg-temp43 = alloca i128, align 8
IC: Visiting:   %indirect-arg-temp43 = alloca i128, align 8
IC: Visiting:   %agg.tmp741 = alloca %struct.tcp_t, align 8
IC: Visiting:   %agg.tmp240 = alloca %struct.ipv4_t, align 8
IC: Visiting:   %agg.tmp39 = alloca %struct.ethernet_t, align 8
IC: Visiting:   %eth = alloca %struct.ethernet_t, align 8
IC: Visiting:   %ipv4 = alloca %struct.ipv4_t, align 8
IC: Visiting:   %tcp = alloca %struct.tcp_t, align 8
IC: Visiting:   %ref.tmp = alloca %struct.ethernet_t, align 8
IC: Visiting:   %agg.tmp = alloca %struct.ethernet_t, align 8
IC: Visiting:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
IC: Visiting:   %agg.tmp2 = alloca %struct.ipv4_t, align 8
IC: Visiting:   %ref.tmp6 = alloca %struct.tcp_t, align 8
IC: Visiting:   %agg.tmp7 = alloca %struct.tcp_t, align 8
IC: Visiting:   %indirect-arg-temp = alloca i128, align 8
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
IC: Visiting:   %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
IC: Visiting:   store %struct.ethernet_t %0, ptr %ref.tmp, align 8
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !7
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !7
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
IC: Visiting:   %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
IC: Visiting:   tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
IC: Visiting:   %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
IC: Visiting:   %3 = load i16, ptr %2, align 2
IC: Visiting:   %cmp = icmp eq i16 %3, 2048
IC: Visiting:   br i1 %cmp, label %if.then, label %if.end38
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
IC: Visiting:   %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
IC: Visiting:   store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !14
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !14
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
IC: Visiting:   %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
IC: Visiting:   tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
IC: Visiting:   %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
IC: Visiting:   %7 = load i8, ptr %6, align 1
IC: Visiting:   switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]
IC: Visiting:   %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
IC: Visiting:   tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
IC: Visiting:   br label %if.end38
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
IC: Visiting:   %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
IC: Visiting:   store %struct.tcp_t %8, ptr %ref.tmp6, align 8
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !21
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !21
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
IC: Visiting:   %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
IC: Visiting:   tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
IC: Visiting:   %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
IC: Visiting:   %11 = load i4, ptr %10, align 1
IC: Visiting:   %cmp9 = icmp sgt i4 %11, 0
IC: Visiting:   br i1 %cmp9, label %if.then10, label %if.end38
IC: Visiting:   %conv12 = zext nneg i4 %11 to i32
IC: Visiting:   %sub = mul nuw nsw i32 %conv12, 4
IC: Old =   %sub = mul nuw nsw i32 %conv12, 4
    New =   <badref> = shl nuw nsw i32 %conv12, 2
ADD:   %sub = shl nuw nsw i32 %conv12, 2
IC: ERASE   %12 = mul nuw nsw i32 %conv12, 4
ADD DEFERRED:   %conv12 = zext nneg i4 %11 to i32
ADD DEFERRED:   %sub = shl nuw nsw i32 %conv12, 2
ADD:   %conv12 = zext nneg i4 %11 to i32
IC: Visiting:   %conv12 = zext nneg i4 %11 to i32
IC: Visiting:   %sub = shl nuw nsw i32 %conv12, 2
IC: Visiting:   %mul = add nsw i32 %sub, -20
IC: Visiting:   %cmp1352 = icmp sgt i32 %mul, 0
IC: Old =   %cmp1352 = icmp sgt i32 %mul, 0
    New =   <badref> = icmp sgt i32 %sub, 20
ADD:   %cmp1352 = icmp sgt i32 %sub, 20
IC: ERASE   %12 = icmp sgt i32 %mul, 0
ADD DEFERRED:   %mul = add nsw i32 %sub, -20
ADD DEFERRED:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %if.then10 ]
ADD:   %mul = add nsw i32 %sub, -20
IC: Visiting:   %mul = add nsw i32 %sub, -20
IC: Visiting:   %cmp1352 = icmp sgt i32 %sub, 20
IC: Old =   %cmp1352 = icmp sgt i32 %sub, 20
    New =   <badref> = icmp ugt i32 %sub, 20
ADD:   %cmp1352 = icmp ugt i32 %sub, 20
IC: ERASE   %12 = icmp sgt i32 %sub, 20
ADD DEFERRED:   %sub = shl nuw nsw i32 %conv12, 2
ADD:   %sub = shl nuw nsw i32 %conv12, 2
IC: Visiting:   %sub = shl nuw nsw i32 %conv12, 2
IC: Visiting:   %cmp1352 = icmp ugt i32 %sub, 20
IC: Old =   %cmp1352 = icmp ugt i32 %sub, 20
    New =   <badref> = icmp ugt i32 %conv12, 5
ADD:   %cmp1352 = icmp ugt i32 %conv12, 5
IC: ERASE   %12 = icmp ugt i32 %sub, 20
ADD DEFERRED:   %sub = shl nuw nsw i32 %conv12, 2
ADD DEFERRED:   %mul = add nsw i32 %sub, -20
ADD:   %mul = add nsw i32 %sub, -20
ADD:   %sub = shl nuw nsw i32 %conv12, 2
IC: Visiting:   %sub = shl nuw nsw i32 %conv12, 2
IC: Visiting:   %mul = add nsw i32 %sub, -20
IC: Visiting:   %cmp1352 = icmp ugt i32 %conv12, 5
IC: Old =   %cmp1352 = icmp ugt i32 %conv12, 5
    New =   <badref> = icmp ugt i4 %11, 5
ADD:   %cmp1352 = icmp ugt i4 %11, 5
IC: ERASE   %12 = icmp ugt i32 %conv12, 5
ADD DEFERRED:   %conv12 = zext nneg i4 %11 to i32
ADD DEFERRED:   %sub = shl nuw nsw i32 %conv12, 2
ADD:   %sub = shl nuw nsw i32 %conv12, 2
ADD:   %conv12 = zext nneg i4 %11 to i32
IC: Visiting:   %conv12 = zext nneg i4 %11 to i32
IC: Visiting:   %sub = shl nuw nsw i32 %conv12, 2
IC: Visiting:   %cmp1352 = icmp ugt i4 %11, 5
IC: Visiting:   br i1 %cmp1352, label %while.body, label %if.end38
IC: Visiting:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %if.then10 ]
IC: Visiting:   %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
IC: Visiting:   switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]
IC: Visiting:   %dec25 = add nsw i32 %hdr_byte_left.053, -1
IC: Visiting:   tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
IC: Visiting:   br label %cleanup
IC: Visiting:   %.lcssa = phi i8 [ %12, %while.body ]
IC: Replacing   %.lcssa = phi i8 [ %12, %while.body ]
    with   %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
IC: Mod =   %.lcssa = phi i8 [ %12, %while.body ]
    New =   %.lcssa = phi i8 [ %12, %while.body ]
IC: ERASE   %.lcssa = phi i8 [ %12, %while.body ]
ADD DEFERRED:   %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
ADD:   %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
IC: Visiting:   %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
IC: Visiting:   %hdr_byte_left.0.lcssa51 = phi i32 [ %hdr_byte_left.053, %while.body ]
IC: Replacing   %hdr_byte_left.0.lcssa51 = phi i32 [ %hdr_byte_left.053, %while.body ]
    with   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %if.then10 ]
IC: Mod =   %hdr_byte_left.0.lcssa51 = phi i32 [ %hdr_byte_left.053, %while.body ]
    New =   %hdr_byte_left.0.lcssa51 = phi i32 [ %hdr_byte_left.053, %while.body ]
IC: ERASE   %hdr_byte_left.0.lcssa51 = phi i32 [ %hdr_byte_left.053, %while.body ]
ADD DEFERRED:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %if.then10 ]
ADD:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %if.then10 ]
IC: Visiting:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %if.then10 ]
IC: Visiting:   %dec = add nsw i32 %hdr_byte_left.053, -1
IC: Visiting:   tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
IC: Visiting:   %cmp1854 = icmp sgt i32 %dec, 0
IC: Old =   %cmp1854 = icmp sgt i32 %dec, 0
    New =   <badref> = icmp sgt i32 %hdr_byte_left.053, 1
ADD:   %cmp1854 = icmp sgt i32 %hdr_byte_left.053, 1
IC: ERASE   %13 = icmp sgt i32 %dec, 0
ADD DEFERRED:   %dec = add nsw i32 %hdr_byte_left.053, -1
ADD DEFERRED:   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %if.then16 ]
ADD:   %dec = add nsw i32 %hdr_byte_left.053, -1
IC: Visiting:   %dec = add nsw i32 %hdr_byte_left.053, -1
IC: Visiting:   %cmp1854 = icmp sgt i32 %hdr_byte_left.053, 1
IC: Visiting:   br i1 %cmp1854, label %while.body19, label %if.end38
IC: Visiting:   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %if.then16 ]
IC: Visiting:   %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
IC: Visiting:   store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !28
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
IC: Visiting:   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28
IC: Visiting:   tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
IC: Visiting:   %sub20 = add nsw i32 %hdr_byte_left.155, -16
IC: Visiting:   %cmp18 = icmp sgt i32 %sub20, 0
IC: Old =   %cmp18 = icmp sgt i32 %sub20, 0
    New =   <badref> = icmp sgt i32 %hdr_byte_left.155, 16
ADD:   %cmp18 = icmp sgt i32 %hdr_byte_left.155, 16
IC: ERASE   %14 = icmp sgt i32 %sub20, 0
ADD DEFERRED:   %sub20 = add nsw i32 %hdr_byte_left.155, -16
ADD DEFERRED:   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %if.then16 ]
ADD:   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %if.then16 ]
ADD:   %sub20 = add nsw i32 %hdr_byte_left.155, -16
IC: Visiting:   %sub20 = add nsw i32 %hdr_byte_left.155, -16
IC: Visiting:   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %if.then16 ]
IC: Visiting:   %cmp18 = icmp sgt i32 %hdr_byte_left.155, 16
IC: Visiting:   br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !30
IC: Visiting:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
IC: Visiting:   %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
IC: Visiting:   br i1 %cmp13, label %while.body, label %if.end38
IC: Visiting:   tail call void @llvm.primate.input.done()
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
IC: Visiting:   ret void


[IC] Iteration limit #1 on _Z12primate_mainv reached; stopping without verifying fixpoint
; *** IR Dump After InstCombinePass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  %cmp1352 = icmp ugt i4 %11, 5
  br i1 %cmp1352, label %while.body, label %if.end38

while.body:                                       ; preds = %if.then10, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %if.then10 ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  %cmp1854 = icmp sgt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19, label %if.end38

while.body19:                                     ; preds = %if.then16, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %if.then16 ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !29
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp sgt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !31

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %if.then10, %cleanup, %if.then16, %while.body19, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
LoopSimplify: Creating pre-header while.body19.preheader
LoopSimplify: Creating dedicated exit block if.end38.loopexit
LoopSimplify: Creating pre-header while.body.preheader
LoopSimplify: Creating dedicated exit block if.end38.loopexit56
; *** IR Dump After LoopSimplifyPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  %cmp1352 = icmp ugt i4 %11, 5
  br i1 %cmp1352, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then10
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  %cmp1854 = icmp sgt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !29
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp sgt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !31

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit56

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit56:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit56, %if.end38.loopexit, %if.then10, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
; *** IR Dump After LCSSAPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  %cmp1352 = icmp ugt i4 %11, 5
  br i1 %cmp1352, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then10
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  %.lcssa = phi i8 [ %12, %while.body ]
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  tail call void @llvm.primate.output.i8.i32(i8 %.lcssa, i32 1)
  %cmp1854 = icmp sgt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !29
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp sgt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !31

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit56

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit56:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit56, %if.end38.loopexit, %if.then10, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
loop-idiom Scanning: F[_Z12primate_mainv] Noncountable Loop %while.body
loop-idiom Performing shift-until-bittest idiom detection.
loop-idiom Bad block/backedge count.
loop-idiom shift-until-bittest idiom detection failed.
loop-idiom Performing shift-until-zero idiom detection.
loop-idiom Bad block/backedge count.
loop-idiom shift-until-zero idiom detection failed.
; *** IR Dump After LoopIdiomRecognizePass on while.body ***

; Preheader:
while.body.preheader:                             ; preds = %if.then10
  br label %while.body

; Loop:
while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit56

; Exit blocks
if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  %.lcssa = phi i8 [ %12, %while.body ]
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  tail call void @llvm.primate.output.i8.i32(i8 %.lcssa, i32 1)
  %cmp1854 = icmp sgt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

if.end38.loopexit56:                              ; preds = %cleanup
  br label %if.end38
; *** IR Dump After IndVarSimplifyPass on while.body ***

; Preheader:
while.body.preheader:                             ; preds = %if.then10
  br label %while.body

; Loop:
while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit56

; Exit blocks
if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  %.lcssa = phi i8 [ %12, %while.body ]
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  tail call void @llvm.primate.output.i8.i32(i8 %.lcssa, i32 1)
  %cmp1854 = icmp sgt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

if.end38.loopexit56:                              ; preds = %cleanup
  br label %if.end38
Analyzing Loop for deletion: Loop at depth 1 containing: %while.body<header><exiting>,%if.then23,%cleanup<latch><exiting>
Deletion requires at most one exit block.
; *** IR Dump After LoopDeletionPass on while.body ***

; Preheader:
while.body.preheader:                             ; preds = %if.then10
  br label %while.body

; Loop:
while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit56

; Exit blocks
if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  %.lcssa = phi i8 [ %12, %while.body ]
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  tail call void @llvm.primate.output.i8.i32(i8 %.lcssa, i32 1)
  %cmp1854 = icmp sgt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

if.end38.loopexit56:                              ; preds = %cleanup
  br label %if.end38
Loop Unroll: F[_Z12primate_mainv] Loop %while.body
  Loop Size = 7
  will not try to unroll loop with runtime trip count -unroll-runtime not given
; *** IR Dump After LoopFullUnrollPass on while.body ***

; Preheader:
while.body.preheader:                             ; preds = %if.then10
  br label %while.body

; Loop:
while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit56

; Exit blocks
if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  %.lcssa = phi i8 [ %12, %while.body ]
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  tail call void @llvm.primate.output.i8.i32(i8 %.lcssa, i32 1)
  %cmp1854 = icmp sgt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

if.end38.loopexit56:                              ; preds = %cleanup
  br label %if.end38
loop-idiom Scanning: F[_Z12primate_mainv] Countable Loop %while.body19
; *** IR Dump After LoopIdiomRecognizePass on while.body19 ***

; Preheader:
while.body19.preheader:                           ; preds = %if.then16
  br label %while.body19

; Loop:
while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !28
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp sgt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !30

; Exit blocks
if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38
; *** IR Dump After IndVarSimplifyPass on while.body19 ***

; Preheader:
while.body19.preheader:                           ; preds = %if.then16
  br label %while.body19

; Loop:
while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !28
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp sgt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !30

; Exit blocks
if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38
Analyzing Loop for deletion: Loop at depth 1 containing: %while.body19<header><latch><exiting>
Loop is not invariant, cannot delete.
; *** IR Dump After LoopDeletionPass on while.body19 ***

; Preheader:
while.body19.preheader:                           ; preds = %if.then16
  br label %while.body19

; Loop:
while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !28
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp sgt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !30

; Exit blocks
if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38
Loop Unroll: F[_Z12primate_mainv] Loop %while.body19
  Loop Size = 11
  will not try to unroll loop with runtime trip count -unroll-runtime not given
; *** IR Dump After LoopFullUnrollPass on while.body19 ***

; Preheader:
while.body19.preheader:                           ; preds = %if.then16
  br label %while.body19

; Loop:
while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !28
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp sgt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !30

; Exit blocks
if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38
; *** IR Dump After VectorCombinePass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  %cmp1352 = icmp ugt i4 %11, 5
  br i1 %cmp1352, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then10
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  %.lcssa = phi i8 [ %12, %while.body ]
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  tail call void @llvm.primate.output.i8.i32(i8 %.lcssa, i32 1)
  %cmp1854 = icmp sgt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !29
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp sgt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !31

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit56

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit56:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit56, %if.end38.loopexit, %if.then10, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
Instruction Merger
; *** IR Dump After MergedLoadStoreMotionPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  %cmp1352 = icmp ugt i4 %11, 5
  br i1 %cmp1352, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then10
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  %.lcssa = phi i8 [ %12, %while.body ]
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  tail call void @llvm.primate.output.i8.i32(i8 %.lcssa, i32 1)
  %cmp1854 = icmp sgt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !29
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp sgt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !31

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit56

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit56:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit56, %if.end38.loopexit, %if.then10, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
GVN iteration: 0
GVN: load %struct.ethernet_t %1 is clobbered by   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
GVN: load i16 %3 is clobbered by   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !7
GVN: load %struct.ipv4_t %5 is clobbered by   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
GVN: load i8 %7 is clobbered by   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !14
GVN: load %struct.tcp_t %9 is clobbered by   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
GVN: load i4 %11 is clobbered by   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !21
Replace dominated use of 'i8 %12' with i8 0 in   %.lcssa = phi i8 [ %12, %while.body ]
Replace dominated use of 'i8 %12' with i8 1 in   tail call void @llvm.primate.output.i8.i32(i8 %12, i32 1)
GVN removed:   %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
GVN removed:   %.lcssa = phi i8 [ 0, %while.body ]
GVN: load i128 %out.i is clobbered by   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
GVN iteration: 1
GVN: load %struct.ethernet_t %1 is clobbered by   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
GVN: load i16 %3 is clobbered by   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !7
GVN: load %struct.ipv4_t %5 is clobbered by   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
GVN: load i8 %7 is clobbered by   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !14
GVN: load %struct.tcp_t %9 is clobbered by   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
GVN: load i4 %11 is clobbered by   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !21
GVN: load i128 %out.i is clobbered by   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
; *** IR Dump After GVNPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  %cmp1352 = icmp ugt i4 %11, 5
  br i1 %cmp1352, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then10
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp sgt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !29
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp sgt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !31

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit56

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit56:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit56, %if.end38.loopexit, %if.then10, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
SCCP on function '_Z12primate_mainv'
Marking Block Executable: entry

Popped off BBWL: 
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !7
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !7
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

SCCP: Don't know how to handle:   %indirect-arg-temp43 = alloca i128, align 8
markOverdefined:   %indirect-arg-temp43 = alloca i128, align 8
SCCP: Don't know how to handle:   %agg.tmp741 = alloca %struct.tcp_t, align 8
markOverdefined:   %agg.tmp741 = alloca %struct.tcp_t, align 8
SCCP: Don't know how to handle:   %agg.tmp240 = alloca %struct.ipv4_t, align 8
markOverdefined:   %agg.tmp240 = alloca %struct.ipv4_t, align 8
SCCP: Don't know how to handle:   %agg.tmp39 = alloca %struct.ethernet_t, align 8
markOverdefined:   %agg.tmp39 = alloca %struct.ethernet_t, align 8
SCCP: Don't know how to handle:   %eth = alloca %struct.ethernet_t, align 8
markOverdefined:   %eth = alloca %struct.ethernet_t, align 8
SCCP: Don't know how to handle:   %ipv4 = alloca %struct.ipv4_t, align 8
markOverdefined:   %ipv4 = alloca %struct.ipv4_t, align 8
SCCP: Don't know how to handle:   %tcp = alloca %struct.tcp_t, align 8
markOverdefined:   %tcp = alloca %struct.tcp_t, align 8
SCCP: Don't know how to handle:   %ref.tmp = alloca %struct.ethernet_t, align 8
markOverdefined:   %ref.tmp = alloca %struct.ethernet_t, align 8
SCCP: Don't know how to handle:   %agg.tmp = alloca %struct.ethernet_t, align 8
markOverdefined:   %agg.tmp = alloca %struct.ethernet_t, align 8
SCCP: Don't know how to handle:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
markOverdefined:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
SCCP: Don't know how to handle:   %agg.tmp2 = alloca %struct.ipv4_t, align 8
markOverdefined:   %agg.tmp2 = alloca %struct.ipv4_t, align 8
SCCP: Don't know how to handle:   %ref.tmp6 = alloca %struct.tcp_t, align 8
markOverdefined:   %ref.tmp6 = alloca %struct.tcp_t, align 8
SCCP: Don't know how to handle:   %agg.tmp7 = alloca %struct.tcp_t, align 8
markOverdefined:   %agg.tmp7 = alloca %struct.tcp_t, align 8
SCCP: Don't know how to handle:   %indirect-arg-temp = alloca i128, align 8
markOverdefined:   %indirect-arg-temp = alloca i128, align 8
markOverdefined:   %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
markOverdefined:   %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
markOverdefined:   %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
markOverdefined:   %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
markOverdefined:   %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
markOverdefined:   %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
markOverdefined:   %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
Merged overdefined into   %3 = load i16, ptr %2, align 2 : overdefined
markOverdefined:   %cmp = icmp eq i16 %3, 2048
Marking Block Executable: if.then
Marking Block Executable: if.end38

Popped off BBWL: 
if.end38:                                         ; preds = %if.end38.loopexit56, %if.end38.loopexit, %if.then10, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void


Popped off BBWL: 
if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !14
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !14
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

markOverdefined:   %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
markOverdefined:   %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
markOverdefined:   %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
markOverdefined:   %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
markOverdefined:   %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
markOverdefined:   %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
markOverdefined:   %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
Merged overdefined into   %7 = load i8, ptr %6, align 1 : overdefined
Marking Edge Executable: if.then -> if.end38
Marking Block Executable: if.then5
Marking Block Executable: if.then33

Popped off BBWL: 
if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

markOverdefined:   %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
Marking Edge Executable: if.then33 -> if.end38

Popped off BBWL: 
if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !21
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !21
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

markOverdefined:   %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
markOverdefined:   %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
markOverdefined:   %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
markOverdefined:   %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
markOverdefined:   %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
markOverdefined:   %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
markOverdefined:   %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
Merged overdefined into   %11 = load i4, ptr %10, align 1 : overdefined
markOverdefined:   %cmp9 = icmp sgt i4 %11, 0
Marking Block Executable: if.then10
Marking Edge Executable: if.then5 -> if.end38

Popped off BBWL: 
if.then10:                                        ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  %cmp1352 = icmp ugt i4 %11, 5
  br i1 %cmp1352, label %while.body.preheader, label %if.end38

Merged constantrange<0, 16> into   %conv12 = zext nneg i4 %11 to i32 : constantrange<0, 16>
Merged constantrange<0, 61> into   %sub = shl nuw nsw i32 %conv12, 2 : constantrange<0, 61>
Merged constantrange<-20, 41> into   %mul = add nsw i32 %sub, -20 : constantrange<-20, 41>
markOverdefined:   %cmp1352 = icmp ugt i4 %11, 5
Marking Block Executable: while.body.preheader
Marking Edge Executable: if.then10 -> if.end38

Popped off BBWL: 
while.body.preheader:                             ; preds = %if.then10
  br label %while.body

Marking Block Executable: while.body

Popped off BBWL: 
while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

Merged constantrange<-20, 41> into   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] : constantrange<-20, 41>
Merged overdefined into   %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1) : overdefined
Marking Block Executable: cleanup
Marking Block Executable: if.then16
Marking Block Executable: if.then23

Popped off BBWL: 
if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

Merged constantrange<-21, 40> into   %dec25 = add nsw i32 %hdr_byte_left.053, -1 : constantrange<-21, 40>
Marking Edge Executable: if.then23 -> cleanup
Merged constantrange<-21, 41> into   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ] : constantrange<-21, 41>

Popped off BBWL: 
if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp sgt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

Merged constantrange<-21, 40> into   %dec = add nsw i32 %hdr_byte_left.053, -1 : constantrange<-21, 40>
markOverdefined:   %cmp1854 = icmp sgt i32 %hdr_byte_left.053, 1
Marking Block Executable: while.body19.preheader
Marking Edge Executable: if.then16 -> if.end38

Popped off BBWL: 
while.body19.preheader:                           ; preds = %if.then16
  br label %while.body19

Marking Block Executable: while.body19

Popped off BBWL: 
while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !28
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp sgt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !30

Merged constantrange<-21, 40> into   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ] : constantrange<-21, 40>
Merged overdefined into   %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16) : overdefined
Merged overdefined into   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28 : overdefined
Merged constantrange<-37, 24> into   %sub20 = add nsw i32 %hdr_byte_left.155, -16 : constantrange<-37, 24>
markOverdefined:   %cmp18 = icmp sgt i32 %hdr_byte_left.155, 16
Marking Edge Executable: while.body19 -> while.body19
Merged constantrange<-37, 40> into   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ] : constantrange<-37, 40>
Marking Block Executable: if.end38.loopexit

Popped off BBWL: 
if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

Marking Edge Executable: if.end38.loopexit -> if.end38

Popped off BBWL: 
cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit56

markOverdefined:   %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
Marking Edge Executable: cleanup -> while.body
Merged constantrange<-21, 41> into   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] : constantrange<-21, 41>
Marking Block Executable: if.end38.loopexit56

Popped off BBWL: 
if.end38.loopexit56:                              ; preds = %cleanup
  br label %if.end38

Marking Edge Executable: if.end38.loopexit56 -> if.end38

Popped off OI-WL:   %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0

Popped off OI-WL:   %cmp18 = icmp sgt i32 %hdr_byte_left.155, 16

Popped off OI-WL:   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28

Popped off OI-WL:   %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)

Popped off OI-WL:   %cmp1854 = icmp sgt i32 %hdr_byte_left.053, 1

Popped off OI-WL:   %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)

Popped off OI-WL:   %cmp1352 = icmp ugt i4 %11, 5

Popped off OI-WL:   %cmp9 = icmp sgt i4 %11, 0

Popped off OI-WL:   %11 = load i4, ptr %10, align 1

Popped off OI-WL:   %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1

Popped off OI-WL:   %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8

Popped off OI-WL:   %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)

Popped off OI-WL:   %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)

Popped off OI-WL:   %7 = load i8, ptr %6, align 1

Popped off OI-WL:   %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1

Popped off OI-WL:   %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8

Popped off OI-WL:   %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)

Popped off OI-WL:   %cmp = icmp eq i16 %3, 2048

Popped off OI-WL:   %3 = load i16, ptr %2, align 2

Popped off OI-WL:   %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2

Popped off OI-WL:   %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8

Popped off OI-WL:   %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)

Popped off OI-WL:   %indirect-arg-temp = alloca i128, align 8

Popped off OI-WL:   %agg.tmp7 = alloca %struct.tcp_t, align 8

Popped off OI-WL:   %ref.tmp6 = alloca %struct.tcp_t, align 8

Popped off OI-WL:   %agg.tmp2 = alloca %struct.ipv4_t, align 8

Popped off OI-WL:   %ref.tmp1 = alloca %struct.ipv4_t, align 8

Popped off OI-WL:   %agg.tmp = alloca %struct.ethernet_t, align 8

Popped off OI-WL:   %ref.tmp = alloca %struct.ethernet_t, align 8

Popped off OI-WL:   %tcp = alloca %struct.tcp_t, align 8

Popped off OI-WL:   %ipv4 = alloca %struct.ipv4_t, align 8

Popped off OI-WL:   %eth = alloca %struct.ethernet_t, align 8

Popped off OI-WL:   %agg.tmp39 = alloca %struct.ethernet_t, align 8

Popped off OI-WL:   %agg.tmp240 = alloca %struct.ipv4_t, align 8

Popped off OI-WL:   %agg.tmp741 = alloca %struct.tcp_t, align 8

Popped off OI-WL:   %indirect-arg-temp43 = alloca i128, align 8

Popped off I-WL:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
Merged constantrange<-22, 40> into   %dec = add nsw i32 %hdr_byte_left.053, -1 : constantrange<-22, 40>
Merged constantrange<-22, 40> into   %dec25 = add nsw i32 %hdr_byte_left.053, -1 : constantrange<-22, 40>
Merged constantrange<-22, 41> into   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ] : constantrange<-22, 41>

Popped off I-WL:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
Merged constantrange<-22, 41> into   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] : constantrange<-22, 41>

Popped off I-WL:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
Merged constantrange<-23, 40> into   %dec = add nsw i32 %hdr_byte_left.053, -1 : constantrange<-23, 40>
Merged constantrange<-23, 40> into   %dec25 = add nsw i32 %hdr_byte_left.053, -1 : constantrange<-23, 40>
Merged constantrange<-23, 41> into   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ] : overdefined

Popped off I-WL:   %dec25 = add nsw i32 %hdr_byte_left.053, -1

Popped off I-WL:   %dec = add nsw i32 %hdr_byte_left.053, -1

Popped off I-WL:   %dec25 = add nsw i32 %hdr_byte_left.053, -1

Popped off I-WL:   %dec = add nsw i32 %hdr_byte_left.053, -1

Popped off I-WL:   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
Merged constantrange<-53, 24> into   %sub20 = add nsw i32 %hdr_byte_left.155, -16 : constantrange<-53, 24>

Popped off I-WL:   %sub20 = add nsw i32 %hdr_byte_left.155, -16
Merged constantrange<-53, 40> into   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ] : constantrange<-53, 40>

Popped off I-WL:   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
Merged constantrange<-69, 24> into   %sub20 = add nsw i32 %hdr_byte_left.155, -16 : constantrange<-69, 24>

Popped off I-WL:   %sub20 = add nsw i32 %hdr_byte_left.155, -16
Merged constantrange<-69, 40> into   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ] : overdefined

Popped off I-WL:   %dec = add nsw i32 %hdr_byte_left.053, -1

Popped off I-WL:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]

Popped off I-WL:   %dec25 = add nsw i32 %hdr_byte_left.053, -1

Popped off I-WL:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]

Popped off I-WL:   %mul = add nsw i32 %sub, -20
Merged overdefined into   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] : overdefined

Popped off I-WL:   %sub = shl nuw nsw i32 %conv12, 2

Popped off I-WL:   %conv12 = zext nneg i4 %11 to i32

Popped off OI-WL:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
Merged overdefined into   %dec = add nsw i32 %hdr_byte_left.053, -1 : overdefined
Merged overdefined into   %dec25 = add nsw i32 %hdr_byte_left.053, -1 : overdefined

Popped off OI-WL:   %dec25 = add nsw i32 %hdr_byte_left.053, -1

Popped off OI-WL:   %dec = add nsw i32 %hdr_byte_left.053, -1

Popped off OI-WL:   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
Merged overdefined into   %sub20 = add nsw i32 %hdr_byte_left.155, -16 : overdefined

Popped off OI-WL:   %sub20 = add nsw i32 %hdr_byte_left.155, -16

Popped off OI-WL:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
RESOLVING UNDEFs
; *** IR Dump After SCCPPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  %cmp1352 = icmp ugt i4 %11, 5
  br i1 %cmp1352, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then10
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp sgt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !29
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp sgt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !31

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit56

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit56:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit56, %if.end38.loopexit, %if.then10, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
DemandedBits: Root:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
DemandedBits: Root:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
DemandedBits: Root:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
DemandedBits: Root:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
DemandedBits: Root:   %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
DemandedBits: Root:   store %struct.ethernet_t %0, ptr %ref.tmp, align 8
DemandedBits: Root:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !7
DemandedBits: Root:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
DemandedBits: Root:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !7
DemandedBits: Root:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
DemandedBits: Root:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
DemandedBits: Root:   tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
DemandedBits: Root:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
DemandedBits: Root:   br i1 %cmp, label %if.then, label %if.end38
DemandedBits: Root:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
DemandedBits: Root:   %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
DemandedBits: Root:   store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
DemandedBits: Root:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !14
DemandedBits: Root:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
DemandedBits: Root:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !14
DemandedBits: Root:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
DemandedBits: Root:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
DemandedBits: Root:   tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
DemandedBits: Root:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
DemandedBits: Root:   switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]
DemandedBits: Root:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
DemandedBits: Root:   %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
DemandedBits: Root:   store %struct.tcp_t %8, ptr %ref.tmp6, align 8
DemandedBits: Root:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !21
DemandedBits: Root:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
DemandedBits: Root:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !21
DemandedBits: Root:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
DemandedBits: Root:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
DemandedBits: Root:   tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
DemandedBits: Root:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
DemandedBits: Root:   br i1 %cmp9, label %if.then10, label %if.end38
DemandedBits: Root:   br i1 %cmp1352, label %while.body.preheader, label %if.end38
DemandedBits: Root:   br label %while.body
DemandedBits: Root:   %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
DemandedBits: Root:   switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]
DemandedBits: Root:   tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
DemandedBits: Root:   br i1 %cmp1854, label %while.body19.preheader, label %if.end38
DemandedBits: Root:   br label %while.body19
DemandedBits: Root:   %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
DemandedBits: Root:   store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !28
DemandedBits: Root:   call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
DemandedBits: Root:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
DemandedBits: Root:   tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
DemandedBits: Root:   call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
DemandedBits: Root:   br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !30
DemandedBits: Root:   tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
DemandedBits: Root:   br label %cleanup
DemandedBits: Root:   br i1 %cmp13, label %while.body, label %if.end38.loopexit56
DemandedBits: Root:   %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
DemandedBits: Root:   tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
DemandedBits: Root:   br label %if.end38
DemandedBits: Root:   br label %if.end38
DemandedBits: Root:   br label %if.end38
DemandedBits: Root:   tail call void @llvm.primate.input.done()
DemandedBits: Root:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
DemandedBits: Root:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
DemandedBits: Root:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
DemandedBits: Root:   ret void
DemandedBits: Visiting:   %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
DemandedBits: Visiting:   %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0 Alive Out: 0x1
DemandedBits: Visiting:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ] Alive Out: 0xffffffff
DemandedBits: Visiting:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] Alive Out: 0xffffffff
DemandedBits: Visiting:   %mul = add nsw i32 %sub, -20 Alive Out: 0xffffffff
DemandedBits: Visiting:   %sub = shl nuw nsw i32 %conv12, 2 Alive Out: 0xffffffff
DemandedBits: Visiting:   %conv12 = zext nneg i4 %11 to i32 Alive Out: 0xffffffff
DemandedBits: Visiting:   %11 = load i4, ptr %10, align 1 Alive Out: 0xf
DemandedBits: Visiting:   %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
DemandedBits: Visiting:   %dec25 = add nsw i32 %hdr_byte_left.053, -1 Alive Out: 0xffffffff
DemandedBits: Visiting:   %cmp18 = icmp sgt i32 %hdr_byte_left.155, 16 Alive Out: 0x1
DemandedBits: Visiting:   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ] Alive Out: 0xffffffff
DemandedBits: Visiting:   %dec = add nsw i32 %hdr_byte_left.053, -1 Alive Out: 0xffffffff
DemandedBits: Visiting:   %sub20 = add nsw i32 %hdr_byte_left.155, -16 Alive Out: 0xffffffff
DemandedBits: Visiting:   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28 Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %indirect-arg-temp43 = alloca i128, align 8
DemandedBits: Visiting:   %indirect-arg-temp = alloca i128, align 8
DemandedBits: Visiting:   %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16) Alive Out: 0xffffffffffffffff
DemandedBits: Visiting:   %cmp1854 = icmp sgt i32 %hdr_byte_left.053, 1 Alive Out: 0x1
DemandedBits: Visiting:   %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1) Alive Out: 0xff
DemandedBits: Visiting:   %cmp1352 = icmp ugt i4 %11, 5 Alive Out: 0x1
DemandedBits: Visiting:   %cmp9 = icmp sgt i4 %11, 0 Alive Out: 0x1
DemandedBits: Visiting:   %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
DemandedBits: Visiting:   %agg.tmp741 = alloca %struct.tcp_t, align 8
DemandedBits: Visiting:   %agg.tmp7 = alloca %struct.tcp_t, align 8
DemandedBits: Visiting:   %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
DemandedBits: Visiting:   %ref.tmp6 = alloca %struct.tcp_t, align 8
DemandedBits: Visiting:   %7 = load i8, ptr %6, align 1 Alive Out: 0xff
DemandedBits: Visiting:   %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
DemandedBits: Visiting:   %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
DemandedBits: Visiting:   %agg.tmp240 = alloca %struct.ipv4_t, align 8
DemandedBits: Visiting:   %agg.tmp2 = alloca %struct.ipv4_t, align 8
DemandedBits: Visiting:   %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
DemandedBits: Visiting:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
DemandedBits: Visiting:   %cmp = icmp eq i16 %3, 2048 Alive Out: 0x1
DemandedBits: Visiting:   %3 = load i16, ptr %2, align 2 Alive Out: 0xffff
DemandedBits: Visiting:   %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
DemandedBits: Visiting:   %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
DemandedBits: Visiting:   %agg.tmp39 = alloca %struct.ethernet_t, align 8
DemandedBits: Visiting:   %agg.tmp = alloca %struct.ethernet_t, align 8
DemandedBits: Visiting:   %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
DemandedBits: Visiting:   %ref.tmp = alloca %struct.ethernet_t, align 8
DemandedBits: Visiting:   %tcp = alloca %struct.tcp_t, align 8
DemandedBits: Visiting:   %ipv4 = alloca %struct.ipv4_t, align 8
DemandedBits: Visiting:   %eth = alloca %struct.ethernet_t, align 8
; *** IR Dump After BDCEPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  %cmp1352 = icmp ugt i4 %11, 5
  br i1 %cmp1352, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then10
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %dec = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp sgt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !29
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp sgt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !31

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit56

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit56:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit56, %if.end38.loopexit, %if.then10, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}


INSTCOMBINE ITERATION #1 on _Z12primate_mainv
ADD:   ret void
ADD:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
ADD:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
ADD:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
ADD:   tail call void @llvm.primate.input.done()
ADD:   br label %if.end38
ADD:   br i1 %cmp13, label %while.body, label %if.end38.loopexit56
ADD:   %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
ADD:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
ADD:   br label %if.end38
ADD:   br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !30
ADD:   %cmp18 = icmp sgt i32 %hdr_byte_left.155, 16
ADD:   %sub20 = add nsw i32 %hdr_byte_left.155, -16
ADD:   call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
ADD:   tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
ADD:   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
ADD:   call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
ADD:   store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !28
ADD:   %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
ADD:   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
ADD:   br label %while.body19
ADD:   br i1 %cmp1854, label %while.body19.preheader, label %if.end38
ADD:   %cmp1854 = icmp sgt i32 %hdr_byte_left.053, 1
ADD:   tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
ADD:   %dec = add nsw i32 %hdr_byte_left.053, -1
ADD:   br label %cleanup
ADD:   tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
ADD:   %dec25 = add nsw i32 %hdr_byte_left.053, -1
ADD:   switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]
ADD:   %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
ADD:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
ADD:   br label %while.body
ADD:   br i1 %cmp1352, label %while.body.preheader, label %if.end38
ADD:   %cmp1352 = icmp ugt i4 %11, 5
ADD:   %mul = add nsw i32 %sub, -20
ADD:   %sub = shl nuw nsw i32 %conv12, 2
ADD:   %conv12 = zext nneg i4 %11 to i32
ADD:   br i1 %cmp9, label %if.then10, label %if.end38
ADD:   %cmp9 = icmp sgt i4 %11, 0
ADD:   %11 = load i4, ptr %10, align 1
ADD:   %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
ADD:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
ADD:   tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
ADD:   %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
ADD:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !21
ADD:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !21
ADD:   store %struct.tcp_t %8, ptr %ref.tmp6, align 8
ADD:   %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
ADD:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
ADD:   br label %if.end38
ADD:   tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
ADD:   %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
ADD:   switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]
ADD:   %7 = load i8, ptr %6, align 1
ADD:   %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
ADD:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
ADD:   tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
ADD:   %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
ADD:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !14
ADD:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !14
ADD:   store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
ADD:   %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
ADD:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
ADD:   br i1 %cmp, label %if.then, label %if.end38
ADD:   %cmp = icmp eq i16 %3, 2048
ADD:   %3 = load i16, ptr %2, align 2
ADD:   %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
ADD:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
ADD:   tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
ADD:   %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
ADD:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !7
ADD:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
ADD:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !7
ADD:   store %struct.ethernet_t %0, ptr %ref.tmp, align 8
ADD:   %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
ADD:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
ADD:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
ADD:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
ADD:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
ADD:   %indirect-arg-temp = alloca i128, align 8
ADD:   %agg.tmp7 = alloca %struct.tcp_t, align 8
ADD:   %ref.tmp6 = alloca %struct.tcp_t, align 8
ADD:   %agg.tmp2 = alloca %struct.ipv4_t, align 8
ADD:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
ADD:   %agg.tmp = alloca %struct.ethernet_t, align 8
ADD:   %ref.tmp = alloca %struct.ethernet_t, align 8
ADD:   %tcp = alloca %struct.tcp_t, align 8
ADD:   %ipv4 = alloca %struct.ipv4_t, align 8
ADD:   %eth = alloca %struct.ethernet_t, align 8
ADD:   %agg.tmp39 = alloca %struct.ethernet_t, align 8
ADD:   %agg.tmp240 = alloca %struct.ipv4_t, align 8
ADD:   %agg.tmp741 = alloca %struct.tcp_t, align 8
ADD:   %indirect-arg-temp43 = alloca i128, align 8
IC: Visiting:   %indirect-arg-temp43 = alloca i128, align 8
IC: Visiting:   %agg.tmp741 = alloca %struct.tcp_t, align 8
IC: Visiting:   %agg.tmp240 = alloca %struct.ipv4_t, align 8
IC: Visiting:   %agg.tmp39 = alloca %struct.ethernet_t, align 8
IC: Visiting:   %eth = alloca %struct.ethernet_t, align 8
IC: Visiting:   %ipv4 = alloca %struct.ipv4_t, align 8
IC: Visiting:   %tcp = alloca %struct.tcp_t, align 8
IC: Visiting:   %ref.tmp = alloca %struct.ethernet_t, align 8
IC: Visiting:   %agg.tmp = alloca %struct.ethernet_t, align 8
IC: Visiting:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
IC: Visiting:   %agg.tmp2 = alloca %struct.ipv4_t, align 8
IC: Visiting:   %ref.tmp6 = alloca %struct.tcp_t, align 8
IC: Visiting:   %agg.tmp7 = alloca %struct.tcp_t, align 8
IC: Visiting:   %indirect-arg-temp = alloca i128, align 8
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
IC: Visiting:   %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
IC: Visiting:   store %struct.ethernet_t %0, ptr %ref.tmp, align 8
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !7
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !7
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
IC: Visiting:   %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
IC: Visiting:   tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
IC: Visiting:   %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
IC: Visiting:   %3 = load i16, ptr %2, align 2
IC: Visiting:   %cmp = icmp eq i16 %3, 2048
IC: Visiting:   br i1 %cmp, label %if.then, label %if.end38
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
IC: Visiting:   %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
IC: Visiting:   store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !14
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !14
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
IC: Visiting:   %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
IC: Visiting:   tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
IC: Visiting:   %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
IC: Visiting:   %7 = load i8, ptr %6, align 1
IC: Visiting:   switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]
IC: Visiting:   %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
IC: Visiting:   tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
IC: Visiting:   br label %if.end38
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
IC: Visiting:   %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
IC: Visiting:   store %struct.tcp_t %8, ptr %ref.tmp6, align 8
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !21
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
IC: Visiting:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !21
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
IC: Visiting:   %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
IC: Visiting:   tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
IC: Visiting:   %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
IC: Visiting:   %11 = load i4, ptr %10, align 1
IC: Visiting:   %cmp9 = icmp sgt i4 %11, 0
IC: Visiting:   br i1 %cmp9, label %if.then10, label %if.end38
IC: Visiting:   %conv12 = zext nneg i4 %11 to i32
IC: Visiting:   %sub = shl nuw nsw i32 %conv12, 2
IC: Sink:   %mul = add nsw i32 %sub, -20
ADD:   %sub = shl nuw nsw i32 %conv12, 2
IC: Visiting:   %mul = add nsw i32 %sub, -20
IC: Sink:   %sub = shl nuw nsw i32 %conv12, 2
ADD:   %conv12 = zext nneg i4 %11 to i32
IC: Visiting:   %sub = shl nuw nsw i32 %conv12, 2
IC: Sink:   %conv12 = zext nneg i4 %11 to i32
ADD:   %11 = load i4, ptr %10, align 1
IC: Visiting:   %conv12 = zext nneg i4 %11 to i32
IC: Visiting:   %11 = load i4, ptr %10, align 1
IC: Visiting:   %cmp1352 = icmp ugt i4 %11, 5
IC: Visiting:   br i1 %cmp1352, label %while.body.preheader, label %if.end38
IC: Visiting:   br label %while.body
IC: Visiting:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
IC: Visiting:   %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
IC: Visiting:   switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]
IC: Visiting:   %dec25 = add nsw i32 %hdr_byte_left.053, -1
IC: Visiting:   tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
IC: Visiting:   br label %cleanup
IC: Sink:   %dec = add nsw i32 %hdr_byte_left.053, -1
ADD:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
IC: Visiting:   %dec = add nsw i32 %hdr_byte_left.053, -1
IC: Visiting:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
IC: Visiting:   tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
IC: Visiting:   %cmp1854 = icmp sgt i32 %hdr_byte_left.053, 1
IC: Visiting:   br i1 %cmp1854, label %while.body19.preheader, label %if.end38
IC: Visiting:   br label %while.body19
IC: Visiting:   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
IC: Visiting:   %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
IC: Visiting:   store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !28
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
IC: Visiting:   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28
IC: Visiting:   tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
IC: Visiting:   %sub20 = add nsw i32 %hdr_byte_left.155, -16
IC: Visiting:   %cmp18 = icmp sgt i32 %hdr_byte_left.155, 16
IC: Visiting:   br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !30
IC: Visiting:   br label %if.end38
IC: Visiting:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
IC: Visiting:   %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
IC: Visiting:   br i1 %cmp13, label %while.body, label %if.end38.loopexit56
IC: Visiting:   br label %if.end38
IC: Visiting:   tail call void @llvm.primate.input.done()
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
IC: Visiting:   ret void


[IC] Iteration limit #1 on _Z12primate_mainv reached; stopping without verifying fixpoint
; *** IR Dump After InstCombinePass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %cmp1352 = icmp ugt i4 %11, 5
  br i1 %cmp1352, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then10
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp sgt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !29
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp sgt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !31

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit56

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit56:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit56, %if.end38.loopexit, %if.then10, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
Jump threading on function '_Z12primate_mainv'
LVI Getting value   %3 = load i16, ptr %2, align 2 at ''
  Result = overdefined
LVI Getting block end value   %3 = load i16, ptr %2, align 2 at 'entry'
PUSH:   %3 = load i16, ptr %2, align 2 in entry
 compute BB 'entry' - unknown inst def found.
POP   %3 = load i16, ptr %2, align 2 in entry = overdefined
  Result = overdefined
LVI Getting block end value   %7 = load i8, ptr %6, align 1 at 'if.then'
PUSH:   %7 = load i8, ptr %6, align 1 in if.then
 compute BB 'if.then' - unknown inst def found.
POP   %7 = load i8, ptr %6, align 1 in if.then = overdefined
  Result = overdefined
LVI Getting value   %11 = load i4, ptr %10, align 1 at ''
  Result = overdefined
LVI Getting block end value   %11 = load i4, ptr %10, align 1 at 'if.then5'
PUSH:   %11 = load i4, ptr %10, align 1 in if.then5
 compute BB 'if.then5' - unknown inst def found.
POP   %11 = load i4, ptr %10, align 1 in if.then5 = overdefined
  Result = overdefined
LVI Getting value   %11 = load i4, ptr %10, align 1 at ''
  Result = overdefined
LVI Getting edge value   %11 = load i4, ptr %10, align 1 from 'if.then5' to 'if.then10'
  Result = constantrange<1, -8>
LVI Getting edge value   %11 = load i4, ptr %10, align 1 from 'if.then5' to 'if.then10'
  Result = constantrange<1, -8>
LVI Getting value   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] at ''
  Result = overdefined
LVI Getting edge value   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] from 'while.body' to 'if.then16'
PUSH:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] in while.body
PUSH:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ] in cleanup
PUSH:   %dec25 = add nsw i32 %hdr_byte_left.053, -1 in if.then23
PUSH:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] in if.then23
 compute BB 'if.then23' - overdefined because of pred 'while.body' (non local).
POP   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] in if.then23 = overdefined
POP   %dec25 = add nsw i32 %hdr_byte_left.053, -1 in if.then23 = constantrange<-2147483648, 2147483647>
 compute BB 'cleanup' - overdefined because of pred (local).
POP   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ] in cleanup = overdefined
PUSH:   %mul = add nsw i32 %sub, -20 in while.body.preheader
PUSH:   %sub = shl nuw nsw i32 %conv12, 2 in while.body.preheader
PUSH:   %conv12 = zext nneg i4 %11 to i32 in while.body.preheader
PUSH:   %11 = load i4, ptr %10, align 1 in while.body.preheader
PUSH:   %11 = load i4, ptr %10, align 1 in if.then10
POP   %11 = load i4, ptr %10, align 1 in if.then10 = constantrange<1, -8>
POP   %11 = load i4, ptr %10, align 1 in while.body.preheader = constantrange<6, -8>
POP   %conv12 = zext nneg i4 %11 to i32 in while.body.preheader = constantrange<6, 8>
POP   %sub = shl nuw nsw i32 %conv12, 2 in while.body.preheader = constantrange<24, 29>
POP   %mul = add nsw i32 %sub, -20 in while.body.preheader = constantrange<4, 9>
POP   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] in while.body = constantrange<1, -2147483648>
  Result = constantrange<1, -2147483648>
LVI Getting edge value   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] from 'while.body' to 'if.then16'
  Result = constantrange<1, -2147483648>
LVI Getting value   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ] at ''
  Result = overdefined
LVI Getting edge value   %sub20 = add nsw i32 %hdr_byte_left.155, -16 from 'while.body19' to 'while.body19'
PUSH:   %sub20 = add nsw i32 %hdr_byte_left.155, -16 in while.body19
PUSH:   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ] in while.body19
PUSH:   %dec = add nsw i32 %hdr_byte_left.053, -1 in while.body19.preheader
PUSH:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] in while.body19.preheader
PUSH:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] in if.then16
POP   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] in if.then16 = constantrange<1, -2147483648>
POP   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] in while.body19.preheader = constantrange<2, -2147483648>
POP   %dec = add nsw i32 %hdr_byte_left.053, -1 in while.body19.preheader = constantrange<1, 2147483647>
POP   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ] in while.body19 = constantrange<1, 2147483647>
POP   %sub20 = add nsw i32 %hdr_byte_left.155, -16 in while.body19 = constantrange<-15, 2147483631>
  Result = constantrange<1, 2147483631>
LVI Getting value   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ] at ''
  Result = overdefined
LVI Getting edge value   %dec25 = add nsw i32 %hdr_byte_left.053, -1 from 'if.then23' to 'cleanup'
  Result = constantrange<-2147483648, 2147483647>
LVI Getting edge value   %dec25 = add nsw i32 %hdr_byte_left.053, -1 from 'if.then23' to 'cleanup'
  Result = constantrange<-2147483648, 2147483647>
LVI Getting edge value   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] from 'while.body' to 'cleanup'
  Result = constantrange<1, -2147483648>
IN BB: 
cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit56
  BB 'cleanup': FOUND condition = i1 true for pred 'while.body'.
  Not threading across block BB 'cleanup' to dest loop header BB 'while.body' - it might create an irreducible loop!
Looking to fold if.end38.loopexit into if.end38
Killing Trivial BB: 

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38
Looking to fold if.end38.loopexit56 into if.end38
Killing Trivial BB: 

if.end38.loopexit56:                              ; preds = %cleanup
  br label %if.end38
LVI Getting value   %3 = load i16, ptr %2, align 2 at ''
  Result = overdefined
LVI Getting block end value   %3 = load i16, ptr %2, align 2 at 'entry'
  Result = overdefined
LVI Getting block end value   %7 = load i8, ptr %6, align 1 at 'if.then'
  Result = overdefined
LVI Getting value   %11 = load i4, ptr %10, align 1 at ''
  Result = overdefined
LVI Getting block end value   %11 = load i4, ptr %10, align 1 at 'if.then5'
  Result = overdefined
LVI Getting value   %11 = load i4, ptr %10, align 1 at ''
  Result = overdefined
LVI Getting edge value   %11 = load i4, ptr %10, align 1 from 'if.then5' to 'if.then10'
  Result = constantrange<1, -8>
LVI Getting edge value   %11 = load i4, ptr %10, align 1 from 'if.then5' to 'if.then10'
  Result = constantrange<1, -8>
LVI Getting value   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] at ''
  Result = overdefined
LVI Getting edge value   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] from 'while.body' to 'if.then16'
  Result = constantrange<1, -2147483648>
LVI Getting edge value   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] from 'while.body' to 'if.then16'
  Result = constantrange<1, -2147483648>
LVI Getting value   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ] at ''
  Result = overdefined
LVI Getting edge value   %sub20 = add nsw i32 %hdr_byte_left.155, -16 from 'while.body19' to 'while.body19'
  Result = constantrange<1, 2147483631>
LVI Getting value   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ] at ''
  Result = overdefined
LVI Getting edge value   %dec25 = add nsw i32 %hdr_byte_left.053, -1 from 'if.then23' to 'cleanup'
  Result = constantrange<-2147483648, 2147483647>
LVI Getting edge value   %dec25 = add nsw i32 %hdr_byte_left.053, -1 from 'if.then23' to 'cleanup'
  Result = constantrange<-2147483648, 2147483647>
LVI Getting edge value   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] from 'while.body' to 'cleanup'
  Result = constantrange<1, -2147483648>
IN BB: 
cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38
  BB 'cleanup': FOUND condition = i1 true for pred 'while.body'.
  Not threading across block BB 'cleanup' to dest loop header BB 'while.body' - it might create an irreducible loop!
Inserting edge %while.body19 -> %if.end38
	Reachable %while.body19 -> %if.end38
		NCA == %entry
Deleting edge %while.body19 -> %if.end38.loopexit
	NCD %while.body19, ToIDom %while.body19
IsReachableFromIDom %if.end38.loopexit
Deleting unreachable subtree %if.end38.loopexit
Processing affected node %if.end38 with NCD = %entry, MinNode =%if.end38.loopexit
The entire tree needs to be rebuilt
DomTree recalculated, skipping future batch updates
; *** IR Dump After JumpThreadingPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %cmp1352 = icmp ugt i4 %11, 5
  br i1 %cmp1352, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then10
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp sgt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !29
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp sgt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !31

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then10, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
LVI Getting block end value   %3 = load i16, ptr %2, align 2 at 'entry'
  Result = overdefined
LVI Getting block end value   %7 = load i8, ptr %6, align 1 at 'if.then'
  Result = overdefined
LVI Getting block end value   %7 = load i8, ptr %6, align 1 at 'if.then'
  Result = overdefined
LVI Getting block end value   %11 = load i4, ptr %10, align 1 at 'if.then5'
  Result = overdefined
LVI Getting block end value   %11 = load i4, ptr %10, align 1 at 'if.then5'
  Result = overdefined
LVI Getting block end value i4 0 at 'if.then5'
  Result = constantrange<0, 1>
LVI Getting block end value   %11 = load i4, ptr %10, align 1 at 'if.then10'
  Result = constantrange<1, -8>
LVI Getting edge value   %11 = load i4, ptr %10, align 1 from 'if.then5' to 'if.then10'
  Result = constantrange<1, -8>
LVI Getting block end value   %sub = shl nuw nsw i32 %conv12, 2 at 'while.body.preheader'
  Result = constantrange<24, 29>
LVI Getting block end value i32 -20 at 'while.body.preheader'
  Result = constantrange<-20, -19>
LVI Getting edge value   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ] from 'cleanup' to 'while.body'
  Result = constantrange<1, -2147483648>
LVI Getting edge value   %mul = add nsw i32 %sub, -20 from 'while.body.preheader' to 'while.body'
  Result = constantrange<4, 9>
LVI Getting block end value   %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1) at 'while.body'
PUSH:   %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1) in while.body
 compute BB 'while.body' - unknown intrinsic.
POP   %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1) in while.body = overdefined
  Result = overdefined
LVI Getting block end value   %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1) at 'while.body'
  Result = overdefined
LVI Getting edge value   %dec25 = add nsw i32 %hdr_byte_left.053, -1 from 'if.then23' to 'cleanup'
  Result = constantrange<-2147483648, 2147483647>
LVI Getting edge value   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] from 'while.body' to 'cleanup'
  Result = constantrange<1, -2147483648>
LVI Getting block end value   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ] at 'cleanup'
  Result = overdefined
LVI Getting edge value   %dec25 = add nsw i32 %hdr_byte_left.053, -1 from 'if.then23' to 'cleanup'
  Result = constantrange<-2147483648, 2147483647>
LVI Getting block end value   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ] at 'cleanup'
  Result = overdefined
LVI Getting block end value i32 0 at 'cleanup'
  Result = constantrange<0, 1>
LVI Getting block end value   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] at 'if.then16'
  Result = constantrange<1, -2147483648>
LVI Getting edge value   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] from 'while.body' to 'if.then16'
  Result = constantrange<1, -2147483648>
LVI Getting block end value   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] at 'if.then16'
  Result = constantrange<1, -2147483648>
LVI Getting block end value i32 1 at 'if.then16'
  Result = constantrange<1, 2>
LVI Getting block end value   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] at 'while.body19.preheader'
  Result = constantrange<2, -2147483648>
LVI Getting block end value i32 -1 at 'while.body19.preheader'
  Result = constantrange<-1, 0>
LVI Getting edge value   %sub20 = add nsw i32 %hdr_byte_left.155, -16 from 'while.body19' to 'while.body19'
  Result = constantrange<1, 2147483631>
LVI Getting edge value   %dec = add nsw i32 %hdr_byte_left.053, -1 from 'while.body19.preheader' to 'while.body19'
  Result = constantrange<1, 2147483647>
LVI Getting block end value   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ] at 'while.body19'
  Result = constantrange<1, 2147483647>
LVI Getting block end value i32 -16 at 'while.body19'
  Result = constantrange<-16, -15>
LVI Getting block end value   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ] at 'while.body19'
  Result = constantrange<1, 2147483647>
LVI Getting edge value   %sub20 = add nsw i32 %hdr_byte_left.155, -16 from 'while.body19' to 'while.body19'
  Result = constantrange<1, 2147483631>
LVI Getting block end value   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ] at 'while.body19'
  Result = constantrange<1, 2147483647>
LVI Getting block end value i32 16 at 'while.body19'
  Result = constantrange<16, 17>
LVI Getting block end value   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ] at 'if.then23'
  Result = overdefined
LVI Getting block end value i32 -1 at 'if.then23'
  Result = constantrange<-1, 0>
; *** IR Dump After CorrelatedValuePropagationPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %cmp1352 = icmp ugt i4 %11, 5
  br i1 %cmp1352, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then10
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !29
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !31

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then10, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
		Looking for trivial roots
Found a new trivial root: %if.end38
Last visited node: %while.body19.preheader
		Looking for non-trivial roots
Total: 13, Num: 14
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %if.end38
3: %entry
4: %if.then33
5: %if.then
6: %if.then5
7: %if.then16
8: %while.body
9: %cleanup
10: %if.then23
11: %while.body.preheader
12: %if.then10
13: %while.body19
14: %while.body19.preheader
Found roots: %if.end38 
mark live:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
mark block live: entry
mark live:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
mark live:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
mark live:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
mark live:   %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
mark live:   store %struct.ethernet_t %0, ptr %ref.tmp, align 8
mark live:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !7
mark live:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
mark live:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !7
mark live:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
mark live:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
mark live:   tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
mark live:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
mark live:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
mark block live: if.then
mark live:   %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
mark live:   store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
mark live:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !14
mark live:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
mark live:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !14
mark live:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
mark live:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
mark live:   tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
mark live:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
mark live:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
mark block live: if.then5
mark live:   %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
mark live:   store %struct.tcp_t %8, ptr %ref.tmp6, align 8
mark live:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !21
mark live:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
mark live:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !21
mark live:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
mark live:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
mark live:   tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
mark live:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
mark live:   %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
mark block live: while.body
mark live:   tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
mark block live: if.then16
mark live:   %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
mark block live: while.body19
mark live:   store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !28
mark live:   call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
mark live:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
mark live:   tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
mark live:   call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
mark live:   tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
mark block live: if.then23
mark live:   br label %cleanup
mark live:   %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
mark block live: if.then33
mark live:   br label %if.end38
mark live:   tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
mark live:   tail call void @llvm.primate.input.done()
mark block live: if.end38
mark live:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
mark live:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
mark live:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
mark live:   ret void
mark live:   br i1 %cmp13, label %while.body, label %if.end38
mark block live: cleanup
mark live:   br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !30
post-dom root child is a return: if.end38
work live:   br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !30
mark live:   %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
work live:   %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
mark live:   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
work live:   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
mark live:   %sub20 = add nsw i32 %hdr_byte_left.155, -16
mark live:   %dec = add nsw i32 %hdr_byte_left.053, -1
mark block live: while.body19.preheader
mark live:   br label %while.body19
work live:   br label %while.body19
work live:   %dec = add nsw i32 %hdr_byte_left.053, -1
mark live:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
work live:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
mark live:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
mark live:   %mul = add nsw i32 %sub, -20
mark block live: while.body.preheader
mark live:   br label %while.body
work live:   br label %while.body
work live:   %mul = add nsw i32 %sub, -20
mark live:   %sub = shl nuw nsw i32 %conv12, 2
work live:   %sub = shl nuw nsw i32 %conv12, 2
mark live:   %conv12 = zext nneg i4 %11 to i32
work live:   %conv12 = zext nneg i4 %11 to i32
mark live:   %11 = load i4, ptr %10, align 1
work live:   %11 = load i4, ptr %10, align 1
mark live:   %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
work live:   %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
mark live:   %tcp = alloca %struct.tcp_t, align 8
work live:   %tcp = alloca %struct.tcp_t, align 8
work live:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
mark live:   %dec25 = add nsw i32 %hdr_byte_left.053, -1
work live:   %dec25 = add nsw i32 %hdr_byte_left.053, -1
work live:   %sub20 = add nsw i32 %hdr_byte_left.155, -16
work live:   br i1 %cmp13, label %while.body, label %if.end38
mark live:   %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
work live:   %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
work live:   ret void
work live:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
mark live:   %eth = alloca %struct.ethernet_t, align 8
work live:   %eth = alloca %struct.ethernet_t, align 8
work live:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
mark live:   %ipv4 = alloca %struct.ipv4_t, align 8
work live:   %ipv4 = alloca %struct.ipv4_t, align 8
work live:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
work live:   tail call void @llvm.primate.input.done()
work live:   tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
work live:   br label %if.end38
work live:   %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
work live:   br label %cleanup
work live:   tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
work live:   call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
mark live:   %indirect-arg-temp43 = alloca i128, align 8
work live:   %indirect-arg-temp43 = alloca i128, align 8
work live:   tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
mark live:   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28
work live:   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !28
work live:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
mark live:   %indirect-arg-temp = alloca i128, align 8
work live:   %indirect-arg-temp = alloca i128, align 8
work live:   call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
work live:   store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !28
work live:   %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
work live:   tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
work live:   %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
work live:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
mark live:   %agg.tmp741 = alloca %struct.tcp_t, align 8
work live:   %agg.tmp741 = alloca %struct.tcp_t, align 8
work live:   tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
mark live:   %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
work live:   %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
work live:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
mark live:   %agg.tmp7 = alloca %struct.tcp_t, align 8
work live:   %agg.tmp7 = alloca %struct.tcp_t, align 8
work live:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
work live:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !21
work live:   call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
mark live:   %ref.tmp6 = alloca %struct.tcp_t, align 8
work live:   %ref.tmp6 = alloca %struct.tcp_t, align 8
work live:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !21
work live:   store %struct.tcp_t %8, ptr %ref.tmp6, align 8
work live:   %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
work live:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
work live:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
mark live:   %agg.tmp240 = alloca %struct.ipv4_t, align 8
work live:   %agg.tmp240 = alloca %struct.ipv4_t, align 8
work live:   tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
mark live:   %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
work live:   %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
work live:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
mark live:   %agg.tmp2 = alloca %struct.ipv4_t, align 8
work live:   %agg.tmp2 = alloca %struct.ipv4_t, align 8
work live:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
work live:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !14
work live:   call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
mark live:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
work live:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
work live:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !14
work live:   store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
work live:   %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
work live:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
work live:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
mark live:   %agg.tmp39 = alloca %struct.ethernet_t, align 8
work live:   %agg.tmp39 = alloca %struct.ethernet_t, align 8
work live:   tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
mark live:   %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
work live:   %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
work live:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
mark live:   %agg.tmp = alloca %struct.ethernet_t, align 8
work live:   %agg.tmp = alloca %struct.ethernet_t, align 8
work live:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
work live:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !7
work live:   call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
mark live:   %ref.tmp = alloca %struct.ethernet_t, align 8
work live:   %ref.tmp = alloca %struct.ethernet_t, align 8
work live:   call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !7
work live:   store %struct.ethernet_t %0, ptr %ref.tmp, align 8
work live:   %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
work live:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
work live:   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
work live:   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
work live:   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
new live blocks:
	entry
	if.then
	if.then5
	while.body
	if.then16
	while.body19
	if.then23
	if.then33
	if.end38
	cleanup
	while.body19.preheader
	while.body.preheader
dead terminator blocks:
	entry
	if.then
	if.then5
	if.then10
	while.body
	if.then16
live control in: if.then16
mark live:   br i1 %cmp1854, label %while.body19.preheader, label %if.end38
live control in: while.body
mark live:   switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]
live control in: if.then10
mark live:   br i1 %cmp1352, label %while.body.preheader, label %if.end38
mark block live: if.then10
live control in: if.then5
mark live:   br i1 %cmp9, label %if.then10, label %if.end38
live control in: if.then
mark live:   switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]
live control in: entry
mark live:   br i1 %cmp, label %if.then, label %if.end38
work live:   br i1 %cmp, label %if.then, label %if.end38
mark live:   %cmp = icmp eq i16 %3, 2048
work live:   %cmp = icmp eq i16 %3, 2048
mark live:   %3 = load i16, ptr %2, align 2
work live:   %3 = load i16, ptr %2, align 2
mark live:   %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
work live:   %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
work live:   switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]
mark live:   %7 = load i8, ptr %6, align 1
work live:   %7 = load i8, ptr %6, align 1
mark live:   %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
work live:   %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
work live:   br i1 %cmp9, label %if.then10, label %if.end38
mark live:   %cmp9 = icmp sgt i4 %11, 0
work live:   %cmp9 = icmp sgt i4 %11, 0
work live:   br i1 %cmp1352, label %while.body.preheader, label %if.end38
mark live:   %cmp1352 = icmp ugt i4 %11, 5
work live:   %cmp1352 = icmp ugt i4 %11, 5
work live:   switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]
work live:   br i1 %cmp1854, label %while.body19.preheader, label %if.end38
mark live:   %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
work live:   %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
final dead terminator blocks: 
; *** IR Dump After ADCEPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %agg.tmp741 = alloca %struct.tcp_t, align 8
  %agg.tmp240 = alloca %struct.ipv4_t, align 8
  %agg.tmp39 = alloca %struct.ethernet_t, align 8
  %eth = alloca %struct.ethernet_t, align 8
  %ipv4 = alloca %struct.ipv4_t, align 8
  %tcp = alloca %struct.tcp_t, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %agg.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %agg.tmp2 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %agg.tmp7 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %eth) #1
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %ref.tmp) #1
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %ref.tmp) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %eth, i32 24, i1 false), !tbaa.struct !8
  call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, i64 24, i1 false)
  %1 = load %struct.ethernet_t, ptr %agg.tmp39, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %agg.tmp39)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %eth, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %ref.tmp1) #1
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ref.tmp1) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ipv4, i32 40, i1 false), !tbaa.struct !15
  call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, i64 40, i1 false)
  %5 = load %struct.ipv4_t, ptr %agg.tmp240, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %agg.tmp240)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ipv4, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %ref.tmp6) #1
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %ref.tmp6) #1
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %tcp, i32 32, i1 false), !tbaa.struct !22
  call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, i64 32, i1 false)
  %9 = load %struct.tcp_t, ptr %agg.tmp741, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %agg.tmp741)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %tcp, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %cmp1352 = icmp ugt i4 %11, 5
  br i1 %cmp1352, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then10
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !29
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !29
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !31

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then10, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  call void @llvm.lifetime.end.p0(i64 32, ptr nonnull %tcp) #1
  call void @llvm.lifetime.end.p0(i64 40, ptr nonnull %ipv4) #1
  call void @llvm.lifetime.end.p0(i64 24, ptr nonnull %eth) #1
  ret void
}
Captured?:   %eth = alloca %struct.ethernet_t, align 8 = not captured
Clobber starting at access 6 = MemoryDef(5)
  for instruction   store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  is 1 = MemoryDef(liveOnEntry)
Clobber starting at access 6 = MemoryDef(5)
  for instruction   store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  is 6 = MemoryDef(5)
Stack Move: Attempting to optimize:
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %eth, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !7
Stack Move: Performed staack-move optimization
Captured?:   %agg.tmp = alloca %struct.ethernet_t, align 8 = not captured
Clobber starting at access 6 = MemoryDef(5)
  for instruction   store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  is 0 = MemoryDef(liveOnEntry)
Clobber starting at access 6 = MemoryDef(5)
  for instruction   store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  is 6 = MemoryDef(5)
Stack Move: Attempting to optimize:
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i32 24, i1 false), !tbaa.struct !7
Stack Move: Performed staack-move optimization
Captured?:   %agg.tmp39 = alloca %struct.ethernet_t, align 8 = not captured
Clobber starting at access 10 = MemoryDef(6)
  for instruction   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  is 10 = MemoryDef(6)
Captured?:   %ref.tmp = alloca %struct.ethernet_t, align 8 = not captured
Clobber starting at access 10 = MemoryDef(6)
  for instruction   call void @llvm.lifetime.start.p0(i64 24, ptr nonnull %agg.tmp39)
  is 6 = MemoryDef(5)
Stack Move: Attempting to optimize:
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(24) %agg.tmp39, ptr noundef nonnull align 8 dereferenceable(24) %ref.tmp, i64 24, i1 false)
Stack Move: Performed staack-move optimization
Captured?:   %ipv4 = alloca %struct.ipv4_t, align 8 = not captured
Clobber starting at access 16 = MemoryDef(15)
  for instruction   store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  is 2 = MemoryDef(liveOnEntry)
Clobber starting at access 16 = MemoryDef(15)
  for instruction   store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  is 16 = MemoryDef(15)
Stack Move: Attempting to optimize:
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %ipv4, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !7
Stack Move: Performed staack-move optimization
Captured?:   %agg.tmp2 = alloca %struct.ipv4_t, align 8 = not captured
Clobber starting at access 16 = MemoryDef(15)
  for instruction   store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  is 0 = MemoryDef(liveOnEntry)
Clobber starting at access 16 = MemoryDef(15)
  for instruction   store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  is 16 = MemoryDef(15)
Stack Move: Attempting to optimize:
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp2, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i32 40, i1 false), !tbaa.struct !7
Stack Move: Performed staack-move optimization
Captured?:   %agg.tmp240 = alloca %struct.ipv4_t, align 8 = not captured
Clobber starting at access 20 = MemoryDef(16)
  for instruction   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  is 20 = MemoryDef(16)
Captured?:   %ref.tmp1 = alloca %struct.ipv4_t, align 8 = not captured
Clobber starting at access 20 = MemoryDef(16)
  for instruction   call void @llvm.lifetime.start.p0(i64 40, ptr nonnull %agg.tmp240)
  is 16 = MemoryDef(15)
Stack Move: Attempting to optimize:
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(40) %agg.tmp240, ptr noundef nonnull align 8 dereferenceable(40) %ref.tmp1, i64 40, i1 false)
Stack Move: Performed staack-move optimization
Captured?:   %tcp = alloca %struct.tcp_t, align 8 = not captured
Clobber starting at access 26 = MemoryDef(25)
  for instruction   store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  is 3 = MemoryDef(liveOnEntry)
Clobber starting at access 26 = MemoryDef(25)
  for instruction   store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  is 26 = MemoryDef(25)
Stack Move: Attempting to optimize:
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %tcp, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !7
Stack Move: Performed staack-move optimization
Clobber starting at access 26 = MemoryDef(25)
  for instruction   store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  is 0 = MemoryDef(liveOnEntry)
Clobber starting at access 26 = MemoryDef(25)
  for instruction   store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  is 26 = MemoryDef(25)
Stack Move: Attempting to optimize:
  call void @llvm.memcpy.p0.p0.i32(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp7, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i32 32, i1 false), !tbaa.struct !7
Captured?:   %agg.tmp7 = alloca %struct.tcp_t, align 8 = not captured
Stack Move: Performed staack-move optimization
Captured?:   %agg.tmp741 = alloca %struct.tcp_t, align 8 = not captured
Clobber starting at access 30 = MemoryDef(26)
  for instruction   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  is 30 = MemoryDef(26)
Captured?:   %ref.tmp6 = alloca %struct.tcp_t, align 8 = not captured
Clobber starting at access 30 = MemoryDef(26)
  for instruction   call void @llvm.lifetime.start.p0(i64 32, ptr nonnull %agg.tmp741)
  is 26 = MemoryDef(25)
Stack Move: Attempting to optimize:
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(32) %agg.tmp741, ptr noundef nonnull align 8 dereferenceable(32) %ref.tmp6, i64 32, i1 false)
Stack Move: Performed staack-move optimization
Captured?:   %indirect-arg-temp43 = alloca i128, align 8 = not captured
Clobber starting at access 38 = MemoryDef(37)
  for instruction   call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  is 38 = MemoryDef(37)
Captured?:   %indirect-arg-temp = alloca i128, align 8 = not captured
Clobber starting at access 38 = MemoryDef(37)
  for instruction   call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  is 37 = MemoryDef(36)
Stack Move: Attempting to optimize:
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
Captured?:   %indirect-arg-temp43 = alloca i128, align 8 = not captured
Clobber starting at access 38 = MemoryDef(37)
  for instruction   call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  is 38 = MemoryDef(37)
Captured?:   %indirect-arg-temp = alloca i128, align 8 = not captured
Clobber starting at access 38 = MemoryDef(37)
  for instruction   call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  is 37 = MemoryDef(36)
Stack Move: Attempting to optimize:
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
; *** IR Dump After MemCpyOptPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  %1 = load %struct.ethernet_t, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  %5 = load %struct.ipv4_t, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  %9 = load %struct.tcp_t, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %cmp1352 = icmp ugt i4 %11, 5
  br i1 %cmp1352, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then10
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then10, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
Trying to eliminate MemoryDefs killed by 37 = MemoryDef(36) (  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !7)
  trying to get dominating access
   visiting 36 = MemoryDef(49) (  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16))
   visiting 49 = MemoryPhi({while.body19.preheader,35},{while.body19,41})
   ...  found MemoryPhi
 Checking if we can kill 49 = MemoryPhi({while.body19.preheader,35},{while.body19,41})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 35 = MemoryDef(34) (  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1))
   visiting 34 = MemoryDef(52) (  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1))
   visiting 52 = MemoryPhi({while.body.preheader,32},{cleanup,51})
   ...  found MemoryPhi
 Checking if we can kill 52 = MemoryPhi({while.body.preheader,32},{cleanup,51})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 32 = MemoryDef(26) (  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32))
   visiting 26 = MemoryDef(25) (  store %struct.tcp_t %8, ptr %ref.tmp6, align 8)
   visiting 25 = MemoryDef(22) (  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32))
   visiting 22 = MemoryDef(16) (  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40))
   visiting 16 = MemoryDef(15) (  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8)
   visiting 15 = MemoryDef(12) (  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40))
   visiting 12 = MemoryDef(6) (  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24))
   visiting 6 = MemoryDef(5) (  store %struct.ethernet_t %0, ptr %ref.tmp, align 8)
   visiting 5 = MemoryDef(liveOnEntry) (  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24))
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
Trying to eliminate MemoryDefs killed by 38 = MemoryDef(37) (  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43))
  trying to get dominating access
   visiting 37 = MemoryDef(36) (  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !7)
   visiting 36 = MemoryDef(49) (  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16))
   visiting 49 = MemoryPhi({while.body19.preheader,35},{while.body19,41})
   ...  found MemoryPhi
 Checking if we can kill 49 = MemoryPhi({while.body19.preheader,35},{while.body19,41})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 35 = MemoryDef(34) (  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1))
   visiting 34 = MemoryDef(52) (  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1))
   visiting 52 = MemoryPhi({while.body.preheader,32},{cleanup,51})
   ...  found MemoryPhi
 Checking if we can kill 52 = MemoryPhi({while.body.preheader,32},{cleanup,51})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 32 = MemoryDef(26) (  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32))
   visiting 26 = MemoryDef(25) (  store %struct.tcp_t %8, ptr %ref.tmp6, align 8)
   visiting 25 = MemoryDef(22) (  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32))
   visiting 22 = MemoryDef(16) (  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40))
   visiting 16 = MemoryDef(15) (  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8)
   visiting 15 = MemoryDef(12) (  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40))
   visiting 12 = MemoryDef(6) (  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24))
   visiting 6 = MemoryDef(5) (  store %struct.ethernet_t %0, ptr %ref.tmp, align 8)
   visiting 5 = MemoryDef(liveOnEntry) (  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24))
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
Trying to eliminate MemoryDefs killed by 39 = MemoryDef(38) (  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false))
  trying to get dominating access
   visiting 38 = MemoryDef(37) (  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43))
   visiting 37 = MemoryDef(36) (  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !7)
   visiting 36 = MemoryDef(49) (  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16))
   visiting 49 = MemoryPhi({while.body19.preheader,35},{while.body19,41})
   ...  found MemoryPhi
 Checking if we can kill 49 = MemoryPhi({while.body19.preheader,35},{while.body19,41})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 35 = MemoryDef(34) (  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1))
   visiting 34 = MemoryDef(52) (  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1))
   visiting 52 = MemoryPhi({while.body.preheader,32},{cleanup,51})
   ...  found MemoryPhi
 Checking if we can kill 52 = MemoryPhi({while.body.preheader,32},{cleanup,51})
  ... adding incoming values to worklist
  trying to get dominating access
   visiting 32 = MemoryDef(26) (  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32))
   visiting 26 = MemoryDef(25) (  store %struct.tcp_t %8, ptr %ref.tmp6, align 8)
   visiting 25 = MemoryDef(22) (  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32))
   visiting 22 = MemoryDef(16) (  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40))
   visiting 16 = MemoryDef(15) (  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8)
   visiting 15 = MemoryDef(12) (  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40))
   visiting 12 = MemoryDef(6) (  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24))
   visiting 6 = MemoryDef(5) (  store %struct.ethernet_t %0, ptr %ref.tmp, align 8)
   visiting 5 = MemoryDef(liveOnEntry) (  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24))
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
Trying to eliminate MemoryDefs killed by 41 = MemoryDef(40) (  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43))
  trying to get dominating access
   visiting 40 = MemoryDef(39) (  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16))
   visiting 39 = MemoryDef(38) (  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false))
   ...  found a read clobber
  finished walk
Trying to eliminate MemoryDefs killed by 26 = MemoryDef(25) (  store %struct.tcp_t %8, ptr %ref.tmp6, align 8)
  trying to get dominating access
   visiting 25 = MemoryDef(22) (  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32))
   visiting 22 = MemoryDef(16) (  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40))
   visiting 16 = MemoryDef(15) (  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8)
   visiting 15 = MemoryDef(12) (  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40))
   visiting 12 = MemoryDef(6) (  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24))
   visiting 6 = MemoryDef(5) (  store %struct.ethernet_t %0, ptr %ref.tmp, align 8)
   visiting 5 = MemoryDef(liveOnEntry) (  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24))
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
Trying to eliminate MemoryDefs killed by 16 = MemoryDef(15) (  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8)
  trying to get dominating access
   visiting 15 = MemoryDef(12) (  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40))
   visiting 12 = MemoryDef(6) (  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24))
   visiting 6 = MemoryDef(5) (  store %struct.ethernet_t %0, ptr %ref.tmp, align 8)
   visiting 5 = MemoryDef(liveOnEntry) (  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24))
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
Trying to eliminate MemoryDefs killed by 6 = MemoryDef(5) (  store %struct.ethernet_t %0, ptr %ref.tmp, align 8)
  trying to get dominating access
   visiting 5 = MemoryDef(liveOnEntry) (  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24))
   visiting 0 = MemoryDef(liveOnEntry)
   ...  found LiveOnEntryDef
  finished walk
Trying to eliminate MemoryDefs that write the already existing value
Trying to eliminate MemoryDefs at the end of the function
  Check if def 6 = MemoryDef(5) (  store %struct.ethernet_t %0, ptr %ref.tmp, align 8) is at the end the function 
  ... hit read clobber   %1 = load %struct.ethernet_t, ptr %ref.tmp, align 8.
  Check if def 16 = MemoryDef(15) (  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8) is at the end the function 
  ... hit read clobber   %5 = load %struct.ipv4_t, ptr %ref.tmp1, align 8.
  Check if def 26 = MemoryDef(25) (  store %struct.tcp_t %8, ptr %ref.tmp6, align 8) is at the end the function 
  ... hit read clobber   %9 = load %struct.tcp_t, ptr %ref.tmp6, align 8.
  Check if def 39 = MemoryDef(38) (  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)) is at the end the function 
  ... hit read clobber   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !7.
  Check if def 37 = MemoryDef(36) (  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !7) is at the end the function 
  ... hit read clobber   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false).
; *** IR Dump After DSEPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  %1 = load %struct.ethernet_t, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  %5 = load %struct.ipv4_t, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  %9 = load %struct.tcp_t, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %cmp1352 = icmp ugt i4 %11, 5
  br i1 %cmp1352, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then10
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then10, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After MoveAutoInitPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  %1 = load %struct.ethernet_t, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  %5 = load %struct.ipv4_t, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  %9 = load %struct.tcp_t, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %cmp1352 = icmp ugt i4 %11, 5
  br i1 %cmp1352, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then10
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then10, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
LoopSimplify: Creating dedicated exit block if.end38.loopexit
LoopSimplify: Creating dedicated exit block if.end38.loopexit59
; *** IR Dump After LoopSimplifyPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  %1 = load %struct.ethernet_t, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  %5 = load %struct.ipv4_t, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  %9 = load %struct.tcp_t, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %cmp1352 = icmp ugt i4 %11, 5
  br i1 %cmp1352, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then10
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit59

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit59:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit59, %if.end38.loopexit, %if.then10, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LCSSAPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  %1 = load %struct.ethernet_t, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  %5 = load %struct.ipv4_t, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  %9 = load %struct.tcp_t, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %cmp1352 = icmp ugt i4 %11, 5
  br i1 %cmp1352, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then10
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit59

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit59:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit59, %if.end38.loopexit, %if.then10, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LICMPass on while.body ***

; Preheader:
while.body.preheader:                             ; preds = %if.then10
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

; Loop:
while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit59

; Exit blocks
if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

if.end38.loopexit59:                              ; preds = %cleanup
  br label %if.end38
Captured?:   %indirect-arg-temp43 = alloca i128, align 8 = not captured
Starting Memory SSA clobber for   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !7 is MemoryUse(39)
Optimized Memory SSA clobber for   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !7 is 39 = MemoryDef(38)
Result Memory SSA clobber [SkipSelf = 1] for   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !7 is 39 = MemoryDef(38)
Captured?:   %indirect-arg-temp = alloca i128, align 8 = not captured
; *** IR Dump After LICMPass on while.body19 ***

; Preheader:
while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  br label %while.body19

; Loop:
while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !7
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !7
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !11

; Exit blocks
if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38
; *** IR Dump After CoroElidePass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  %1 = load %struct.ethernet_t, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  %5 = load %struct.ipv4_t, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  %9 = load %struct.tcp_t, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  br i1 %cmp9, label %if.then10, label %if.end38

if.then10:                                        ; preds = %if.then5
  %cmp1352 = icmp ugt i4 %11, 5
  br i1 %cmp1352, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then10
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit59

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit59:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit59, %if.end38.loopexit, %if.then10, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
FOLDING BRANCH TO COMMON DEST:
  br i1 %cmp9, label %if.then10, label %if.end38
if.then10:                                        ; preds = %if.then5
  %cmp1352 = icmp ugt i4 %11, 5
  br i1 %cmp1352, label %while.body.preheader, label %if.end38
Removing BB: 

if.then10:                                        ; No predecessors!
  %cmp1352.old = icmp ugt i4 %11, 5
  br i1 %cmp1352.old, label %while.body.preheader, label %if.end38
Looking to fold if.end38.loopexit into if.end38
Killing Trivial BB: 

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38
Looking to fold if.end38.loopexit59 into if.end38
Killing Trivial BB: 

if.end38.loopexit59:                              ; preds = %cleanup
  br label %if.end38
; *** IR Dump After SimplifyCFGPass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  %1 = load %struct.ethernet_t, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
  %2 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %3 = load i16, ptr %2, align 2
  %cmp = icmp eq i16 %3, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
  %5 = load %struct.ipv4_t, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
  %6 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %7 = load i8, ptr %6, align 1
  switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %8, ptr %ref.tmp6, align 8
  %9 = load %struct.tcp_t, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
  %10 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %11 = load i4, ptr %10, align 1
  %cmp9 = icmp sgt i4 %11, 0
  %cmp1352 = icmp ugt i4 %11, 5
  %or.cond = and i1 %cmp9, %cmp1352
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %11 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}


INSTCOMBINE ITERATION #1 on _Z12primate_mainv
ADD:   ret void
ADD:   tail call void @llvm.primate.input.done()
ADD:   br i1 %cmp13, label %while.body, label %if.end38
ADD:   %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
ADD:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
ADD:   br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !11
ADD:   %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
ADD:   %sub20 = add nsw i32 %hdr_byte_left.155, -16
ADD:   call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
ADD:   tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
ADD:   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !7
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
ADD:   call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
ADD:   store i128 %13, ptr %indirect-arg-temp, align 8, !tbaa !7
ADD:   %13 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
ADD:   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
ADD:   br label %while.body19
ADD:   %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
ADD:   br i1 %cmp1854, label %while.body19.preheader, label %if.end38
ADD:   %cmp1854 = icmp ugt i32 %hdr_byte_left.053.lcssa, 1
ADD:   tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
ADD:   %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
ADD:   br label %cleanup
ADD:   tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
ADD:   %dec25 = add nsw i32 %hdr_byte_left.053, -1
ADD:   switch i8 %12, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]
ADD:   %12 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
ADD:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
ADD:   br label %while.body
ADD:   %mul = add nsw i32 %sub, -20
ADD:   %sub = shl nuw nsw i32 %conv12, 2
ADD:   %conv12 = zext nneg i4 %11 to i32
ADD:   br i1 %or.cond, label %while.body.preheader, label %if.end38
ADD:   %or.cond = and i1 %cmp9, %cmp1352
ADD:   %cmp1352 = icmp ugt i4 %11, 5
ADD:   %cmp9 = icmp sgt i4 %11, 0
ADD:   %11 = load i4, ptr %10, align 1
ADD:   %10 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
ADD:   tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %9, i32 32)
ADD:   %9 = load %struct.tcp_t, ptr %ref.tmp6, align 8
ADD:   store %struct.tcp_t %8, ptr %ref.tmp6, align 8
ADD:   %8 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
ADD:   br label %if.end38
ADD:   tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %14, i32 8)
ADD:   %14 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
ADD:   switch i8 %7, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]
ADD:   %7 = load i8, ptr %6, align 1
ADD:   %6 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
ADD:   tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %5, i32 40)
ADD:   %5 = load %struct.ipv4_t, ptr %ref.tmp1, align 8
ADD:   store %struct.ipv4_t %4, ptr %ref.tmp1, align 8
ADD:   %4 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
ADD:   br i1 %cmp, label %if.then, label %if.end38
ADD:   %cmp = icmp eq i16 %3, 2048
ADD:   %3 = load i16, ptr %2, align 2
ADD:   %2 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
ADD:   tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %1, i32 24)
ADD:   %1 = load %struct.ethernet_t, ptr %ref.tmp, align 8
ADD:   store %struct.ethernet_t %0, ptr %ref.tmp, align 8
ADD:   %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
ADD:   %indirect-arg-temp = alloca i128, align 8
ADD:   %ref.tmp6 = alloca %struct.tcp_t, align 8
ADD:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
ADD:   %ref.tmp = alloca %struct.ethernet_t, align 8
ADD:   %indirect-arg-temp43 = alloca i128, align 8
IC: Visiting:   %indirect-arg-temp43 = alloca i128, align 8
IC: Visiting:   %ref.tmp = alloca %struct.ethernet_t, align 8
IC: Visiting:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
IC: Visiting:   %ref.tmp6 = alloca %struct.tcp_t, align 8
IC: Visiting:   %indirect-arg-temp = alloca i128, align 8
IC: Visiting:   %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
IC: Visiting:   store %struct.ethernet_t %0, ptr %ref.tmp, align 8
IC: Visiting:   %1 = load %struct.ethernet_t, ptr %ref.tmp, align 8
IC: Replacing   %1 = load %struct.ethernet_t, ptr %ref.tmp, align 8
    with   %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
IC: Mod =   %1 = load %struct.ethernet_t, ptr %ref.tmp, align 8
    New =   %1 = load %struct.ethernet_t, ptr %ref.tmp, align 8
IC: ERASE   %1 = load %struct.ethernet_t, ptr %ref.tmp, align 8
ADD DEFERRED:   %ref.tmp = alloca %struct.ethernet_t, align 8
ADD:   %ref.tmp = alloca %struct.ethernet_t, align 8
IC: Visiting:   %ref.tmp = alloca %struct.ethernet_t, align 8
IC: Visiting:   tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
IC: Visiting:   %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
IC: Visiting:   %2 = load i16, ptr %1, align 2
IC: Visiting:   %cmp = icmp eq i16 %2, 2048
IC: Visiting:   br i1 %cmp, label %if.then, label %if.end38
IC: Visiting:   %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
IC: Visiting:   store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
IC: Visiting:   %4 = load %struct.ipv4_t, ptr %ref.tmp1, align 8
IC: Replacing   %4 = load %struct.ipv4_t, ptr %ref.tmp1, align 8
    with   %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
IC: Mod =   %4 = load %struct.ipv4_t, ptr %ref.tmp1, align 8
    New =   %4 = load %struct.ipv4_t, ptr %ref.tmp1, align 8
IC: ERASE   %4 = load %struct.ipv4_t, ptr %ref.tmp1, align 8
ADD DEFERRED:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
ADD:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
IC: Visiting:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
IC: Visiting:   tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
IC: Visiting:   %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
IC: Visiting:   %5 = load i8, ptr %4, align 1
IC: Visiting:   switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]
IC: Visiting:   %12 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
IC: Visiting:   tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %12, i32 8)
IC: Visiting:   br label %if.end38
IC: Visiting:   %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
IC: Visiting:   store %struct.tcp_t %6, ptr %ref.tmp6, align 8
IC: Visiting:   %7 = load %struct.tcp_t, ptr %ref.tmp6, align 8
IC: Replacing   %7 = load %struct.tcp_t, ptr %ref.tmp6, align 8
    with   %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
IC: Mod =   %7 = load %struct.tcp_t, ptr %ref.tmp6, align 8
    New =   %7 = load %struct.tcp_t, ptr %ref.tmp6, align 8
IC: ERASE   %7 = load %struct.tcp_t, ptr %ref.tmp6, align 8
ADD DEFERRED:   %ref.tmp6 = alloca %struct.tcp_t, align 8
ADD:   %ref.tmp6 = alloca %struct.tcp_t, align 8
IC: Visiting:   %ref.tmp6 = alloca %struct.tcp_t, align 8
IC: Visiting:   tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
IC: Visiting:   %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
IC: Visiting:   %8 = load i4, ptr %7, align 1
IC: Visiting:   %cmp9 = icmp sgt i4 %8, 0
IC: Visiting:   %cmp1352 = icmp ugt i4 %8, 5
IC: Visiting:   %or.cond = and i1 %cmp9, %cmp1352
ADD DEFERRED:   %9 = icmp sge i4 %8, 6
IC: Replacing   %or.cond = and i1 %cmp9, %cmp1352
    with   %9 = icmp sge i4 %8, 6
IC: Mod =   %or.cond = and i1 %cmp9, %cmp1352
    New =   %9 = and i1 %cmp9, %cmp1352
IC: ERASE   %9 = and i1 %cmp9, %cmp1352
ADD DEFERRED:   %cmp9 = icmp sgt i4 %8, 0
ADD DEFERRED:   %cmp1352 = icmp ugt i4 %8, 5
IC: ERASE   %cmp1352 = icmp ugt i4 %8, 5
ADD DEFERRED:   %8 = load i4, ptr %7, align 1
ADD:   %8 = load i4, ptr %7, align 1
IC: ERASE   %cmp9 = icmp sgt i4 %8, 0
ADD DEFERRED:   %8 = load i4, ptr %7, align 1
ADD:   %or.cond = icmp sge i4 %8, 6
IC: Visiting:   %or.cond = icmp sge i4 %8, 6
IC: Old =   %or.cond = icmp sge i4 %8, 6
    New =   <badref> = icmp sgt i4 %8, 5
ADD:   %or.cond = icmp sgt i4 %8, 5
IC: ERASE   %9 = icmp sge i4 %8, 6
ADD DEFERRED:   %8 = load i4, ptr %7, align 1
IC: Visiting:   %or.cond = icmp sgt i4 %8, 5
IC: Visiting:   %8 = load i4, ptr %7, align 1
IC: Visiting:   br i1 %or.cond, label %while.body.preheader, label %if.end38
IC: Visiting:   %conv12 = zext nneg i4 %8 to i32
IC: Visiting:   %sub = shl nuw nsw i32 %conv12, 2
IC: Visiting:   %mul = add nsw i32 %sub, -20
IC: Visiting:   br label %while.body
IC: Visiting:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
IC: Visiting:   %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
IC: Visiting:   switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]
IC: Visiting:   %dec25 = add nsw i32 %hdr_byte_left.053, -1
IC: Visiting:   tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
IC: Visiting:   br label %cleanup
IC: Visiting:   %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
IC: Replacing   %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
    with   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
IC: Mod =   %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
    New =   %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
IC: ERASE   %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
ADD DEFERRED:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
ADD:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
IC: Visiting:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
IC: Visiting:   tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
IC: Visiting:   %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
IC: Visiting:   br i1 %cmp1854, label %while.body19.preheader, label %if.end38
IC: Visiting:   %dec = add nsw i32 %hdr_byte_left.053, -1
IC: Visiting:   br label %while.body19
IC: Visiting:   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
IC: Visiting:   %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
IC: Visiting:   store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !7
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
IC: Visiting:   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !7
IC: Visiting:   tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
IC: Visiting:   %sub20 = add nsw i32 %hdr_byte_left.155, -16
IC: Visiting:   %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
IC: Visiting:   br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !11
IC: Visiting:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
IC: Visiting:   %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
IC: Visiting:   br i1 %cmp13, label %while.body, label %if.end38
IC: Visiting:   tail call void @llvm.primate.input.done()
IC: Visiting:   ret void


[IC] Iteration limit #1 on _Z12primate_mainv reached; stopping without verifying fixpoint
; *** IR Dump After InstCombinePass on _Z12primate_mainv ***
; Function Attrs: mustprogress
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 2
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 1
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
Adding nounwind attr to fn _Z12primate_mainv
; *** IR Dump After PostOrderFunctionAttrsPass on (_Z12primate_mainv) ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 2
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 1
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !7
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !7
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !11

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
Running function passes across an SCC: (_Z12primate_mainv)
; *** IR Dump After RequireAnalysisPass<llvm::ShouldNotRunFunctionPassesAnalysis, llvm::Function, llvm::AnalysisManager<llvm::Function>> on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 2
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 1
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After CoroSplitPass on (_Z12primate_mainv) ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 2
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 1
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !7
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !7
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !11

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After InvalidateAnalysisPass<llvm::ShouldNotRunFunctionPassesAnalysis> on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After InvalidateAnalysisPass<llvm::ShouldNotRunFunctionPassesAnalysis> on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After InvalidateAnalysisPass<llvm::ShouldNotRunFunctionPassesAnalysis> on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 2
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 1
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
DeadArgumentEliminationPass - Deleting dead varargs
DeadArgumentEliminationPass - Determining liveness
DeadArgumentEliminationPass - Intrinsically live fn: _ZN7PRIMATE10input_doneEv
DeadArgumentEliminationPass - Intrinsically live fn: llvm.primate.input.done
DeadArgumentEliminationPass - Intrinsically live fn: _ZN7PRIMATE11output_doneEv
DeadArgumentEliminationPass - Intrinsically live fn: llvm.primate.output.done
DeadArgumentEliminationPass - Intrinsically live fn: _Z12primate_mainv
DeadArgumentEliminationPass - Intrinsically live fn: llvm.lifetime.start.p0
DeadArgumentEliminationPass - Intrinsically live fn: llvm.memcpy.p0.p0.i32
DeadArgumentEliminationPass - Intrinsically live fn: llvm.lifetime.end.p0
DeadArgumentEliminationPass - Intrinsically live fn: llvm.primate.input.p0.i32
DeadArgumentEliminationPass - Intrinsically live fn: llvm.primate.output.p0.i32
DeadArgumentEliminationPass - Intrinsically live fn: llvm.experimental.noalias.scope.decl
DeadArgumentEliminationPass - Intrinsically live fn: llvm.memcpy.p0.p0.i64
DeadArgumentEliminationPass - Intrinsically live fn: llvm.primate.input.s_struct.ethernet_ts.i32
DeadArgumentEliminationPass - Intrinsically live fn: llvm.primate.input.s_struct.ipv4_ts.i32
DeadArgumentEliminationPass - Intrinsically live fn: llvm.primate.input.s_struct.tcp_ts.i32
DeadArgumentEliminationPass - Intrinsically live fn: llvm.primate.input.i8.i32
DeadArgumentEliminationPass - Intrinsically live fn: llvm.primate.input.i128.i32
DeadArgumentEliminationPass - Intrinsically live fn: llvm.primate.input.s_struct.udp_ts.i32
DeadArgumentEliminationPass - Intrinsically live fn: llvm.primate.output.s_struct.ethernet_ts.i32
DeadArgumentEliminationPass - Intrinsically live fn: llvm.primate.output.s_struct.ipv4_ts.i32
DeadArgumentEliminationPass - Intrinsically live fn: llvm.primate.output.s_struct.tcp_ts.i32
DeadArgumentEliminationPass - Intrinsically live fn: llvm.primate.output.i8.i32
DeadArgumentEliminationPass - Intrinsically live fn: llvm.primate.output.i128.i32
DeadArgumentEliminationPass - Intrinsically live fn: llvm.primate.output.s_struct.udp_ts.i32
; *** IR Dump After DeadArgumentEliminationPass on [module] ***
; ModuleID = 'tcp_parse.cpp'
source_filename = "tcp_parse.cpp"
target datalayout = "e-G1-m:e-p:32:32-i64:64-n32-S128"
target triple = "primate32-unknown-linux-gnu"

%struct.ethernet_t = type { i48, i48, i16 }
%struct.ipv4_t = type { i72, i8, i80 }
%struct.tcp_t = type { i96, i4, i60 }
%struct.udp_t = type { i64 }

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.done() #1

; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 2
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 1
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i32(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i32, i1 immarg) #4

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: nounwind
declare !primate !7 ptr @llvm.primate.input.p0.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.p0.i32(ptr, i32) #1

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite)
declare void @llvm.experimental.noalias.scope.decl(metadata) #5

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #6

; Function Attrs: nounwind
declare !primate !7 %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 i8 @llvm.primate.input.i8.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 i128 @llvm.primate.input.i128.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i8.i32(i8, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i128.i32(i128, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t, i32) #1

attributes #0 = { alwaysinline mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #1 = { nounwind }
attributes #2 = { mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #3 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #5 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite) }
attributes #6 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5}
!llvm.ident = !{!6}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"ilp32"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{i32 8, !"SmallDataLimit", i32 8}
!6 = !{!"clang version 18.1.8 (git@github.com:FAST-Research-Group/primate-arch-gen.git e8582d4315ec2267abfc97212fa19f342d0812e8)"}
!7 = !{!"blue", !"IO", i64 1, i64 1}
!8 = !{!9, !9, i64 0}
!9 = !{!"_BitInt(128)", !10, i64 0}
!10 = !{!"omnipotent char", !11, i64 0}
!11 = !{!"Simple C++ TBAA"}
!12 = distinct !{!12, !13}
!13 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After CoroCleanupPass on [module] ***
; ModuleID = 'tcp_parse.cpp'
source_filename = "tcp_parse.cpp"
target datalayout = "e-G1-m:e-p:32:32-i64:64-n32-S128"
target triple = "primate32-unknown-linux-gnu"

%struct.ethernet_t = type { i48, i48, i16 }
%struct.ipv4_t = type { i72, i8, i80 }
%struct.tcp_t = type { i96, i4, i60 }
%struct.udp_t = type { i64 }

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.done() #1

; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 2
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 1
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i32(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i32, i1 immarg) #4

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: nounwind
declare !primate !7 ptr @llvm.primate.input.p0.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.p0.i32(ptr, i32) #1

; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite)
declare void @llvm.experimental.noalias.scope.decl(metadata) #5

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #6

; Function Attrs: nounwind
declare !primate !7 %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 i8 @llvm.primate.input.i8.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 i128 @llvm.primate.input.i128.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i8.i32(i8, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i128.i32(i128, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t, i32) #1

attributes #0 = { alwaysinline mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #1 = { nounwind }
attributes #2 = { mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #3 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #5 = { nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite) }
attributes #6 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5}
!llvm.ident = !{!6}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"ilp32"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{i32 8, !"SmallDataLimit", i32 8}
!6 = !{!"clang version 18.1.8 (git@github.com:FAST-Research-Group/primate-arch-gen.git e8582d4315ec2267abfc97212fa19f342d0812e8)"}
!7 = !{!"blue", !"IO", i64 1, i64 1}
!8 = !{!9, !9, i64 0}
!9 = !{!"_BitInt(128)", !10, i64 0}
!10 = !{!"omnipotent char", !11, i64 0}
!11 = !{!"Simple C++ TBAA"}
!12 = distinct !{!12, !13}
!13 = !{!"llvm.loop.mustprogress"}
GLOBAL DEAD: ; Function Attrs: mustprogress nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i32(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i32, i1 immarg) #4

GLOBAL DEAD: ; Function Attrs: nounwind
declare !primate !7 ptr @llvm.primate.input.p0.i32(i32) #1

GLOBAL DEAD: ; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.p0.i32(ptr, i32) #1

GLOBAL DEAD: ; Function Attrs: nocallback nofree nosync nounwind willreturn memory(inaccessiblemem: readwrite)
declare void @llvm.experimental.noalias.scope.decl(metadata) #4

; *** IR Dump After GlobalOptPass on [module] ***
; ModuleID = 'tcp_parse.cpp'
source_filename = "tcp_parse.cpp"
target datalayout = "e-G1-m:e-p:32:32-i64:64-n32-S128"
target triple = "primate32-unknown-linux-gnu"

%struct.ethernet_t = type { i48, i48, i16 }
%struct.ipv4_t = type { i72, i8, i80 }
%struct.tcp_t = type { i96, i4, i60 }
%struct.udp_t = type { i64 }

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.done() #1

; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 2
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 1
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #4

; Function Attrs: nounwind
declare !primate !7 %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 i8 @llvm.primate.input.i8.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 i128 @llvm.primate.input.i128.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i8.i32(i8, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i128.i32(i128, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t, i32) #1

attributes #0 = { alwaysinline mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #1 = { nounwind }
attributes #2 = { mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #3 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5}
!llvm.ident = !{!6}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"ilp32"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{i32 8, !"SmallDataLimit", i32 8}
!6 = !{!"clang version 18.1.8 (git@github.com:FAST-Research-Group/primate-arch-gen.git e8582d4315ec2267abfc97212fa19f342d0812e8)"}
!7 = !{!"blue", !"IO", i64 1, i64 1}
!8 = !{!9, !9, i64 0}
!9 = !{!"_BitInt(128)", !10, i64 0}
!10 = !{!"omnipotent char", !11, i64 0}
!11 = !{!"Simple C++ TBAA"}
!12 = distinct !{!12, !13}
!13 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After GlobalDCEPass on [module] ***
; ModuleID = 'tcp_parse.cpp'
source_filename = "tcp_parse.cpp"
target datalayout = "e-G1-m:e-p:32:32-i64:64-n32-S128"
target triple = "primate32-unknown-linux-gnu"

%struct.ethernet_t = type { i48, i48, i16 }
%struct.ipv4_t = type { i72, i8, i80 }
%struct.tcp_t = type { i96, i4, i60 }
%struct.udp_t = type { i64 }

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.done() #1

; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 2
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 1
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #4

; Function Attrs: nounwind
declare !primate !7 %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 i8 @llvm.primate.input.i8.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 i128 @llvm.primate.input.i128.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i8.i32(i8, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i128.i32(i128, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t, i32) #1

attributes #0 = { alwaysinline mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #1 = { nounwind }
attributes #2 = { mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #3 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5}
!llvm.ident = !{!6}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"ilp32"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{i32 8, !"SmallDataLimit", i32 8}
!6 = !{!"clang version 18.1.8 (git@github.com:FAST-Research-Group/primate-arch-gen.git e8582d4315ec2267abfc97212fa19f342d0812e8)"}
!7 = !{!"blue", !"IO", i64 1, i64 1}
!8 = !{!9, !9, i64 0}
!9 = !{!"_BitInt(128)", !10, i64 0}
!10 = !{!"omnipotent char", !11, i64 0}
!11 = !{!"Simple C++ TBAA"}
!12 = distinct !{!12, !13}
!13 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After EliminateAvailableExternallyPass on [module] ***
; ModuleID = 'tcp_parse.cpp'
source_filename = "tcp_parse.cpp"
target datalayout = "e-G1-m:e-p:32:32-i64:64-n32-S128"
target triple = "primate32-unknown-linux-gnu"

%struct.ethernet_t = type { i48, i48, i16 }
%struct.ipv4_t = type { i72, i8, i80 }
%struct.tcp_t = type { i96, i4, i60 }
%struct.udp_t = type { i64 }

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.done() #1

; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 2
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 1
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #4

; Function Attrs: nounwind
declare !primate !7 %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 i8 @llvm.primate.input.i8.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 i128 @llvm.primate.input.i128.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i8.i32(i8, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i128.i32(i128, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t, i32) #1

attributes #0 = { alwaysinline mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #1 = { nounwind }
attributes #2 = { mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #3 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5}
!llvm.ident = !{!6}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"ilp32"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{i32 8, !"SmallDataLimit", i32 8}
!6 = !{!"clang version 18.1.8 (git@github.com:FAST-Research-Group/primate-arch-gen.git e8582d4315ec2267abfc97212fa19f342d0812e8)"}
!7 = !{!"blue", !"IO", i64 1, i64 1}
!8 = !{!9, !9, i64 0}
!9 = !{!"_BitInt(128)", !10, i64 0}
!10 = !{!"omnipotent char", !11, i64 0}
!11 = !{!"Simple C++ TBAA"}
!12 = distinct !{!12, !13}
!13 = !{!"llvm.loop.mustprogress"}
Building CG for module: tcp_parse.cpp
  Adding '_ZN7PRIMATE10input_doneEv' to entry set of the graph.
    Added callable function: _ZN7PRIMATE10input_doneEv
  Adding '_ZN7PRIMATE11output_doneEv' to entry set of the graph.
    Added callable function: _ZN7PRIMATE11output_doneEv
  Adding '_Z12primate_mainv' to entry set of the graph.
    Added callable function: _Z12primate_mainv
  Adding functions referenced by global initializers to the entry set.
  Adding functions called by '_ZN7PRIMATE10input_doneEv' to the graph.
  Adding functions called by '_ZN7PRIMATE11output_doneEv' to the graph.
  Adding functions called by '_Z12primate_mainv' to the graph.
; *** IR Dump After ReversePostOrderFunctionAttrsPass on [module] ***
; ModuleID = 'tcp_parse.cpp'
source_filename = "tcp_parse.cpp"
target datalayout = "e-G1-m:e-p:32:32-i64:64-n32-S128"
target triple = "primate32-unknown-linux-gnu"

%struct.ethernet_t = type { i48, i48, i16 }
%struct.ipv4_t = type { i72, i8, i80 }
%struct.tcp_t = type { i96, i4, i60 }
%struct.udp_t = type { i64 }

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.done() #1

; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 2
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 1
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #4

; Function Attrs: nounwind
declare !primate !7 %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 i8 @llvm.primate.input.i8.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 i128 @llvm.primate.input.i128.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i8.i32(i8, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i128.i32(i128, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t, i32) #1

attributes #0 = { alwaysinline mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #1 = { nounwind }
attributes #2 = { mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #3 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5}
!llvm.ident = !{!6}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"ilp32"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{i32 8, !"SmallDataLimit", i32 8}
!6 = !{!"clang version 18.1.8 (git@github.com:FAST-Research-Group/primate-arch-gen.git e8582d4315ec2267abfc97212fa19f342d0812e8)"}
!7 = !{!"blue", !"IO", i64 1, i64 1}
!8 = !{!9, !9, i64 0}
!9 = !{!"_BitInt(128)", !10, i64 0}
!10 = !{!"omnipotent char", !11, i64 0}
!11 = !{!"Simple C++ TBAA"}
!12 = distinct !{!12, !13}
!13 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After RecomputeGlobalsAAPass on [module] ***
; ModuleID = 'tcp_parse.cpp'
source_filename = "tcp_parse.cpp"
target datalayout = "e-G1-m:e-p:32:32-i64:64-n32-S128"
target triple = "primate32-unknown-linux-gnu"

%struct.ethernet_t = type { i48, i48, i16 }
%struct.ipv4_t = type { i72, i8, i80 }
%struct.tcp_t = type { i96, i4, i60 }
%struct.udp_t = type { i64 }

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.done() #1

; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 2
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 1
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite)
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #3

; Function Attrs: nocallback nofree nounwind willreturn memory(argmem: readwrite)
declare void @llvm.memcpy.p0.p0.i64(ptr noalias nocapture writeonly, ptr noalias nocapture readonly, i64, i1 immarg) #4

; Function Attrs: nounwind
declare !primate !7 %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 i8 @llvm.primate.input.i8.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 i128 @llvm.primate.input.i128.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i8.i32(i8, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i128.i32(i128, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t, i32) #1

attributes #0 = { alwaysinline mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #1 = { nounwind }
attributes #2 = { mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #3 = { mustprogress nocallback nofree nosync nounwind willreturn memory(argmem: readwrite) }
attributes #4 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5}
!llvm.ident = !{!6}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"ilp32"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{i32 8, !"SmallDataLimit", i32 8}
!6 = !{!"clang version 18.1.8 (git@github.com:FAST-Research-Group/primate-arch-gen.git e8582d4315ec2267abfc97212fa19f342d0812e8)"}
!7 = !{!"blue", !"IO", i64 1, i64 1}
!8 = !{!9, !9, i64 0}
!9 = !{!"_BitInt(128)", !10, i64 0}
!10 = !{!"omnipotent char", !11, i64 0}
!11 = !{!"Simple C++ TBAA"}
!12 = distinct !{!12, !13}
!13 = !{!"llvm.loop.mustprogress"}
F2I: Looking at function _ZN7PRIMATE10input_doneEv
; *** IR Dump After Float2IntPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LowerConstantIntrinsicsPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After ControlHeightReductionPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LoopSimplifyPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LCSSAPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LoopDistributePass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After InjectTLIMappings on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LoopVectorizePass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After InferAlignmentPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LoopLoadEliminationPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE10input_doneEv
ADD:   ret void
ADD:   tail call void @llvm.primate.input.done()
IC: Visiting:   tail call void @llvm.primate.input.done()
IC: Visiting:   ret void
; *** IR Dump After InstCombinePass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
SLP: Analyzing blocks in _ZN7PRIMATE10input_doneEv.
; *** IR Dump After SLPVectorizerPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After VectorCombinePass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE10input_doneEv
ADD:   ret void
ADD:   tail call void @llvm.primate.input.done()
IC: Visiting:   tail call void @llvm.primate.input.done()
IC: Visiting:   ret void
; *** IR Dump After InstCombinePass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LoopUnrollPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After WarnMissedTransformationsPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
SROA function: _ZN7PRIMATE10input_doneEv
; *** IR Dump After SROAPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After InferAlignmentPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE10input_doneEv
ADD:   ret void
ADD:   tail call void @llvm.primate.input.done()
IC: Visiting:   tail call void @llvm.primate.input.done()
IC: Visiting:   ret void
; *** IR Dump After InstCombinePass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LoopSimplifyPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LCSSAPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After AlignmentFromAssumptionsPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LoopSinkPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After InstSimplifyPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After DivRemPairsPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After TailCallElimPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
F2I: Looking at function _ZN7PRIMATE11output_doneEv
; *** IR Dump After Float2IntPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After LowerConstantIntrinsicsPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After ControlHeightReductionPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After LoopSimplifyPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After LCSSAPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After LoopDistributePass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After InjectTLIMappings on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After LoopVectorizePass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After InferAlignmentPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After LoopLoadEliminationPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE11output_doneEv
ADD:   ret void
ADD:   tail call void @llvm.primate.output.done()
IC: Visiting:   tail call void @llvm.primate.output.done()
IC: Visiting:   ret void
; *** IR Dump After InstCombinePass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
SLP: Analyzing blocks in _ZN7PRIMATE11output_doneEv.
; *** IR Dump After SLPVectorizerPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After VectorCombinePass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE11output_doneEv
ADD:   ret void
ADD:   tail call void @llvm.primate.output.done()
IC: Visiting:   tail call void @llvm.primate.output.done()
IC: Visiting:   ret void
; *** IR Dump After InstCombinePass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After LoopUnrollPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After WarnMissedTransformationsPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
SROA function: _ZN7PRIMATE11output_doneEv
; *** IR Dump After SROAPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After InferAlignmentPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}


INSTCOMBINE ITERATION #1 on _ZN7PRIMATE11output_doneEv
ADD:   ret void
ADD:   tail call void @llvm.primate.output.done()
IC: Visiting:   tail call void @llvm.primate.output.done()
IC: Visiting:   ret void
; *** IR Dump After InstCombinePass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After LoopSimplifyPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After LCSSAPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After AlignmentFromAssumptionsPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After LoopSinkPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After InstSimplifyPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After DivRemPairsPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After TailCallElimPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After SimplifyCFGPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
F2I: Looking at function _Z12primate_mainv
; *** IR Dump After Float2IntPass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 2
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 1
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LowerConstantIntrinsicsPass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 2
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 1
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After ControlHeightReductionPass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 2
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 1
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
LoopSimplify: Creating dedicated exit block if.end38.loopexit
LoopSimplify: Creating dedicated exit block if.end38.loopexit61
; *** IR Dump After LoopSimplifyPass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 2
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 1
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit61

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit61:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit61, %if.end38.loopexit, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LCSSAPass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 2
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 1
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit61

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit61:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit61, %if.end38.loopexit, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LoopRotatePass on while.body ***

; Preheader:
while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

; Loop:
while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit61

; Exit blocks
if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

if.end38.loopexit61:                              ; preds = %cleanup
  br label %if.end38
Analyzing Loop for deletion: Loop at depth 1 containing: %while.body<header><exiting>,%if.then23,%cleanup<latch><exiting>
Deletion requires at most one exit block.
; *** IR Dump After LoopDeletionPass on while.body ***

; Preheader:
while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

; Loop:
while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit61

; Exit blocks
if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

if.end38.loopexit61:                              ; preds = %cleanup
  br label %if.end38
; *** IR Dump After LoopRotatePass on while.body19 ***

; Preheader:
while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  br label %while.body19

; Loop:
while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !7
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !7
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !11

; Exit blocks
if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38
Analyzing Loop for deletion: Loop at depth 1 containing: %while.body19<header><latch><exiting>
Loop is not invariant, cannot delete.
; *** IR Dump After LoopDeletionPass on while.body19 ***

; Preheader:
while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  br label %while.body19

; Loop:
while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !7
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !7
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !11

; Exit blocks
if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38
; *** IR Dump After LoopDistributePass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 2
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 1
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit61

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit61:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit61, %if.end38.loopexit, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After InjectTLIMappings on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 2
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 1
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit61

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit61:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit61, %if.end38.loopexit, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}

LV: Checking a loop in '_Z12primate_mainv' from tcp_parse.cpp
LV: Loop hints: force=? width=0 interleave=0
LV: Found a loop: while.body
LV: Not vectorizing: Loop contains a switch statement   switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]
LV: Interleaving disabled by the pass manager
LV: Can't if-convert the loop.
LV: Not vectorizing: Cannot prove legality.

LV: Checking a loop in '_Z12primate_mainv' from tcp_parse.cpp
LV: Loop hints: force=? width=0 interleave=0
LV: Found a loop: while.body19
LV: Found an induction variable.
LV: Not vectorizing: Found a non-intrinsic callsite   %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
LV: Interleaving disabled by the pass manager
LV: Can't vectorize the instructions or CFG
LV: Not vectorizing: Cannot prove legality.
; *** IR Dump After LoopVectorizePass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 2
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 1
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 1
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit61

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit61:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit61, %if.end38.loopexit, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After InferAlignmentPass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 8
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 8
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 8
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit61

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit61:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit61, %if.end38.loopexit, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
LAA: Found a loop in _Z12primate_mainv: while.body19

In "_Z12primate_mainv" checking Loop at depth 1 containing: %while.body19<header><latch><exiting>

; *** IR Dump After LoopLoadEliminationPass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 8
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 8
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 8
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit61

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit61:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit61, %if.end38.loopexit, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}


INSTCOMBINE ITERATION #1 on _Z12primate_mainv
ADD:   ret void
ADD:   tail call void @llvm.primate.input.done()
ADD:   br label %if.end38
ADD:   br i1 %cmp13, label %while.body, label %if.end38.loopexit61
ADD:   %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
ADD:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
ADD:   br label %if.end38
ADD:   br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !11
ADD:   %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
ADD:   %sub20 = add nsw i32 %hdr_byte_left.155, -16
ADD:   call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
ADD:   tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
ADD:   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !7
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
ADD:   call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
ADD:   store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !7
ADD:   %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
ADD:   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
ADD:   br label %while.body19
ADD:   %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
ADD:   br i1 %cmp1854, label %while.body19.preheader, label %if.end38
ADD:   %cmp1854 = icmp ugt i32 %hdr_byte_left.053.lcssa, 1
ADD:   tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
ADD:   %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
ADD:   br label %cleanup
ADD:   tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
ADD:   %dec25 = add nsw i32 %hdr_byte_left.053, -1
ADD:   switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]
ADD:   %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
ADD:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
ADD:   br label %while.body
ADD:   %mul = add nsw i32 %sub, -20
ADD:   %sub = shl nuw nsw i32 %conv12, 2
ADD:   %conv12 = zext nneg i4 %8 to i32
ADD:   br i1 %or.cond, label %while.body.preheader, label %if.end38
ADD:   %or.cond = icmp sgt i4 %8, 5
ADD:   %8 = load i4, ptr %7, align 8
ADD:   %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
ADD:   tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
ADD:   store %struct.tcp_t %6, ptr %ref.tmp6, align 8
ADD:   %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
ADD:   br label %if.end38
ADD:   tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
ADD:   %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
ADD:   switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]
ADD:   %5 = load i8, ptr %4, align 8
ADD:   %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
ADD:   tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
ADD:   store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
ADD:   %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
ADD:   br i1 %cmp, label %if.then, label %if.end38
ADD:   %cmp = icmp eq i16 %2, 2048
ADD:   %2 = load i16, ptr %1, align 8
ADD:   %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
ADD:   tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
ADD:   store %struct.ethernet_t %0, ptr %ref.tmp, align 8
ADD:   %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
ADD:   %indirect-arg-temp = alloca i128, align 8
ADD:   %ref.tmp6 = alloca %struct.tcp_t, align 8
ADD:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
ADD:   %ref.tmp = alloca %struct.ethernet_t, align 8
ADD:   %indirect-arg-temp43 = alloca i128, align 8
IC: Visiting:   %indirect-arg-temp43 = alloca i128, align 8
IC: Visiting:   %ref.tmp = alloca %struct.ethernet_t, align 8
IC: Visiting:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
IC: Visiting:   %ref.tmp6 = alloca %struct.tcp_t, align 8
IC: Visiting:   %indirect-arg-temp = alloca i128, align 8
IC: Visiting:   %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
IC: Visiting:   store %struct.ethernet_t %0, ptr %ref.tmp, align 8
IC: Visiting:   tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
IC: Visiting:   %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
IC: Visiting:   %2 = load i16, ptr %1, align 8
IC: Visiting:   %cmp = icmp eq i16 %2, 2048
IC: Visiting:   br i1 %cmp, label %if.then, label %if.end38
IC: Visiting:   %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
IC: Visiting:   store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
IC: Visiting:   tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
IC: Visiting:   %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
IC: Visiting:   %5 = load i8, ptr %4, align 8
IC: Visiting:   switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]
IC: Visiting:   %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
IC: Visiting:   tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
IC: Visiting:   br label %if.end38
IC: Visiting:   %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
IC: Visiting:   store %struct.tcp_t %6, ptr %ref.tmp6, align 8
IC: Visiting:   tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
IC: Visiting:   %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
IC: Visiting:   %8 = load i4, ptr %7, align 8
IC: Visiting:   %or.cond = icmp sgt i4 %8, 5
IC: Visiting:   br i1 %or.cond, label %while.body.preheader, label %if.end38
IC: Visiting:   %conv12 = zext nneg i4 %8 to i32
IC: Visiting:   %sub = shl nuw nsw i32 %conv12, 2
IC: Visiting:   %mul = add nsw i32 %sub, -20
IC: Visiting:   br label %while.body
IC: Visiting:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
IC: Visiting:   %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
IC: Visiting:   switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]
IC: Visiting:   %dec25 = add nsw i32 %hdr_byte_left.053, -1
IC: Visiting:   tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
IC: Visiting:   br label %cleanup
IC: Visiting:   %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
IC: Replacing   %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
    with   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
IC: Mod =   %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
    New =   %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
IC: ERASE   %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
ADD DEFERRED:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
ADD:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
IC: Visiting:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
IC: Visiting:   tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
IC: Visiting:   %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
IC: Visiting:   br i1 %cmp1854, label %while.body19.preheader, label %if.end38
IC: Visiting:   %dec = add nsw i32 %hdr_byte_left.053, -1
IC: Visiting:   br label %while.body19
IC: Visiting:   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
IC: Visiting:   %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
IC: Visiting:   store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !7
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
IC: Visiting:   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !7
IC: Visiting:   tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
IC: Visiting:   %sub20 = add nsw i32 %hdr_byte_left.155, -16
IC: Visiting:   %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
IC: Visiting:   br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !11
IC: Visiting:   br label %if.end38
IC: Visiting:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
IC: Visiting:   %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
IC: Visiting:   br i1 %cmp13, label %while.body, label %if.end38.loopexit61
IC: Visiting:   br label %if.end38
IC: Visiting:   tail call void @llvm.primate.input.done()
IC: Visiting:   ret void


[IC] Iteration limit #1 on _Z12primate_mainv reached; stopping without verifying fixpoint
; *** IR Dump After InstCombinePass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 8
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 8
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 8
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit61

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit61:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit61, %if.end38.loopexit, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
Looking to fold if.end38.loopexit into if.end38
Killing Trivial BB: 

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38
Looking to fold if.end38.loopexit61 into if.end38
Killing Trivial BB: 

if.end38.loopexit61:                              ; preds = %cleanup
  br label %if.end38
; *** IR Dump After SimplifyCFGPass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 8
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 8
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 8
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
SLP: Analyzing blocks in _Z12primate_mainv.
SLP: Found stores for 1 underlying objects.
; *** IR Dump After SLPVectorizerPass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 8
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 8
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 8
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After VectorCombinePass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 8
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 8
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 8
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}


INSTCOMBINE ITERATION #1 on _Z12primate_mainv
ADD:   ret void
ADD:   tail call void @llvm.primate.input.done()
ADD:   br i1 %cmp13, label %while.body, label %if.end38
ADD:   %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
ADD:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
ADD:   br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !11
ADD:   %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
ADD:   %sub20 = add nsw i32 %hdr_byte_left.155, -16
ADD:   call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
ADD:   tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
ADD:   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !7
ADD:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
ADD:   call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
ADD:   store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !7
ADD:   %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
ADD:   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
ADD:   br label %while.body19
ADD:   %dec = add nsw i32 %hdr_byte_left.053, -1
ADD:   br i1 %cmp1854, label %while.body19.preheader, label %if.end38
ADD:   %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
ADD:   tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
ADD:   br label %cleanup
ADD:   tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
ADD:   %dec25 = add nsw i32 %hdr_byte_left.053, -1
ADD:   switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]
ADD:   %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
ADD:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
ADD:   br label %while.body
ADD:   %mul = add nsw i32 %sub, -20
ADD:   %sub = shl nuw nsw i32 %conv12, 2
ADD:   %conv12 = zext nneg i4 %8 to i32
ADD:   br i1 %or.cond, label %while.body.preheader, label %if.end38
ADD:   %or.cond = icmp sgt i4 %8, 5
ADD:   %8 = load i4, ptr %7, align 8
ADD:   %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
ADD:   tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
ADD:   store %struct.tcp_t %6, ptr %ref.tmp6, align 8
ADD:   %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
ADD:   br label %if.end38
ADD:   tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
ADD:   %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
ADD:   switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]
ADD:   %5 = load i8, ptr %4, align 8
ADD:   %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
ADD:   tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
ADD:   store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
ADD:   %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
ADD:   br i1 %cmp, label %if.then, label %if.end38
ADD:   %cmp = icmp eq i16 %2, 2048
ADD:   %2 = load i16, ptr %1, align 8
ADD:   %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
ADD:   tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
ADD:   store %struct.ethernet_t %0, ptr %ref.tmp, align 8
ADD:   %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
ADD:   %indirect-arg-temp = alloca i128, align 8
ADD:   %ref.tmp6 = alloca %struct.tcp_t, align 8
ADD:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
ADD:   %ref.tmp = alloca %struct.ethernet_t, align 8
ADD:   %indirect-arg-temp43 = alloca i128, align 8
IC: Visiting:   %indirect-arg-temp43 = alloca i128, align 8
IC: Visiting:   %ref.tmp = alloca %struct.ethernet_t, align 8
IC: Visiting:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
IC: Visiting:   %ref.tmp6 = alloca %struct.tcp_t, align 8
IC: Visiting:   %indirect-arg-temp = alloca i128, align 8
IC: Visiting:   %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
IC: Visiting:   store %struct.ethernet_t %0, ptr %ref.tmp, align 8
IC: Visiting:   tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
IC: Visiting:   %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
IC: Visiting:   %2 = load i16, ptr %1, align 8
IC: Visiting:   %cmp = icmp eq i16 %2, 2048
IC: Visiting:   br i1 %cmp, label %if.then, label %if.end38
IC: Visiting:   %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
IC: Visiting:   store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
IC: Visiting:   tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
IC: Visiting:   %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
IC: Visiting:   %5 = load i8, ptr %4, align 8
IC: Visiting:   switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]
IC: Visiting:   %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
IC: Visiting:   tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
IC: Visiting:   br label %if.end38
IC: Visiting:   %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
IC: Visiting:   store %struct.tcp_t %6, ptr %ref.tmp6, align 8
IC: Visiting:   tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
IC: Visiting:   %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
IC: Visiting:   %8 = load i4, ptr %7, align 8
IC: Visiting:   %or.cond = icmp sgt i4 %8, 5
IC: Visiting:   br i1 %or.cond, label %while.body.preheader, label %if.end38
IC: Visiting:   %conv12 = zext nneg i4 %8 to i32
IC: Visiting:   %sub = shl nuw nsw i32 %conv12, 2
IC: Visiting:   %mul = add nsw i32 %sub, -20
IC: Visiting:   br label %while.body
IC: Visiting:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
IC: Visiting:   %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
IC: Visiting:   switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]
IC: Visiting:   %dec25 = add nsw i32 %hdr_byte_left.053, -1
IC: Visiting:   tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
IC: Visiting:   br label %cleanup
IC: Visiting:   tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
IC: Visiting:   %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
IC: Visiting:   br i1 %cmp1854, label %while.body19.preheader, label %if.end38
IC: Visiting:   %dec = add nsw i32 %hdr_byte_left.053, -1
IC: Visiting:   br label %while.body19
IC: Visiting:   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
IC: Visiting:   %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
IC: Visiting:   store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !7
IC: Visiting:   call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
IC: Visiting:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
IC: Visiting:   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !7
IC: Visiting:   tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
IC: Visiting:   call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
IC: Visiting:   %sub20 = add nsw i32 %hdr_byte_left.155, -16
IC: Visiting:   %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
IC: Visiting:   br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !11
IC: Visiting:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
IC: Visiting:   %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
IC: Visiting:   br i1 %cmp13, label %while.body, label %if.end38
IC: Visiting:   tail call void @llvm.primate.input.done()
IC: Visiting:   ret void
; *** IR Dump After InstCombinePass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 8
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 8
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 8
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
LoopSimplify: Creating dedicated exit block if.end38.loopexit
LoopSimplify: Creating dedicated exit block if.end38.loopexit63
Loop Unroll: F[_Z12primate_mainv] Loop %while.body
  Loop Size = 7
  will not try to unroll loop with runtime trip count -unroll-runtime not given
Loop Unroll: F[_Z12primate_mainv] Loop %while.body19
  Loop Size = 11
  will not try to unroll loop with runtime trip count -unroll-runtime not given
; *** IR Dump After LoopUnrollPass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 8
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 8
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 8
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit63

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit63:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit63, %if.end38.loopexit, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After WarnMissedTransformationsPass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %indirect-arg-temp43 = alloca i128, align 8
  %ref.tmp = alloca %struct.ethernet_t, align 8
  %ref.tmp1 = alloca %struct.ipv4_t, align 8
  %ref.tmp6 = alloca %struct.tcp_t, align 8
  %indirect-arg-temp = alloca i128, align 8
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  store %struct.ethernet_t %0, ptr %ref.tmp, align 8
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
  %2 = load i16, ptr %1, align 8
  %cmp = icmp eq i16 %2, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %3 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %3, i32 40)
  %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
  %5 = load i8, ptr %4, align 8
  switch i8 %5, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %6 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  store %struct.tcp_t %6, ptr %ref.tmp6, align 8
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %6, i32 32)
  %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
  %8 = load i4, ptr %7, align 8
  %or.cond = icmp sgt i4 %8, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %8 to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %9 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %9, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %10 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !8
  call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
  %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !8
  tail call void @llvm.primate.output.i128.i32(i128 %out.i, i32 16)
  call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !12

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit63

if.then33:                                        ; preds = %if.then
  %11 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %11, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit63:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit63, %if.end38.loopexit, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
SROA function: _Z12primate_mainv
SROA alloca:   %indirect-arg-temp = alloca i128, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %indirect-arg-temp = alloca i128, align 8
  [0,16) slice #0 (splittable)
    used by:   store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !7
  [0,16) slice #1 (splittable)
    used by:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,16) to:   %indirect-arg-temp = alloca i128, align 8
  rewriting [0,16) slice #0 (splittable)
   Begin:(0, 16) NewBegin:(0, 16) NewAllocaBegin:(0, 16)
    original:   store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !7
          to:   store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !7
  rewriting [0,16) slice #1 (splittable)
   Begin:(0, 16) NewBegin:(0, 16) NewAllocaBegin:(0, 16)
    original:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
          to:   store i128 %indirect-arg-temp.0.copyload, ptr %indirect-arg-temp43, align 8
  Speculating PHIs
  Rewriting Selects
Deleting dead instruction:   call void @llvm.memcpy.p0.p0.i64(ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp43, ptr noundef nonnull align 8 dereferenceable(16) %indirect-arg-temp, i64 16, i1 false)
Deleting dead instruction:   store i128 %10, ptr %indirect-arg-temp, align 8, !tbaa !7
SROA alloca:   %ref.tmp6 = alloca %struct.tcp_t, align 8
  Rewriting FCA loads and stores...
    original:   store %struct.tcp_t %6, ptr %ref.tmp6, align 8
          to:   store i96 %.fca.0.extract, ptr %.fca.0.gep, align 8
          to:   store i4 %.fca.1.extract, ptr %.fca.1.gep, align 8
          to:   store i60 %.fca.2.extract, ptr %.fca.2.gep, align 8
Slices of alloca:   %ref.tmp6 = alloca %struct.tcp_t, align 8
  [0,12) slice #0 (splittable)
    used by:   store i96 %.fca.0.extract, ptr %.fca.0.gep, align 8
  [16,17) slice #1
    used by:   %8 = load i4, ptr %7, align 8
  [16,17) slice #2
    used by:   store i4 %.fca.1.extract, ptr %.fca.1.gep, align 8
  [24,32) slice #3
    used by:   store i60 %.fca.2.extract, ptr %.fca.2.gep, align 8
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,12) to:   %ref.tmp6.sroa.0 = alloca i96, align 8
  rewriting [0,12) slice #0 (splittable)
   Begin:(0, 12) NewBegin:(0, 12) NewAllocaBegin:(0, 12)
    original:   store i96 %.fca.0.extract, ptr %.fca.0.gep, align 8
          to:   store i96 %.fca.0.extract, ptr %ref.tmp6.sroa.0, align 8
Rewriting alloca partition [16,17) to:   %ref.tmp6.sroa.1 = alloca i4, align 8
  rewriting [16,17) slice #1
   Begin:(16, 17) NewBegin:(16, 17) NewAllocaBegin:(16, 17)
    original:   %8 = load i4, ptr %7, align 8
          to:   %ref.tmp6.sroa.1.16. = load i4, ptr %ref.tmp6.sroa.1, align 8
  rewriting [16,17) slice #2
   Begin:(16, 17) NewBegin:(16, 17) NewAllocaBegin:(16, 17)
    original:   store i4 %.fca.1.extract, ptr %.fca.1.gep, align 8
          to:   store i4 %.fca.1.extract, ptr %ref.tmp6.sroa.1, align 8
Rewriting alloca partition [24,32) to:   %ref.tmp6.sroa.3 = alloca i60, align 8
  rewriting [24,32) slice #3
   Begin:(24, 32) NewBegin:(24, 32) NewAllocaBegin:(24, 32)
    original:   store i60 %.fca.2.extract, ptr %.fca.2.gep, align 8
          to:   store i60 %.fca.2.extract, ptr %ref.tmp6.sroa.3, align 8
  Speculating PHIs
  Rewriting Selects
Deleting dead instruction:   store i60 %.fca.2.extract, ptr %.fca.2.gep, align 8
Deleting dead instruction:   %.fca.2.gep = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 2
Deleting dead instruction:   store i4 %.fca.1.extract, ptr %.fca.1.gep, align 8
Deleting dead instruction:   %.fca.1.gep = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
Deleting dead instruction:   %8 = load i4, ptr %7, align 8
Deleting dead instruction:   %7 = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 1
Deleting dead instruction:   store i96 %.fca.0.extract, ptr %.fca.0.gep, align 8
Deleting dead instruction:   %.fca.0.gep = getelementptr inbounds %struct.tcp_t, ptr %ref.tmp6, i32 0, i32 0
Deleting dead instruction:   %ref.tmp6 = alloca %struct.tcp_t, align 8
SROA alloca:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
  Rewriting FCA loads and stores...
    original:   store %struct.ipv4_t %3, ptr %ref.tmp1, align 8
          to:   store i72 %.fca.0.extract65, ptr %.fca.0.gep, align 8
          to:   store i8 %.fca.1.extract66, ptr %.fca.1.gep, align 8
          to:   store i80 %.fca.2.extract67, ptr %.fca.2.gep, align 8
Slices of alloca:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
  [0,9) slice #0 (splittable)
    used by:   store i72 %.fca.0.extract65, ptr %.fca.0.gep, align 8
  [16,17) slice #1 (splittable)
    used by:   %5 = load i8, ptr %4, align 8
  [16,17) slice #2 (splittable)
    used by:   store i8 %.fca.1.extract66, ptr %.fca.1.gep, align 8
  [24,34) slice #3 (splittable)
    used by:   store i80 %.fca.2.extract67, ptr %.fca.2.gep, align 8
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,9) to:   %ref.tmp1.sroa.0 = alloca i72, align 8
  rewriting [0,9) slice #0 (splittable)
   Begin:(0, 9) NewBegin:(0, 9) NewAllocaBegin:(0, 9)
    original:   store i72 %.fca.0.extract65, ptr %.fca.0.gep, align 8
          to:   store i72 %.fca.0.extract65, ptr %ref.tmp1.sroa.0, align 8
Rewriting alloca partition [16,17) to:   %ref.tmp1.sroa.1 = alloca i8, align 8
  rewriting [16,17) slice #1 (splittable)
   Begin:(16, 17) NewBegin:(16, 17) NewAllocaBegin:(16, 17)
    original:   %5 = load i8, ptr %4, align 8
          to:   %ref.tmp1.sroa.1.16.load = load i8, ptr %ref.tmp1.sroa.1, align 8
  rewriting [16,17) slice #2 (splittable)
   Begin:(16, 17) NewBegin:(16, 17) NewAllocaBegin:(16, 17)
    original:   store i8 %.fca.1.extract66, ptr %.fca.1.gep, align 8
          to:   store i8 %.fca.1.extract66, ptr %ref.tmp1.sroa.1, align 8
Rewriting alloca partition [24,34) to:   %ref.tmp1.sroa.3 = alloca i80, align 8
  rewriting [24,34) slice #3 (splittable)
   Begin:(24, 34) NewBegin:(24, 34) NewAllocaBegin:(24, 34)
    original:   store i80 %.fca.2.extract67, ptr %.fca.2.gep, align 8
          to:   store i80 %.fca.2.extract67, ptr %ref.tmp1.sroa.3, align 8
  Speculating PHIs
  Rewriting Selects
Deleting dead instruction:   store i80 %.fca.2.extract67, ptr %.fca.2.gep, align 8
Deleting dead instruction:   %.fca.2.gep = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 2
Deleting dead instruction:   store i8 %.fca.1.extract66, ptr %.fca.1.gep, align 8
Deleting dead instruction:   %.fca.1.gep = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
Deleting dead instruction:   %5 = load i8, ptr %4, align 8
Deleting dead instruction:   %4 = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 1
Deleting dead instruction:   store i72 %.fca.0.extract65, ptr %.fca.0.gep, align 8
Deleting dead instruction:   %.fca.0.gep = getelementptr inbounds %struct.ipv4_t, ptr %ref.tmp1, i32 0, i32 0
Deleting dead instruction:   %ref.tmp1 = alloca %struct.ipv4_t, align 8
SROA alloca:   %ref.tmp = alloca %struct.ethernet_t, align 8
  Rewriting FCA loads and stores...
    original:   store %struct.ethernet_t %0, ptr %ref.tmp, align 8
          to:   store i48 %.fca.0.extract68, ptr %.fca.0.gep, align 8
          to:   store i48 %.fca.1.extract69, ptr %.fca.1.gep, align 8
          to:   store i16 %.fca.2.extract70, ptr %.fca.2.gep, align 8
Slices of alloca:   %ref.tmp = alloca %struct.ethernet_t, align 8
  [0,6) slice #0 (splittable)
    used by:   store i48 %.fca.0.extract68, ptr %.fca.0.gep, align 8
  [8,14) slice #1 (splittable)
    used by:   store i48 %.fca.1.extract69, ptr %.fca.1.gep, align 8
  [16,18) slice #2 (splittable)
    used by:   %2 = load i16, ptr %1, align 8
  [16,18) slice #3 (splittable)
    used by:   store i16 %.fca.2.extract70, ptr %.fca.2.gep, align 8
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,6) to:   %ref.tmp.sroa.0 = alloca i48, align 8
  rewriting [0,6) slice #0 (splittable)
   Begin:(0, 6) NewBegin:(0, 6) NewAllocaBegin:(0, 6)
    original:   store i48 %.fca.0.extract68, ptr %.fca.0.gep, align 8
          to:   store i48 %.fca.0.extract68, ptr %ref.tmp.sroa.0, align 8
Rewriting alloca partition [8,14) to:   %ref.tmp.sroa.1 = alloca i48, align 8
  rewriting [8,14) slice #1 (splittable)
   Begin:(8, 14) NewBegin:(8, 14) NewAllocaBegin:(8, 14)
    original:   store i48 %.fca.1.extract69, ptr %.fca.1.gep, align 8
          to:   store i48 %.fca.1.extract69, ptr %ref.tmp.sroa.1, align 8
Rewriting alloca partition [16,18) to:   %ref.tmp.sroa.2 = alloca i16, align 8
  rewriting [16,18) slice #2 (splittable)
   Begin:(16, 18) NewBegin:(16, 18) NewAllocaBegin:(16, 18)
    original:   %2 = load i16, ptr %1, align 8
          to:   %ref.tmp.sroa.2.16.load = load i16, ptr %ref.tmp.sroa.2, align 8
  rewriting [16,18) slice #3 (splittable)
   Begin:(16, 18) NewBegin:(16, 18) NewAllocaBegin:(16, 18)
    original:   store i16 %.fca.2.extract70, ptr %.fca.2.gep, align 8
          to:   store i16 %.fca.2.extract70, ptr %ref.tmp.sroa.2, align 8
  Speculating PHIs
  Rewriting Selects
Deleting dead instruction:   store i16 %.fca.2.extract70, ptr %.fca.2.gep, align 8
Deleting dead instruction:   %.fca.2.gep = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
Deleting dead instruction:   %2 = load i16, ptr %1, align 8
Deleting dead instruction:   %1 = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 2
Deleting dead instruction:   store i48 %.fca.1.extract69, ptr %.fca.1.gep, align 8
Deleting dead instruction:   %.fca.1.gep = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 1
Deleting dead instruction:   store i48 %.fca.0.extract68, ptr %.fca.0.gep, align 8
Deleting dead instruction:   %.fca.0.gep = getelementptr inbounds %struct.ethernet_t, ptr %ref.tmp, i32 0, i32 0
Deleting dead instruction:   %ref.tmp = alloca %struct.ethernet_t, align 8
SROA alloca:   %indirect-arg-temp43 = alloca i128, align 8
  Rewriting FCA loads and stores...
Slices of alloca:   %indirect-arg-temp43 = alloca i128, align 8
  [0,16) slice #0 (splittable)
    used by:   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !7
  [0,16) slice #1 (splittable)
    used by:   call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  [0,16) slice #2 (splittable)
    used by:   call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
  [0,16) slice #3 (splittable)
    used by:   store i128 %indirect-arg-temp.0.copyload, ptr %indirect-arg-temp43, align 8
Pre-splitting loads and stores
  Searching for candidate loads and stores
Rewriting alloca partition [0,16) to:   %indirect-arg-temp43 = alloca i128, align 8
  rewriting [0,16) slice #0 (splittable)
   Begin:(0, 16) NewBegin:(0, 16) NewAllocaBegin:(0, 16)
    original:   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !7
          to:   %indirect-arg-temp43.0.load = load i128, ptr %indirect-arg-temp43, align 8
  rewriting [0,16) slice #1 (splittable)
   Begin:(0, 16) NewBegin:(0, 16) NewAllocaBegin:(0, 16)
    original:   call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
          to:   call void @llvm.lifetime.start.p0(i64 16, ptr %indirect-arg-temp43)
  rewriting [0,16) slice #2 (splittable)
   Begin:(0, 16) NewBegin:(0, 16) NewAllocaBegin:(0, 16)
    original:   call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
          to:   call void @llvm.lifetime.end.p0(i64 16, ptr %indirect-arg-temp43)
  rewriting [0,16) slice #3 (splittable)
   Begin:(0, 16) NewBegin:(0, 16) NewAllocaBegin:(0, 16)
    original:   store i128 %indirect-arg-temp.0.copyload, ptr %indirect-arg-temp43, align 8
          to:   store i128 %indirect-arg-temp.0.copyload, ptr %indirect-arg-temp43, align 8
  Speculating PHIs
  Rewriting Selects
Deleting dead instruction:   store i128 %indirect-arg-temp.0.copyload, ptr %indirect-arg-temp43, align 8
Deleting dead instruction:   call void @llvm.lifetime.end.p0(i64 16, ptr nonnull %indirect-arg-temp43)
Deleting dead instruction:   call void @llvm.lifetime.start.p0(i64 16, ptr nonnull %indirect-arg-temp43)
Deleting dead instruction:   %out.i = load i128, ptr %indirect-arg-temp43, align 8, !tbaa !7
Promoting allocas with mem2reg...
; *** IR Dump After SROAPass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  %.fca.0.extract68 = extractvalue %struct.ethernet_t %0, 0
  %.fca.1.extract69 = extractvalue %struct.ethernet_t %0, 1
  %.fca.2.extract70 = extractvalue %struct.ethernet_t %0, 2
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %cmp = icmp eq i16 %.fca.2.extract70, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %1 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  %.fca.0.extract65 = extractvalue %struct.ipv4_t %1, 0
  %.fca.1.extract66 = extractvalue %struct.ipv4_t %1, 1
  %.fca.2.extract67 = extractvalue %struct.ipv4_t %1, 2
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %1, i32 40)
  switch i8 %.fca.1.extract66, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %2 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  %.fca.0.extract = extractvalue %struct.tcp_t %2, 0
  %.fca.1.extract = extractvalue %struct.tcp_t %2, 1
  %.fca.2.extract = extractvalue %struct.tcp_t %2, 2
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %2, i32 32)
  %or.cond = icmp sgt i4 %.fca.1.extract, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %.fca.1.extract to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %3 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %3, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %4 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  tail call void @llvm.primate.output.i128.i32(i128 %4, i32 16)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !8

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit63

if.then33:                                        ; preds = %if.then
  %5 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %5, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit63:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit63, %if.end38.loopexit, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After InferAlignmentPass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  %.fca.0.extract68 = extractvalue %struct.ethernet_t %0, 0
  %.fca.1.extract69 = extractvalue %struct.ethernet_t %0, 1
  %.fca.2.extract70 = extractvalue %struct.ethernet_t %0, 2
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %cmp = icmp eq i16 %.fca.2.extract70, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %1 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  %.fca.0.extract65 = extractvalue %struct.ipv4_t %1, 0
  %.fca.1.extract66 = extractvalue %struct.ipv4_t %1, 1
  %.fca.2.extract67 = extractvalue %struct.ipv4_t %1, 2
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %1, i32 40)
  switch i8 %.fca.1.extract66, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %2 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  %.fca.0.extract = extractvalue %struct.tcp_t %2, 0
  %.fca.1.extract = extractvalue %struct.tcp_t %2, 1
  %.fca.2.extract = extractvalue %struct.tcp_t %2, 2
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %2, i32 32)
  %or.cond = icmp sgt i4 %.fca.1.extract, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %.fca.1.extract to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %3 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %3, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %4 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  tail call void @llvm.primate.output.i128.i32(i128 %4, i32 16)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !8

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit63

if.then33:                                        ; preds = %if.then
  %5 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %5, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit63:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit63, %if.end38.loopexit, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}


INSTCOMBINE ITERATION #1 on _Z12primate_mainv
ADD:   ret void
ADD:   tail call void @llvm.primate.input.done()
ADD:   br label %if.end38
ADD:   br i1 %cmp13, label %while.body, label %if.end38.loopexit63
ADD:   %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
ADD:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
ADD:   br label %if.end38
ADD:   br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !7
ADD:   %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
ADD:   %sub20 = add nsw i32 %hdr_byte_left.155, -16
ADD:   tail call void @llvm.primate.output.i128.i32(i128 %4, i32 16)
ADD:   %4 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
ADD:   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
ADD:   br label %while.body19
ADD:   %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
ADD:   br i1 %cmp1854, label %while.body19.preheader, label %if.end38
ADD:   %cmp1854 = icmp ugt i32 %hdr_byte_left.053.lcssa, 1
ADD:   tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
ADD:   %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
ADD:   br label %cleanup
ADD:   tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
ADD:   %dec25 = add nsw i32 %hdr_byte_left.053, -1
ADD:   switch i8 %3, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]
ADD:   %3 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
ADD:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
ADD:   br label %while.body
ADD:   %mul = add nsw i32 %sub, -20
ADD:   %sub = shl nuw nsw i32 %conv12, 2
ADD:   %conv12 = zext nneg i4 %.fca.1.extract to i32
ADD:   br i1 %or.cond, label %while.body.preheader, label %if.end38
ADD:   %or.cond = icmp sgt i4 %.fca.1.extract, 5
ADD:   tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %2, i32 32)
IC: DCE:   %.fca.2.extract = extractvalue %struct.tcp_t %2, 2
ADD:   %.fca.1.extract = extractvalue %struct.tcp_t %2, 1
IC: DCE:   %.fca.0.extract = extractvalue %struct.tcp_t %2, 0
ADD:   %2 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
ADD:   br label %if.end38
ADD:   tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %5, i32 8)
ADD:   %5 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
ADD:   switch i8 %.fca.1.extract66, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]
ADD:   tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %1, i32 40)
IC: DCE:   %.fca.2.extract67 = extractvalue %struct.ipv4_t %1, 2
ADD:   %.fca.1.extract66 = extractvalue %struct.ipv4_t %1, 1
IC: DCE:   %.fca.0.extract65 = extractvalue %struct.ipv4_t %1, 0
ADD:   %1 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
ADD:   br i1 %cmp, label %if.then, label %if.end38
ADD:   %cmp = icmp eq i16 %.fca.2.extract70, 2048
ADD:   tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
ADD:   %.fca.2.extract70 = extractvalue %struct.ethernet_t %0, 2
IC: DCE:   %.fca.1.extract69 = extractvalue %struct.ethernet_t %0, 1
IC: DCE:   %.fca.0.extract68 = extractvalue %struct.ethernet_t %0, 0
ADD:   %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
IC: Visiting:   %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
IC: Visiting:   %.fca.2.extract70 = extractvalue %struct.ethernet_t %0, 2
IC: Visiting:   tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
IC: Visiting:   %cmp = icmp eq i16 %.fca.2.extract70, 2048
IC: Visiting:   br i1 %cmp, label %if.then, label %if.end38
IC: Visiting:   %1 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
IC: Visiting:   %.fca.1.extract66 = extractvalue %struct.ipv4_t %1, 1
IC: Visiting:   tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %1, i32 40)
IC: Visiting:   switch i8 %.fca.1.extract66, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]
IC: Visiting:   %5 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
IC: Visiting:   tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %5, i32 8)
IC: Visiting:   br label %if.end38
IC: Visiting:   %2 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
IC: Visiting:   %.fca.1.extract = extractvalue %struct.tcp_t %2, 1
IC: Visiting:   tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %2, i32 32)
IC: Visiting:   %or.cond = icmp sgt i4 %.fca.1.extract, 5
IC: Visiting:   br i1 %or.cond, label %while.body.preheader, label %if.end38
IC: Visiting:   %conv12 = zext nneg i4 %.fca.1.extract to i32
IC: Visiting:   %sub = shl nuw nsw i32 %conv12, 2
IC: Visiting:   %mul = add nsw i32 %sub, -20
IC: Visiting:   br label %while.body
IC: Visiting:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
IC: Visiting:   %3 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
IC: Visiting:   switch i8 %3, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]
IC: Visiting:   %dec25 = add nsw i32 %hdr_byte_left.053, -1
IC: Visiting:   tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
IC: Visiting:   br label %cleanup
IC: Visiting:   %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
IC: Replacing   %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
    with   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
IC: Mod =   %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
    New =   %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
IC: ERASE   %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
ADD DEFERRED:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
ADD:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
IC: Visiting:   %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
IC: Visiting:   tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
IC: Visiting:   %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
IC: Visiting:   br i1 %cmp1854, label %while.body19.preheader, label %if.end38
IC: Visiting:   %dec = add nsw i32 %hdr_byte_left.053, -1
IC: Visiting:   br label %while.body19
IC: Visiting:   %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
IC: Visiting:   %4 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
IC: Visiting:   tail call void @llvm.primate.output.i128.i32(i128 %4, i32 16)
IC: Visiting:   %sub20 = add nsw i32 %hdr_byte_left.155, -16
IC: Visiting:   %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
IC: Visiting:   br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !7
IC: Visiting:   br label %if.end38
IC: Visiting:   %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
IC: Visiting:   %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
IC: Visiting:   br i1 %cmp13, label %while.body, label %if.end38.loopexit63
IC: Visiting:   br label %if.end38
IC: Visiting:   tail call void @llvm.primate.input.done()
IC: Visiting:   ret void


[IC] Iteration limit #1 on _Z12primate_mainv reached; stopping without verifying fixpoint
; *** IR Dump After InstCombinePass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  %.fca.2.extract70 = extractvalue %struct.ethernet_t %0, 2
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %cmp = icmp eq i16 %.fca.2.extract70, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %1 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  %.fca.1.extract66 = extractvalue %struct.ipv4_t %1, 1
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %1, i32 40)
  switch i8 %.fca.1.extract66, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %2 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  %.fca.1.extract = extractvalue %struct.tcp_t %2, 1
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %2, i32 32)
  %or.cond = icmp sgt i4 %.fca.1.extract, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %.fca.1.extract to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %3 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %3, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %4 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  tail call void @llvm.primate.output.i128.i32(i128 %4, i32 16)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !8

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit63

if.then33:                                        ; preds = %if.then
  %5 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %5, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit63:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit63, %if.end38.loopexit, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LoopSimplifyPass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  %.fca.2.extract70 = extractvalue %struct.ethernet_t %0, 2
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %cmp = icmp eq i16 %.fca.2.extract70, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %1 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  %.fca.1.extract66 = extractvalue %struct.ipv4_t %1, 1
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %1, i32 40)
  switch i8 %.fca.1.extract66, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %2 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  %.fca.1.extract = extractvalue %struct.tcp_t %2, 1
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %2, i32 32)
  %or.cond = icmp sgt i4 %.fca.1.extract, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %.fca.1.extract to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %3 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %3, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %4 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  tail call void @llvm.primate.output.i128.i32(i128 %4, i32 16)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !8

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit63

if.then33:                                        ; preds = %if.then
  %5 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %5, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit63:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit63, %if.end38.loopexit, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LCSSAPass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  %.fca.2.extract70 = extractvalue %struct.ethernet_t %0, 2
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %cmp = icmp eq i16 %.fca.2.extract70, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %1 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  %.fca.1.extract66 = extractvalue %struct.ipv4_t %1, 1
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %1, i32 40)
  switch i8 %.fca.1.extract66, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %2 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  %.fca.1.extract = extractvalue %struct.tcp_t %2, 1
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %2, i32 32)
  %or.cond = icmp sgt i4 %.fca.1.extract, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %.fca.1.extract to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %3 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %3, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %4 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  tail call void @llvm.primate.output.i128.i32(i128 %4, i32 16)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !8

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit63

if.then33:                                        ; preds = %if.then
  %5 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %5, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit63:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit63, %if.end38.loopexit, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LICMPass on while.body ***

; Preheader:
while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %.fca.1.extract to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

; Loop:
while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %3 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %3, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit63

; Exit blocks
if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

if.end38.loopexit63:                              ; preds = %cleanup
  br label %if.end38
; *** IR Dump After LICMPass on while.body19 ***

; Preheader:
while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  br label %while.body19

; Loop:
while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %4 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  tail call void @llvm.primate.output.i128.i32(i128 %4, i32 16)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !7

; Exit blocks
if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38
; *** IR Dump After AlignmentFromAssumptionsPass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  %.fca.2.extract70 = extractvalue %struct.ethernet_t %0, 2
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %cmp = icmp eq i16 %.fca.2.extract70, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %1 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  %.fca.1.extract66 = extractvalue %struct.ipv4_t %1, 1
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %1, i32 40)
  switch i8 %.fca.1.extract66, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %2 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  %.fca.1.extract = extractvalue %struct.tcp_t %2, 1
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %2, i32 32)
  %or.cond = icmp sgt i4 %.fca.1.extract, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %.fca.1.extract to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %3 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %3, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %4 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  tail call void @llvm.primate.output.i128.i32(i128 %4, i32 16)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !8

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit63

if.then33:                                        ; preds = %if.then
  %5 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %5, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit63:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit63, %if.end38.loopexit, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After LoopSinkPass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  %.fca.2.extract70 = extractvalue %struct.ethernet_t %0, 2
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %cmp = icmp eq i16 %.fca.2.extract70, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %1 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  %.fca.1.extract66 = extractvalue %struct.ipv4_t %1, 1
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %1, i32 40)
  switch i8 %.fca.1.extract66, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %2 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  %.fca.1.extract = extractvalue %struct.tcp_t %2, 1
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %2, i32 32)
  %or.cond = icmp sgt i4 %.fca.1.extract, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %.fca.1.extract to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %3 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %3, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  %hdr_byte_left.053.lcssa = phi i32 [ %hdr_byte_left.053, %while.body ]
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053.lcssa, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053.lcssa, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %4 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  tail call void @llvm.primate.output.i128.i32(i128 %4, i32 16)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !8

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit63

if.then33:                                        ; preds = %if.then
  %5 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %5, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit63:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit63, %if.end38.loopexit, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After InstSimplifyPass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  %.fca.2.extract70 = extractvalue %struct.ethernet_t %0, 2
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %cmp = icmp eq i16 %.fca.2.extract70, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %1 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  %.fca.1.extract66 = extractvalue %struct.ipv4_t %1, 1
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %1, i32 40)
  switch i8 %.fca.1.extract66, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %2 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  %.fca.1.extract = extractvalue %struct.tcp_t %2, 1
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %2, i32 32)
  %or.cond = icmp sgt i4 %.fca.1.extract, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %.fca.1.extract to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %3 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %3, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %4 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  tail call void @llvm.primate.output.i128.i32(i128 %4, i32 16)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !8

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit63

if.then33:                                        ; preds = %if.then
  %5 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %5, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit63:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit63, %if.end38.loopexit, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After DivRemPairsPass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  %.fca.2.extract70 = extractvalue %struct.ethernet_t %0, 2
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %cmp = icmp eq i16 %.fca.2.extract70, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %1 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  %.fca.1.extract66 = extractvalue %struct.ipv4_t %1, 1
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %1, i32 40)
  switch i8 %.fca.1.extract66, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %2 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  %.fca.1.extract = extractvalue %struct.tcp_t %2, 1
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %2, i32 32)
  %or.cond = icmp sgt i4 %.fca.1.extract, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %.fca.1.extract to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %3 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %3, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %4 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  tail call void @llvm.primate.output.i128.i32(i128 %4, i32 16)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !8

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit63

if.then33:                                        ; preds = %if.then
  %5 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %5, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit63:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit63, %if.end38.loopexit, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After TailCallElimPass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  %.fca.2.extract70 = extractvalue %struct.ethernet_t %0, 2
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %cmp = icmp eq i16 %.fca.2.extract70, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %1 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  %.fca.1.extract66 = extractvalue %struct.ipv4_t %1, 1
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %1, i32 40)
  switch i8 %.fca.1.extract66, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %2 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  %.fca.1.extract = extractvalue %struct.tcp_t %2, 1
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %2, i32 32)
  %or.cond = icmp sgt i4 %.fca.1.extract, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %.fca.1.extract to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %3 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %3, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %4 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  tail call void @llvm.primate.output.i128.i32(i128 %4, i32 16)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38.loopexit, !llvm.loop !8

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38.loopexit63

if.then33:                                        ; preds = %if.then
  %5 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %5, i32 8)
  br label %if.end38

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38

if.end38.loopexit63:                              ; preds = %cleanup
  br label %if.end38

if.end38:                                         ; preds = %if.end38.loopexit63, %if.end38.loopexit, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
Looking to fold if.end38.loopexit into if.end38
Killing Trivial BB: 

if.end38.loopexit:                                ; preds = %while.body19
  br label %if.end38
Looking to fold if.end38.loopexit63 into if.end38
Killing Trivial BB: 

if.end38.loopexit63:                              ; preds = %cleanup
  br label %if.end38
; *** IR Dump After SimplifyCFGPass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  %.fca.2.extract70 = extractvalue %struct.ethernet_t %0, 2
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %cmp = icmp eq i16 %.fca.2.extract70, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %1 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  %.fca.1.extract66 = extractvalue %struct.ipv4_t %1, 1
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %1, i32 40)
  switch i8 %.fca.1.extract66, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %2 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  %.fca.1.extract = extractvalue %struct.tcp_t %2, 1
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %2, i32 32)
  %or.cond = icmp sgt i4 %.fca.1.extract, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %.fca.1.extract to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %3 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %3, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %4 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  tail call void @llvm.primate.output.i128.i32(i128 %4, i32 16)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !8

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %5 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %5, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After GlobalDCEPass on [module] ***
; ModuleID = 'tcp_parse.cpp'
source_filename = "tcp_parse.cpp"
target datalayout = "e-G1-m:e-p:32:32-i64:64-n32-S128"
target triple = "primate32-unknown-linux-gnu"

%struct.ethernet_t = type { i48, i48, i16 }
%struct.ipv4_t = type { i72, i8, i80 }
%struct.tcp_t = type { i96, i4, i60 }
%struct.udp_t = type { i64 }

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.done() #1

; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  %.fca.2.extract70 = extractvalue %struct.ethernet_t %0, 2
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %cmp = icmp eq i16 %.fca.2.extract70, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %1 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  %.fca.1.extract66 = extractvalue %struct.ipv4_t %1, 1
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %1, i32 40)
  switch i8 %.fca.1.extract66, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %2 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  %.fca.1.extract = extractvalue %struct.tcp_t %2, 1
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %2, i32 32)
  %or.cond = icmp sgt i4 %.fca.1.extract, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %.fca.1.extract to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %3 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %3, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %4 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  tail call void @llvm.primate.output.i128.i32(i128 %4, i32 16)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !8

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %5 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %5, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 i8 @llvm.primate.input.i8.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 i128 @llvm.primate.input.i128.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i8.i32(i8, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i128.i32(i128, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t, i32) #1

attributes #0 = { alwaysinline mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #1 = { nounwind }
attributes #2 = { mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5}
!llvm.ident = !{!6}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"ilp32"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{i32 8, !"SmallDataLimit", i32 8}
!6 = !{!"clang version 18.1.8 (git@github.com:FAST-Research-Group/primate-arch-gen.git e8582d4315ec2267abfc97212fa19f342d0812e8)"}
!7 = !{!"blue", !"IO", i64 1, i64 1}
!8 = distinct !{!8, !9}
!9 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After ConstantMergePass on [module] ***
; ModuleID = 'tcp_parse.cpp'
source_filename = "tcp_parse.cpp"
target datalayout = "e-G1-m:e-p:32:32-i64:64-n32-S128"
target triple = "primate32-unknown-linux-gnu"

%struct.ethernet_t = type { i48, i48, i16 }
%struct.ipv4_t = type { i72, i8, i80 }
%struct.tcp_t = type { i96, i4, i60 }
%struct.udp_t = type { i64 }

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.done() #1

; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  %.fca.2.extract70 = extractvalue %struct.ethernet_t %0, 2
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %cmp = icmp eq i16 %.fca.2.extract70, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %1 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  %.fca.1.extract66 = extractvalue %struct.ipv4_t %1, 1
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %1, i32 40)
  switch i8 %.fca.1.extract66, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %2 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  %.fca.1.extract = extractvalue %struct.tcp_t %2, 1
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %2, i32 32)
  %or.cond = icmp sgt i4 %.fca.1.extract, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %.fca.1.extract to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %3 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %3, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %4 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  tail call void @llvm.primate.output.i128.i32(i128 %4, i32 16)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !8

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %5 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %5, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 i8 @llvm.primate.input.i8.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 i128 @llvm.primate.input.i128.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i8.i32(i8, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i128.i32(i128, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t, i32) #1

attributes #0 = { alwaysinline mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #1 = { nounwind }
attributes #2 = { mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5}
!llvm.ident = !{!6}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"ilp32"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{i32 8, !"SmallDataLimit", i32 8}
!6 = !{!"clang version 18.1.8 (git@github.com:FAST-Research-Group/primate-arch-gen.git e8582d4315ec2267abfc97212fa19f342d0812e8)"}
!7 = !{!"blue", !"IO", i64 1, i64 1}
!8 = distinct !{!8, !9}
!9 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After CGProfilePass on [module] ***
; ModuleID = 'tcp_parse.cpp'
source_filename = "tcp_parse.cpp"
target datalayout = "e-G1-m:e-p:32:32-i64:64-n32-S128"
target triple = "primate32-unknown-linux-gnu"

%struct.ethernet_t = type { i48, i48, i16 }
%struct.ipv4_t = type { i72, i8, i80 }
%struct.tcp_t = type { i96, i4, i60 }
%struct.udp_t = type { i64 }

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.done() #1

; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  %.fca.2.extract70 = extractvalue %struct.ethernet_t %0, 2
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %cmp = icmp eq i16 %.fca.2.extract70, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %1 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  %.fca.1.extract66 = extractvalue %struct.ipv4_t %1, 1
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %1, i32 40)
  switch i8 %.fca.1.extract66, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %2 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  %.fca.1.extract = extractvalue %struct.tcp_t %2, 1
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %2, i32 32)
  %or.cond = icmp sgt i4 %.fca.1.extract, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %.fca.1.extract to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %3 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %3, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %4 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  tail call void @llvm.primate.output.i128.i32(i128 %4, i32 16)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !8

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %5 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %5, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 i8 @llvm.primate.input.i8.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 i128 @llvm.primate.input.i128.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i8.i32(i8, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i128.i32(i128, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t, i32) #1

attributes #0 = { alwaysinline mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #1 = { nounwind }
attributes #2 = { mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5}
!llvm.ident = !{!6}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"ilp32"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{i32 8, !"SmallDataLimit", i32 8}
!6 = !{!"clang version 18.1.8 (git@github.com:FAST-Research-Group/primate-arch-gen.git e8582d4315ec2267abfc97212fa19f342d0812e8)"}
!7 = !{!"blue", !"IO", i64 1, i64 1}
!8 = distinct !{!8, !9}
!9 = !{!"llvm.loop.mustprogress"}
Compiling to primate CPU: 
; *** IR Dump After RelLookupTableConverterPass on [module] ***
; ModuleID = 'tcp_parse.cpp'
source_filename = "tcp_parse.cpp"
target datalayout = "e-G1-m:e-p:32:32-i64:64-n32-S128"
target triple = "primate32-unknown-linux-gnu"

%struct.ethernet_t = type { i48, i48, i16 }
%struct.ipv4_t = type { i72, i8, i80 }
%struct.tcp_t = type { i96, i4, i60 }
%struct.udp_t = type { i64 }

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.input.done() #1

; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.done() #1

; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  %.fca.2.extract70 = extractvalue %struct.ethernet_t %0, 2
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %cmp = icmp eq i16 %.fca.2.extract70, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %1 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  %.fca.1.extract66 = extractvalue %struct.ipv4_t %1, 1
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %1, i32 40)
  switch i8 %.fca.1.extract66, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %2 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  %.fca.1.extract = extractvalue %struct.tcp_t %2, 1
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %2, i32 32)
  %or.cond = icmp sgt i4 %.fca.1.extract, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %.fca.1.extract to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %3 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %3, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %4 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  tail call void @llvm.primate.output.i128.i32(i128 %4, i32 16)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !8

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %5 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %5, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}

; Function Attrs: nounwind
declare !primate !7 %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 i8 @llvm.primate.input.i8.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 i128 @llvm.primate.input.i128.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i8.i32(i8, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.i128.i32(i128, i32) #1

; Function Attrs: nounwind
declare !primate !7 void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t, i32) #1

attributes #0 = { alwaysinline mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }
attributes #1 = { nounwind }
attributes #2 = { mustprogress nounwind "frame-pointer"="all" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit" }

!llvm.module.flags = !{!0, !1, !2, !3, !4, !5}
!llvm.ident = !{!6}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{i32 1, !"target-abi", !"ilp32"}
!2 = !{i32 8, !"PIC Level", i32 2}
!3 = !{i32 7, !"PIE Level", i32 2}
!4 = !{i32 7, !"frame-pointer", i32 2}
!5 = !{i32 8, !"SmallDataLimit", i32 8}
!6 = !{!"clang version 18.1.8 (git@github.com:FAST-Research-Group/primate-arch-gen.git e8582d4315ec2267abfc97212fa19f342d0812e8)"}
!7 = !{!"blue", !"IO", i64 1, i64 1}
!8 = distinct !{!8, !9}
!9 = !{!"llvm.loop.mustprogress"}
; *** IR Dump After AnnotationRemarksPass on _ZN7PRIMATE10input_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE10input_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.input.done()
  ret void
}
; *** IR Dump After AnnotationRemarksPass on _ZN7PRIMATE11output_doneEv ***
; Function Attrs: alwaysinline mustprogress nounwind
define dso_local void @_ZN7PRIMATE11output_doneEv() local_unnamed_addr #0 !primate !7 {
entry:
  tail call void @llvm.primate.output.done()
  ret void
}
; *** IR Dump After AnnotationRemarksPass on _Z12primate_mainv ***
; Function Attrs: mustprogress nounwind
define dso_local void @_Z12primate_mainv() local_unnamed_addr #2 {
entry:
  %0 = tail call %struct.ethernet_t @llvm.primate.input.s_struct.ethernet_ts.i32(i32 24)
  %.fca.2.extract70 = extractvalue %struct.ethernet_t %0, 2
  tail call void @llvm.primate.output.s_struct.ethernet_ts.i32(%struct.ethernet_t %0, i32 24)
  %cmp = icmp eq i16 %.fca.2.extract70, 2048
  br i1 %cmp, label %if.then, label %if.end38

if.then:                                          ; preds = %entry
  %1 = tail call %struct.ipv4_t @llvm.primate.input.s_struct.ipv4_ts.i32(i32 40)
  %.fca.1.extract66 = extractvalue %struct.ipv4_t %1, 1
  tail call void @llvm.primate.output.s_struct.ipv4_ts.i32(%struct.ipv4_t %1, i32 40)
  switch i8 %.fca.1.extract66, label %if.end38 [
    i8 6, label %if.then5
    i8 17, label %if.then33
  ]

if.then5:                                         ; preds = %if.then
  %2 = tail call %struct.tcp_t @llvm.primate.input.s_struct.tcp_ts.i32(i32 32)
  %.fca.1.extract = extractvalue %struct.tcp_t %2, 1
  tail call void @llvm.primate.output.s_struct.tcp_ts.i32(%struct.tcp_t %2, i32 32)
  %or.cond = icmp sgt i4 %.fca.1.extract, 5
  br i1 %or.cond, label %while.body.preheader, label %if.end38

while.body.preheader:                             ; preds = %if.then5
  %conv12 = zext nneg i4 %.fca.1.extract to i32
  %sub = shl nuw nsw i32 %conv12, 2
  %mul = add nsw i32 %sub, -20
  br label %while.body

while.body:                                       ; preds = %while.body.preheader, %cleanup
  %hdr_byte_left.053 = phi i32 [ %hdr_byte_left.2, %cleanup ], [ %mul, %while.body.preheader ]
  %3 = tail call i8 @llvm.primate.input.i8.i32(i32 1)
  switch i8 %3, label %cleanup [
    i8 0, label %if.then16
    i8 1, label %if.then23
  ]

if.then16:                                        ; preds = %while.body
  tail call void @llvm.primate.output.i8.i32(i8 0, i32 1)
  %cmp1854 = icmp ugt i32 %hdr_byte_left.053, 1
  br i1 %cmp1854, label %while.body19.preheader, label %if.end38

while.body19.preheader:                           ; preds = %if.then16
  %dec = add nsw i32 %hdr_byte_left.053, -1
  br label %while.body19

while.body19:                                     ; preds = %while.body19.preheader, %while.body19
  %hdr_byte_left.155 = phi i32 [ %sub20, %while.body19 ], [ %dec, %while.body19.preheader ]
  %4 = tail call i128 @llvm.primate.input.i128.i32(i32 16)
  tail call void @llvm.primate.output.i128.i32(i128 %4, i32 16)
  %sub20 = add nsw i32 %hdr_byte_left.155, -16
  %cmp18 = icmp ugt i32 %hdr_byte_left.155, 16
  br i1 %cmp18, label %while.body19, label %if.end38, !llvm.loop !8

if.then23:                                        ; preds = %while.body
  %dec25 = add nsw i32 %hdr_byte_left.053, -1
  tail call void @llvm.primate.output.i8.i32(i8 1, i32 1)
  br label %cleanup

cleanup:                                          ; preds = %if.then23, %while.body
  %hdr_byte_left.2 = phi i32 [ %dec25, %if.then23 ], [ %hdr_byte_left.053, %while.body ]
  %cmp13 = icmp sgt i32 %hdr_byte_left.2, 0
  br i1 %cmp13, label %while.body, label %if.end38

if.then33:                                        ; preds = %if.then
  %5 = tail call %struct.udp_t @llvm.primate.input.s_struct.udp_ts.i32(i32 8)
  tail call void @llvm.primate.output.s_struct.udp_ts.i32(%struct.udp_t %5, i32 8)
  br label %if.end38

if.end38:                                         ; preds = %cleanup, %while.body19, %if.then16, %if.then, %if.then5, %if.then33, %entry
  tail call void @llvm.primate.input.done()
  ret void
}
23 warnings generated.
