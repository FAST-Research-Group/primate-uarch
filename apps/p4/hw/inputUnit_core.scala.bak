import chisel3._
import chisel3.util._

class Shifter(num_bytes: Int) extends Module {
  val io = IO(new Bundle{
    val buf_in     = Input(Vec(2*num_bytes, UInt(8.W)))
    val fifo_in    = Input(Vec(num_bytes, UInt(8.W)))
    val length     = Input(UInt((log2Up(num_bytes)+2).W))
    val shift      = Input(UInt((log2Up(num_bytes)+1).W))
    val buf_out    = Output(Vec(2*num_bytes, UInt(8.W)))
  })

  val buf_out_r = Reg(Vec(2*num_bytes, UInt(8.W)))
  for (i <- 0 until 2*num_bytes) {
    when (i.U < io.length - io.shift) {
      buf_out_r(i) := io.buf_in(i.U + io.shift)
    } .otherwise {
      buf_out_r(i) := io.fifo_in(i.U - (io.length - io.shift))
    }
  }
  io.buf_out := buf_out_r

}

class inputUnit_core(reg_width: Int, num_regs_lg: Int, opcode_width: Int, num_threads: Int) extends Module {
  val io = IO(new Bundle {
    val in_valid     = Input(Bool())
    val in_tag       = Input(UInt(log2Up(num_threads).W))
    val in_data      = Input(UInt(512.W))
    val in_empty     = Input(UInt(6.W))
    val in_last      = Input(Bool())
    val in_ready     = Output(Bool())

    val out_ready    = Input(Bool())
    val out_valid    = Output(Bool())
    val out_tag      = Output(UInt(log2Up(num_threads).W))
    val out_wen      = Output(Bool())
    val out_addr     = Output(UInt(num_regs_lg.W))
    val out_data     = Output(UInt(reg_width.W))

    val ar_valid     = Input(Bool())
    val ar_tag       = Input(UInt(log2Up(num_threads).W))
    val ar_opcode    = Input(UInt(opcode_width.W))
    val ar_rd        = Input(UInt(num_regs_lg.W))
    val ar_bits      = Input(UInt(32.W))
    val ar_imm       = Input(UInt(32.W))
    val ar_ready     = Output(Bool())

    // To output unit
    val pkt_buf_data  = Output(new pkt_buf_t(num_threads))
    val pkt_buf_valid = Output(Bool())
    val pkt_buf_ready = Input(Bool())
  })
  // opcode(0) = 0: not write back, 1: write back
  // opcode(1) = 0: not shift, 1: shift
  // opcode(2) = 0: parse not done, 1: parse done
  // opcode(3) = 0: select imm, 1: select reg

  val PKT_BUF_DEPTH = 512

  val parseFifo_t = new Bundle {
    val bits = UInt(256.W)
    val length = UInt(6.W)
    val last = Bool()
  }

  val pktFifo = Module(new Queue(new pkt_buf_t(num_threads), PKT_BUF_DEPTH))
  val parseFifo = Module(new Queue(parseFifo_t, 2))
  val parseDone = RegInit(false.B)
  val parseFifoEnqState = RegInit(0.U(1.W))
  val shifter = Module(new Shifter(32))
  val buf = Reg(Vec(64, UInt(8.W)))
  val length = RegInit(0.U(7.W))
  val isLast = RegInit(false.B)

  io.in_ready := false.B
  parseFifo.io.enq.valid := false.B
  parseFifo.io.enq.bits := DontCare
  when (!parseDone || (parseFifoEnqState === 1.U)) {
    when (io.in_valid && parseFifo.io.enq.ready) {
      when (parseFifoEnqState === 0.U) {
        parseFifo.io.enq.valid := true.B
        parseFifo.io.enq.bits.bits := io.in_data(255, 0)
        when (io.in_empty >= 32.U) {
          parseFifo.io.enq.bits.length := io.in_empty
        }
        parseFifo.io.enq.bits.last := false.B
        parseFifoEnqState := 1.U
      } .otherwise {
        parseFifo.io.enq.valid := true.B
        parseFifo.io.enq.bits.bits := io.in_data(511, 256)
        parseFifo.io.enq.bits.last := io.in_last
        io.in_ready := true.B
        parseFifoEnqState := 0.U
      }
    }
  }

  val seek_valid = RegInit(false.B)
  val parseFifoDeqValid = Reg(Bool())
  val seekState = RegInit(0.U(3.W))
  val tag = Reg(UInt(log2Up(num_threads).W))
  val addr = Reg(UInt(num_regs_lg.W))
  val headerLen = Reg(UInt(6.W))
  val opcode = Reg(UInt(opcode_width.W))
  val fillEn = Reg(Bool())
  val pktFifo_in_r = Reg(UInt(256.W))
  val lastSeen = RegInit(false.B)

  val outBuf = shifter.io.buf_out
  shifter.io.buf_in := buf.asTypeOf(chiselTypeOf(shifter.io.buf_in))
  shifter.io.fifo_in := parseFifo.io.deq.bits.bits.asTypeOf(chiselTypeOf(shifter.io.fifo_in))
  shifter.io.length := length
  shifter.io.shift := 0.U

  io.out_valid := false.B
  io.out_wen := false.B
  io.out_tag := tag
  io.out_addr := addr
  io.out_data := buf.asUInt
  io.ar_ready := false.B
  parseFifoDeqValid := parseFifo.io.deq.valid
  parseFifo.io.deq.ready := false.B
  pktFifo.io.enq.valid := false.B
  pktFifo.io.enq.bits := DontCare
  when (seekState === 0.U) {
    // IDLE
    io.ar_ready := true.B
    when (io.ar_valid) {
      tag := io.ar_tag
      addr := io.ar_rd
      val ar_src = Mux(io.ar_opcode(3).asBool, io.ar_bits, io.ar_imm)
      headerLen := ar_src(5, 0)
      opcode := io.ar_opcode
      when (io.ar_opcode(1) === 1.U && (length >= ar_src(5, 0))) {
        shifter.io.shift := ar_src(5, 0)
      }
      when (length - ar_src(5, 0) <= 32.U) {
        fillEn := true.B
      } .otherwise {
        fillEn := false.B
      }
      when (io.ar_opcode(1, 0) =/= 0.U) {
        when (length < ar_src(5, 0)) {
          // Not enough data, need to fill first
          seekState := 3.U
        } .otherwise {
          seekState := 2.U
        }
      } .elsewhen (io.ar_opcode(2) === 1.U) {
        parseDone := true.B
        seekState := 4.U
      }
    } .elsewhen (length <= 32.U && parseFifo.io.deq.valid) {
      opcode := 0.U
      seekState := 3.U
    }
  } .elsewhen (seekState === 1.U) {
    // Resume
    when (opcode(1) === 1.U) {
      shifter.io.shift := headerLen
    }
    when (length - headerLen <= 32.U) {
      fillEn := true.B
    } .otherwise {
      fillEn := false.B
    }
    seekState := 2.U
  } .elsewhen (seekState === 2.U) {
    // Output, shift
    when (opcode(0) === 1.U) {
      io.out_wen := true.B
    }
    when (opcode(0) === 0.U || io.out_ready) {
      when (opcode(1) === 1.U) {
        // Shift
        buf := outBuf
        when (opcode(2) === 1.U) {
          parseDone := true.B
          seekState := 4.U
        } .otherwise {
          io.out_valid := true.B
          seekState := 0.U
        }
        when (parseFifoDeqValid && fillEn && (!isLast)) {
          parseFifo.io.deq.ready := true.B
          length := length - headerLen + 32.U
          when (parseFifo.io.deq.bits.last) {
            isLast := true.B
          }
        } .otherwise {
          length := length - headerLen
        }
      } .elsewhen (opcode(2) === 1.U) {
        // Parse done
        parseDone := true.B
        seekState := 4.U
      }
    }
  } .elsewhen (seekState === 3.U) {
    // Fill
    when (parseFifoDeqValid && (!isLast)) {
      parseFifo.io.deq.ready := true.B
      length := length + 32.U
      buf := outBuf
      when (parseFifo.io.deq.bits.last) {
        isLast := true.B
      }
      when (opcode(1, 0) === 0.U) {
        seekState := 0.U
      } .otherwise {
        seekState := 1.U
      }
    } .otherwise {
      seekState := 0.U
    }
  } .elsewhen (seekState === 4.U) {
    // dump out the remaining data in the buffer
    val pktFifo_in = Wire(new pkt_buf_t(num_threads))
    pktFifo_in.data := buf.asUInt
    pktFifo_in.last := isLast
    pktFifo_in.tag := tag
    pktFifo_in.empty := 64.U - length
    pktFifo.io.enq.valid := true.B
    pktFifo.io.enq.bits := pktFifo_in
    when (pktFifo.io.enq.ready) {
      when (isLast) {
        isLast := false.B
        parseDone := false.B
        seekState := 0.U
      } .otherwise {
        seekState := 5.U
      }
    }
  } .elsewhen (seekState === 5.U) {
    // drain parseFifo
    length := 0.U
    when (parseFifoDeqValid) {
      pktFifo_in_r := parseFifo.io.deq.bits.bits
      parseFifo.io.deq.ready := true.B
      seekState := 6.U
      when (parseFifo.io.deq.bits.last) {
        lastSeen := true.B
      }
    } .otherwise {
      seekState := 7.U
    }
  } .elsewhen (seekState === 6.U) {
    when (lastSeen || (!parseFifoDeqValid)) {
      pktFifo.io.enq.bits.data := pktFifo_in_r
      pktFifo.io.enq.bits.tag := tag
      pktFifo.io.enq.bits.last := lastSeen
      pktFifo.io.enq.bits.empty := 32.U
      pktFifo.io.enq.valid := true.B
      when (pktFifo.io.enq.ready) {
        when (lastSeen) {
          parseDone := false.B
          lastSeen := false.B
          seekState := 0.U
        } .otherwise {
          seekState := 7.U
        }
      }
    } .elsewhen (parseFifoDeqValid) {
      pktFifo.io.enq.bits.data := Cat(parseFifo.io.deq.bits.bits, pktFifo_in_r)
      pktFifo.io.enq.bits.tag := tag
      pktFifo.io.enq.bits.last := parseFifo.io.deq.bits.last
      pktFifo.io.enq.bits.empty := 0.U
      pktFifo.io.enq.valid := true.B
      when (pktFifo.io.enq.ready) {
        parseFifo.io.deq.ready := true.B
        when (parseFifo.io.deq.bits.last) {
          parseDone := false.B
          seekState := 0.U
        } .otherwise {
          seekState := 5.U
        }
      }
    }
  } .elsewhen (seekState === 7.U) {
    // drain remaining flits
    io.in_ready := pktFifo.io.enq.ready
    when (io.in_valid) {
      pktFifo.io.enq.bits.data := io.in_data
      pktFifo.io.enq.bits.tag := tag
      pktFifo.io.enq.bits.last := io.in_last
      pktFifo.io.enq.bits.empty := io.in_empty
      pktFifo.io.enq.valid := true.B
      when (pktFifo.io.enq.ready) {
        when (io.in_last) {
          io.out_valid := true.B
          parseDone := false.B
          seekState := 0.U
        }
      }
    }
  }

  io.pkt_buf_data := pktFifo.io.deq.bits
  io.pkt_buf_valid := pktFifo.io.deq.valid
  pktFifo.io.deq.ready := io.pkt_buf_ready

}